<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解Android之Activity启动流程]]></title>
    <url>%2F2020%2F10%2F15%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%B9%8BActivity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在进阶Android的路上，了解理解一个应用根Activity启动流程可以作为一个切入点，由此展开进阶之路。平时我们开发的应用都是展示在Android系统桌面上，这个系统桌面其实也是一个Android应用，它叫Launcher。所以本文通过源码层面从Launcher调用ATMS，ATMS调用ApplicationThread，最后ActivityThread启动Activity三个过程了解Activity启动流程（文中源码基于Android 10 ）。 Android源码地址 首先来个脑图，对于整体模块在大脑中形成一个整体印象 Launcher到ActivityTaskManagerServiceLauncher 调用 Activity 至于Launcher如何加载展示应用程序到界面这里先略过（与PMS相关），本文先关注Activity启动过程。当我们点击系统桌面的应用图标，直接响应的则是Launcher这个应用程序，会调用它的startActivitySafely方法 packages/apps/Launcher3/src/com/android/launcher3/Launcher.java 12345678910111213141516public boolean startActivitySafely(View v, Intent intent, ItemInfo item, @Nullable String sourceContainer) &#123; ..... boolean success = super.startActivitySafely(v, intent, item, sourceContainer); // 1 if (success &amp;&amp; v instanceof BubbleTextView) &#123; // This is set to the view that launched the activity that navigated the user away // from launcher. Since there is no callback for when the activity has finished // launching, enable the press state and keep this reference to reset the press // state when we return to launcher. BubbleTextView btv = (BubbleTextView) v; btv.setStayPressed(true); addOnResumeCallback(btv); &#125; return success; &#125; 通过以上源码，在注释1调用的是父类的startActivitySafely方法，Launcher类本身就是Activity,它的父类为BaseDraggingActivity，接着看到它的startActivitySafely方法 packages/apps/Launcher3/src/com/android/launcher3/BaseDraggingActivity.java 12345678910111213141516171819202122232425262728293031public boolean startActivitySafely(View v, Intent intent, @Nullable ItemInfo item, @Nullable String sourceContainer) &#123; ....... // Prepare intent intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); //1 if (v != null) &#123; intent.setSourceBounds(getViewBounds(v)); &#125; try &#123; ...... if (isShortcut) &#123; // Shortcuts need some special checks due to legacy reasons. startShortcutIntentSafely(intent, optsBundle, item, sourceContainer); &#125; else if (user == null || user.equals(Process.myUserHandle())) &#123; // Could be launching some bookkeeping activity startActivity(intent, optsBundle);//2 AppLaunchTracker.INSTANCE.get(this).onStartApp(intent.getComponent(), Process.myUserHandle(), sourceContainer); &#125; else &#123; ....... &#125; getUserEventDispatcher().logAppLaunch(v, intent); getStatsLogManager().logAppLaunch(v, intent); return true; &#125; catch (NullPointerException|ActivityNotFoundException|SecurityException e) &#123; Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show(); Log.e(TAG, "Unable to launch. tag=" + item + " intent=" + intent, e); &#125; return false; &#125; 以上源码看到注释1，设置启动Activity的Flag为FLAG_ACTIVITY_NEW_TASK，设置这个Flag则Activity的启动就会在新的任务栈中启动，后面还会遇到它；接着看到注释2，调用了startActivity的方法，显然这就是调用了Activity类的startActivity方法。继续探究Activity类的startActivity方法 frameworks/base/core/java/android/app/Activity.java 12345678910@Override public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options);//1 &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125; &#125; 有以上源码看到注释1，Activity类的startActivity方法调用的是startActivityForResult方法，这个方法日常开发启动Activity有参数回调也会使用，这里参数传入-1，表明Launcher启动Activity并不管它成功与否。接着看startActivityForResult方法 frameworks/base/core/java/android/app/Activity.java 123456789101112131415Activity mParent;public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; //1 options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options);//2 ...... &#125; else &#123; ...... &#125; &#125; 通过以上源码看到注释1，mParent的声明类型为Activity，当前还是正在起Activity，mParent == null成立，看到注释2调用了Instrumentation类的execStartActivity方法，Instrumentation允许您监视系统与应用程序之间的所有交互（Instrumentation注释：allowing you to monitor all of the interaction the system has with the application.），接着看到它的execStartActivity方法 Instrumentation 调用到ATMS frameworks/base/core/java/android/app/Instrumentation.java 1234567891011121314151617181920@UnsupportedAppUsage public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread;//1 ...... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityTaskManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //2 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException("Failure from system", e); &#125; return null; &#125; 通过以上源码看到注释1，这里获取了IApplicationThread，如果你了解Binder，第一反应就应该很清晰，目前处于Launcher应用程序进程，要启动Activity则需要请求系统服务进程（SystemServer）,而Android进程间通信则可以使用Binder，而这里实现方式为AIDL，它的实现类为ActivityThread的内部类ApplicationThread，而ApplicationThread作用则为应用程序进程和系统服务进程通信的桥梁，后面还会继续提到；接着看到注释2，这里调用ActivityTaskManager.getService则可以获取ActivityTaskManagerService的代理对象，看看他的实现 frameworks/base/core/java/android/app/ActivityTaskManager.java 12345678910111213public static IActivityTaskManager getService() &#123; return IActivityTaskManagerSingleton.get(); &#125; @UnsupportedAppUsage(trackingBug = 129726065) private static final Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton = new Singleton&lt;IActivityTaskManager&gt;() &#123; @Override protected IActivityTaskManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);//1 return IActivityTaskManager.Stub.asInterface(b); //2 &#125; &#125;; 由以上源码注释1，通过ServiceManager来获取远程服务ActivityTaskManagerService，ServiceManager底层最终调用的还是c++层的ServiceManager，它是Binder的守护服务，通过它能够获取在Android系统启动时注册的系统服务，这其中就包含这里提到的ATMS；接着回到注释2建立 Launcher与 ATMS的连接，这样回到execStartActivity方法，Launcher就通过调用ATMS的startActivity方法将启动Activity的数据交给ATMS服务来处理了。 为了更好理解，看看Launcher调用到ActivityTaskManagerService时序图来对上面的步骤进行回顾 ActivityTaskManagerService 调用ApplicationThreadATMS处理启动Activity请求 通过上一小节，启动应用程序Activity已经走到ActivityTaskManagerService中，如果你熟悉前以往版本的Android源码，你肯定会知道ActivityManagerService，而在Android 10 中则将AMS用于管理Activity及其容器（任务，堆栈，显示等）的系统服务分离出来放到ATMS中，也许是谷歌不想让AMS的代码越来越膨胀吧(Android 10中AMS代码有一万九千行)。好了，接着看到ATMS的startActivity方法 frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java 12345678@Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());//1 &#125; 由以上代码，继续调用了startActivityAsUser方法，该方法多传入了用户的ID，接着会判断是否有权限调用，没有权限调用则抛出异常，否则获取用户id用于后续进程间Binder通信。接着继续看startActivityAsUser方法 frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java 123456789101112131415161718192021222324252627282930313233@Override public int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId, true /*validateIncomingUser*/);//1 &#125; int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) &#123; enforceNotIsolatedCaller("startActivityAsUser"); userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), "startActivityAsUser"); // TODO: Switch to user app stacks here. return getActivityStartController().obtainStarter(intent, "startActivityAsUser") .setCaller(caller) .setCallingPackage(callingPackage) .setResolvedType(resolvedType) .setResultTo(resultTo) .setResultWho(resultWho) .setRequestCode(requestCode) .setStartFlags(startFlags) .setProfilerInfo(profilerInfo) .setActivityOptions(bOptions) .setMayWait(userId) .execute();//2 &#125; 由以上代码，注释1调用了ATMS自己实现的startActivityAsUser方法，在注释而2处构造了ActivityStarter，此类收集了用于确定将意图和标志如何转换为活动以及关联的任务和堆栈的所有逻辑，obtainStarter方法第二个参数代表启动Activity的意图，接着调用了execute方法， frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java 1234567891011121314151617181920int execute() &#123; try &#123; // TODO(b/64750076): Look into passing request directly to these methods to allow // for transactional diffs and preprocessing. if (mRequest.mayWait) &#123; //1 return startActivityMayWait(mRequest.caller, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.intent, mRequest.resolvedType, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.startFlags, mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart);//2 &#125; ...... &#125; ....... &#125; 由以上代码看到注释1，前面构造ActivityStarter已经传入了用户id，所以这里判断条件成立，则继续调用startActivityMayWait方法 frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java 12345678910111213141516171819202122private int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, int requestRealCallingPid, int requestRealCallingUid, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity, int userId, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup, PendingIntentRecord originatingPendingIntent, boolean allowBackgroundActivityStart) &#123; ...... final ActivityRecord[] outRecord = new ActivityRecord[1];//1 int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason, allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent, allowBackgroundActivityStart);//2 ...... return res; &#125; &#125; 由以上代码，可以看到注释1处创建了一个ActivityRecord数组，ActivityRecord代表一个Activity,接着调用了startActivity方法， frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup, PendingIntentRecord originatingPendingIntent, boolean allowBackgroundActivityStart) &#123; mSupervisor.getActivityMetricsLogger().notifyActivityLaunching(intent); int err = ActivityManager.START_SUCCESS; // Pull the optional Ephemeral Installer-only bundle out of the options early. final Bundle verificationBundle = options != null ? options.popAppVerificationBundle() : null; WindowProcessController callerApp = null; if (caller != null) &#123;//1 callerApp = mService.getProcessController(caller);//2 if (callerApp != null) &#123; callingPid = callerApp.getPid(); callingUid = callerApp.mInfo.uid; &#125; else &#123; Slog.w(TAG, "Unable to find app for caller " + caller + " (pid=" + callingPid + ") when starting: " + intent.toString()); err = ActivityManager.START_PERMISSION_DENIED; &#125; &#125; ....... ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid, callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, mSupervisor, checkedOptions, sourceRecord); if (outActivity != null) &#123; outActivity[0] = r;//3 &#125; ...... final int res = startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask, outActivity, restrictedBgActivity);//4 ..... return res; &#125; 由以上代码，startActivity里面有很多的逻辑代码，这里只看一些重点的逻辑代码，主要做了两个事情：（1）注释1处判断IApplicationThread是否为空，前面第一小节我们就已经提到过，它代表的就是Launcher进程的ApplicationThread，注释2通过与即将要启动的应用程序进程建立联系，应用程序进程的是fork到Zyote进程，这里先不进行展开了,先专注Activity启动流程。接着注释3创建ActivityRecord代表即将要启动的Activity，包含了Activity的所有信息，并赋值给上一步骤中创建的ActivityRecord类型的outActivity，注释4则继续调用startActivity方法 frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java 123456789101112131415private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity, boolean restrictedBgActivity) &#123; int result = START_CANCELED; final ActivityStack startedActivityStack; try &#123; mService.mWindowManager.deferSurfaceLayout(); result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity, restrictedBgActivity);//1 &#125; ........ return result; &#125; 由以上代码，注释1处startActivity又调用了startActivityUnchecked方法 frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java 123456789101112131415161718192021222324252627282930313233343536373839// Note: This method should only be called from &#123;@link startActivity&#125;. private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity, boolean restrictedBgActivity) &#123; ...... final TaskRecord taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != null) ? mSourceRecord.getTaskRecord() : null; // Should this be considered a new task? int result = START_SUCCESS; if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123; //1 newTask = true; result = setTaskFromReuseOrCreateNewTask(taskToAffiliate); //2 &#125; ........ if (mDoResume) &#123; final ActivityRecord topTaskActivity = mStartActivity.getTaskRecord().topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; mTargetStack.ensureActivitiesVisibleLocked(mStartActivity, 0, !PRESERVE_WINDOWS); mTargetStack.getDisplay().mDisplayContent.executeAppTransition(); &#125; else &#123; // If the target stack was not previously focusable (previous top running activity // on that stack was not visible) then any prior calls to move the stack to the // will not update the focused stack. If starting the new activity now allows the // task stack to be focusable, then ensure that we now update the focused stack // accordingly. if (mTargetStack.isFocusable() &amp;&amp; !mRootActivityContainer.isTopDisplayFocusedStack(mTargetStack)) &#123; mTargetStack.moveToFront("startActivityUnchecked"); &#125; mRootActivityContainer.resumeFocusedStacksTopActivities( mTargetStack, mStartActivity, mOptions);//3 &#125; &#125; 由上代码注释1，在前面第一节Launcher部分中有提到过设置了Flag为FLAG_ACTIVITY_NEW_TASK，所以注意判断条件成立，则调用setTaskFromReuseOrCreateNewTask，它内部会创建的TaskRecord（代表Activity的任务栈），并将传入的TaskRecord对象设置给代表启动的Activity的ActivityRecord，接着在注释3调用了RootActivityContainer的resumeFocusedStacksTopActivities方法，RootActivityContainer 将一些东西从ActivityStackSupervisor中分离出来。目的是将其与RootWindowContainer合并，作为统一层次结构的一部分，接着看它的resumeFocusedStacksTopActivities方法 frameworks/base/services/core/java/com/android/server/wm/RootActivityContainer.java 123456789101112131415boolean resumeFocusedStacksTopActivities( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; ...... boolean result = false; if (targetStack != null &amp;&amp; (targetStack.isTopStackOnDisplay() || getTopDisplayFocusedStack() == targetStack)) &#123; result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);//1 &#125; ....... return result; &#125; 由以上代码注释1处，又调用了ActivityStack的resumeTopActivityUncheckedLocked方法，ActivityStack应该算是任务栈的描述，它管理者一个应用的所有TaskRecord和他们的状态，接着看到它的resumeTopActivityUncheckedLocked方法 frameworks/base/services/core/java/com/android/server/wm/ActivityStack.java 12345678910111213141516171819//确保栈顶 activity 为Resumeboolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; if (mInResumeTopActivity) &#123; // Don't even start recursing. return false; &#125; boolean result = false; try &#123; // 防止递归 mInResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); //1 ........ &#125; finally &#123; mInResumeTopActivity = false; &#125; return result; &#125; 由以上代码，在注释1处接着又调用ActivityStack的resumeTopActivityInnerLocked方法 frameworks/base/services/core/java/com/android/server/wm/ActivityStack.java 1234567891011@GuardedBy("mService") private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; .... // Whoops, need to restart this activity! ........ mStackSupervisor.startSpecificActivityLocked(next, true, true);//1 ........ &#125; 由以上代码看到注释1，resumeTopActivityInnerLocked方法中逻辑非常多，这里直接精简到这一句关键代码，调用了ActivityStackSupervisor的startSpecificActivityLocked方法 ActivityStackSupervisor 启动Activity frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java 1234567891011121314151617181920212223242526272829void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Activity应用程序进程是否已经准备好 final WindowProcessController wpc = mService.getProcessController(r.processName, r.info.applicationInfo.uid); boolean knownToBeDead = false; if (wpc != null &amp;&amp; wpc.hasThread()) &#123; //1 try &#123; realStartActivityLocked(r, wpc, andResume, checkConfig); //2 return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Exception when starting activity " + r.intent.getComponent().flattenToShortString(), e); &#125; ....... &#125; ....... try &#123; ....... // Post message to start process to avoid possible deadlock of calling into AMS with the // ATMS lock held. final Message msg = PooledLambda.obtainMessage( ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName, r.info.applicationInfo, knownToBeDead, "activity", r.intent.getComponent());//3 mService.mH.sendMessage(msg); &#125; ........ &#125; 如上代码所示注释1，判断要启动的应用程序进程是否已经准备好，hasThread则是确定应用程序进程的IApplicationThread是否存在，如果存在则调用ActivityStackSupervisor的realStartActivityLocked方法启动Activity；如果是第一次启动，则应用程序进程没有准备好，则会走到注释3处启动应用程序进程，本文先跳过，留到下篇文章在探究。接下来继续看到realStartActivityLocked方法 frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java 123456789101112131415161718192021222324252627282930313233343536boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc, boolean andResume, boolean checkConfig) throws RemoteException &#123; ....... // Create activity launch transaction. final ClientTransaction clientTransaction = ClientTransaction.obtain( proc.getThread(), r.appToken);//1 final DisplayContent dc = r.getDisplay().mDisplayContent; clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent), System.identityHashCode(r), r.info, // TODO: Have this take the merged configuration instead of separate global // and override configs. mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(), r.icicle, r.persistentState, results, newIntents, dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(), r.assistToken));//2 // Set desired final state. final ActivityLifecycleItem lifecycleItem; if (andResume) &#123; lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward()); &#125; else &#123; lifecycleItem = PauseActivityItem.obtain(); &#125; clientTransaction.setLifecycleStateRequest(lifecycleItem); // Schedule transaction. mService.getLifecycleManager().scheduleTransaction(clientTransaction);//3 ....... return true; &#125; 由以上代码注释1处，创建了ClientTransaction对象，它是包含一系列消息的容器，可以将其发送到客户端，这个客户端就我们要启动的应用程序Activity，注释2处将前面一路传递进来的启动Activity参数封装成了LaunchActivityItem请求request对象，接着我们看到注释3，这里调用了ClientLifecycleManager的scheduleTransaction方法，它的初始化在AMTS构造方法中，并传入了ClientTransaction参数，接着看到ClientLifecycleManager的scheduleTransaction方法 ClientLifecycleManager（ActivityThread）处理ClientTransaction frameworks/base/services/core/java/com/android/server/wm/ClientLifecycleManager.java 12345678910void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; final IApplicationThread client = transaction.getClient();//1 transaction.schedule();//2 if (!(client instanceof Binder)) &#123; // If client is not an instance of Binder - it's a remote call and at this point it is // safe to recycle the object. All objects used for local calls will be recycled after // the transaction is executed on client in ActivityThread. transaction.recycle(); &#125; &#125; 到此，基本上已经比较清晰了，注释1处获取了要启动的应用程序进程的IApplicationThread，上一步中创建ClientTransaction对象时已经将其赋值给ClientTransaction的变量mClient，随后scheduleTransaction判断是否支持进程间通信；注释二处则调用了ClientTransaction的schedule方法， frameworks/base/core/java/android/app/servertransaction/ClientTransaction.java 123456789101112131415/** Target client. */ private IApplicationThread mClient; /** Schedule the transaction after it was initialized. It will be send to client and all its * individual parts will be applied in the following sequence: * 1. The client calls &#123;@link #preExecute(ClientTransactionHandler)&#125;, which triggers all work * that needs to be done before actually scheduling the transaction for callbacks and * lifecycle state request. * 2. The transaction message is scheduled. * 3. The client calls &#123;@link TransactionExecutor#execute(ClientTransaction)&#125;, which executes * all callbacks and necessary lifecycle transitions. */ public void schedule() throws RemoteException &#123; mClient.scheduleTransaction(this); //1 &#125; 通过以上代码，注释1处mClient则代表要启动的应用程序进程的IApplicationThread，而当前还处于ATMS服务的进程，也就是SystemServer进程，这时ATMS要与即将启动的应用程序进程通信则通过IApplicationThread来执行AIDL，IApplicationThread实现为ApplicationThread，它是ActivityThread的内部类，所以前面也说过ApplicationThread为进程间通信的桥梁，注释1处则相当于是IApplicationThread.scheduleTransaction，并将包含要启动Activity信息的ClientTransaction传递到了应用程序进程，下一节就从IApplicationThread讲起。 为了更好理解，看看AMTS调用到ApplicationThread时序图来对上面的步骤进行回顾 ActivityThread启动ActivityApplicationThread 处理进程间数据通信 接着上一节的内容，我们从ApplicationThread的scheduleTransaction方法开始 frameworks/base/core/java/android/app/ActivityThread.java 123456private class ApplicationThread extends IApplicationThread.Stub &#123; @Override public void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; ActivityThread.this.scheduleTransaction(transaction);//1 &#125;&#125; 由以上代码，注释1处调用了ActivityThread的scheduleTransaction方法，ActivityThread继承了ClientTransactionHandler，scheduleTransaction在里面实现 frameworks/base/core/java/android/app/ClientTransactionHandler.java 12345/** Prepare and schedule transaction for execution. */ void scheduleTransaction(ClientTransaction transaction) &#123; transaction.preExecute(this); sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction); &#125; ActivityThread.H 线程间消息处理 可以看到这里发送了一个Handler消息，而ActivityThread.H则是ActivityThread的内部Handler，它是整个应用程序的主线程Handler，这里为什么需要切换线程呢？其原因为前面ATMS进程间通信则是运行在Binder线程，而Android更新UI则需要在主线程，接着看到ActivityThread.H的消息处理 12345678910111213 class H extends Handler &#123; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, "&gt;&gt;&gt; handling: " + codeToString(msg.what)); switch (msg.what) &#123; case EXECUTE_TRANSACTION: final ClientTransaction transaction = (ClientTransaction) msg.obj;//1 mTransactionExecutor.execute(transaction);//2 ...... break; &#125; &#125; TransactionExecutor 由以上代码，看到注释1处，获取了由ATMS传递过来的启动Activity进程的数据，注释2处调用了TransactionExecutor的来处理ClientTransaction的数据，接着看到它的execute方法 frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java 1234567891011public void execute(ClientTransaction transaction) &#123; if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + "Start resolving transaction"); ....... executeCallbacks(transaction); // executeLifecycleState(transaction); mPendingActions.clear(); if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + "End resolving transaction"); &#125; 由以上代码注释1处接着调用了TransactionExecutor的executeCallbacks方法 frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java 12345678910111213141516171819202122232425262728293031323334353637/** Cycle through all states requested by callbacks and execute them at proper times. */ @VisibleForTesting public void executeCallbacks(ClientTransaction transaction) &#123; final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks(); if (callbacks == null || callbacks.isEmpty()) &#123; // No callbacks to execute, return early. return; &#125; if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + "Resolving callbacks in transaction"); final IBinder token = transaction.getActivityToken(); ActivityClientRecord r = mTransactionHandler.getActivityClient(token); // In case when post-execution state of the last callback matches the final state requested // for the activity in this transaction, we won't do the last transition here and do it when // moving to final state instead (because it may contain additional parameters from server). final ActivityLifecycleItem finalStateRequest = transaction.getLifecycleStateRequest(); final int finalState = finalStateRequest != null ? finalStateRequest.getTargetState() : UNDEFINED; // Index of the last callback that requests some post-execution state. final int lastCallbackRequestingState = lastCallbackRequestingState(transaction); final int size = callbacks.size(); for (int i = 0; i &lt; size; ++i) &#123; final ClientTransactionItem item = callbacks.get(i);//1 if (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + "Resolving callback: " + item); final int postExecutionState = item.getPostExecutionState(); final int closestPreExecutionState = mHelper.getClosestPreExecutionState(r, item.getPostExecutionState()); if (closestPreExecutionState != UNDEFINED) &#123; cycleToPath(r, closestPreExecutionState, transaction); &#125; item.execute(mTransactionHandler, token, mPendingActions);//2 ........ &#125; &#125; LaunchActivityItem 由以上代码注释1处，获取的ClientTransactionItem则为第二小节中提到过的LaunchActivityItem对象，它继承了ClientTransactionItem，并保存这需要启动的Activity数据，接着看到注释2 LaunchActivityItem的execute方法。 frameworks/base/core/java/android/app/servertransaction/LaunchActivityItem.java 1234567891011@Override public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, "activityStart"); ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo, mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState, mPendingResults, mPendingNewIntents, mIsForward, mProfilerInfo, client, mAssistToken);//1 client.handleLaunchActivity(r, pendingActions, null /* customIntent */);//2 Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); &#125; 由以上代码，注释1处恢复了要启动的Activity的数据，ActivityClientRecord是ActivityThread的内部类，这里的client为ClientTransactionHandler，而前面已经说过ActivityThread继承ClientTransactionHandler，所以这里的注释2处调用的就是ActivityThread的handleLaunchActivity方法 frameworks/base/core/java/android/app/ActivityThread.java 1234567891011121314/** * Extended implementation of activity launch. Used when server requests a launch or relaunch. */ @Override public Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) &#123; ....... final Activity a = performLaunchActivity(r, customIntent);//1 ....... return a; &#125; 由以上代码注释1处，继续调用了ActivityThread的performLaunchActivity方法来启动Activity，返回的也是Activity实例。所以performLaunchActivity方法才是启动Activity实例的核心代码。 Core Activity Launch frameworks/base/core/java/android/app/ActivityThread.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** Core implementation of activity launch. */ private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo;//1 if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE);//2 &#125; ComponentName component = r.intent.getComponent();//3 if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //应用程序Context的创建 ContextImpl appContext = createBaseContextForActivity(r);//4 Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); //创建Activity的实例 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent);//5 StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( "Unable to instantiate activity " + component + ": " + e.toString(), e); &#125; &#125; try &#123; //应用程序Application的创建 Application app = r.packageInfo.makeApplication(false, mInstrumentation);//6 ...... if (activity != null) &#123; CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity " + r.activityInfo.name + " with config " + config); Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; appContext.setOuterContext(activity); // 通过Activity的 attach 方法将 context等各种数据与Activity绑定，初始化Activity activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken); //7 ...... if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);//8 &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ...... r.activity = activity; &#125; r.setState(ON_CREATE); ....... &#125; return activity; &#125; 由以上代码，注释1处获取了前面保存启动应用程序信息的ActivityClientRecord中的应用程序信息，包括应用程序在清单文件中注册了哪些四大组件，启动的根Activity是什么，并在注释2处通过getPackageInfo方法获取LoadedApk描述对应Apk文件资源，注释3处的ComponentName类获取则对应启动Activity的包名和类名，注释4处则生成了启动应用程序的Base上下文环境Context，注释5处通过注释3获取的类名，通过类加载器和Intent对象实例化了Activity对象，注释6则根据注释2处获取Apk描述对象LoadedApk创建了应用程序的Application对象，并在makeApplication方法中调用了它的OnCreate方法，所以应用程序最新启动的是Application才到根Activity，注释7处则前面创建的Context、Application、Window对象与Activity关联来初始化Activity，最后注释8处还继续调用了Instrumentation对象的callActivityOnCreate方法。接着往下看 Activity的 OnCreate方法调用 frameworks/base/core/java/android/app/Instrumentation.java 12345public void callActivityOnCreate(Activity activity, Bundle icicle,PersistableBundle persistentState) &#123; prePerformCreate(activity); activity.performCreate(icicle, persistentState);//1 postPerformCreate(activity); &#125; 由以上代码，注释1处又调用了Activity的performCreate方法，继续往下看 frameworks/base/core/java/android/app/Activity.java 1234567891011final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123; dispatchActivityPreCreated(icicle); mCanEnterPictureInPicture = true; restoreHasCurrentPermissionRequest(icicle); if (persistentState != null) &#123; onCreate(icicle, persistentState);//1 &#125; else &#123; onCreate(icicle); &#125; ....... &#125; 最终，在已经实例初始化好的Activity调用它的performCreate方法中又掉用了onCreate方法（注释1）。至此，也就是整个应用程序的Activity启动过程我们已经走完了。 为了更好理解，看看ActivityThread启动Activity的时序图来对上面的步骤进行回顾 最后 通过本文，基本上将引用程序启动根的Activity启动流程走了一遍，但是其中还有一点没说展开的就是应用程序进程的启动过程，这一部分内容将通过后续文章继续探究。。如果文章中有写得不对的地方，欢迎在留言区留言大家一起讨论，共同学习进步。如果觉得我的文章给予你帮助，也请给我一个喜欢和关注。参考 书籍《Android 进阶解密》 Android源码地址]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-WanAndroid]]></title>
    <url>%2F2020%2F03%2F30%2FFlutter-WanAndroid%2F</url>
    <content type="text"><![CDATA[前言 Flutter作为当下最火的移动跨平台技术，它是谷歌的推出的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 项目简介 这是一款跨平台的开源Flutter版本玩Android App。首先感谢鸿洋大佬提供的玩Android开放API；其次，本应用提供丰富完整的功能，更好的体验，旨在随时随地都能更好的浏览https://www.wanandroid.com/网站内容，更好的在手机上进行学习。整个应用涉及到了大部分常用的Flutter组件，Flutter界面搭建，页面跳转，网络请求，Json解析转换，数据持久化，组件间消息通信等Flutter学习尝试，可以说是一个比较好的Flutter学习项目，也希望能对看到此项目的您有或多或少的帮助。项目如果对您有帮助，不妨点个Star，您的支持是我前进的动力。 编译运行环境1234567Doctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel stable, v1.12.13+hotfix.8, on Mac OS X 10.15.2 19C57, locale en-CN)[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.2)[✓] Xcode - develop for iOS and macOS (Xcode 11.1)[✓] Android Studio (version 3.5)Dart 2.7.0 项目结构图 下载 历史版本下载地址 最新版本下载 可以手机浏览器输入以下地址下载 http://d.alphaqr.com/9n12 类型 二维码 Apk 下载二维码 ios 下载 暂无下载，可以自行clone项目编译体验 项目截图展示gif （debug 模式略显卡顿，可下载release版本体验丝滑顺畅） ios 截图 API玩Android开放API 项目功能首页 首页文章列表 首页banner 常用网站 搜索热词（包含在搜索界面） 置顶文章 最新项目tab (首页的第二个tab) 知识体系 体系数据 知识体系下的文章 按照作者昵称搜索文章 公众号 获取公众号列表 查看某个公众号历史数据 导航 导航数据 项目 项目分类 项目列表数据 登录与注册 登录、注册功能 收藏 收藏文章列表 收藏站内文章 收藏站外文章 取消收藏 收藏网站列表 收藏网址 编辑收藏网站 删除收藏网站 搜索 首页文章搜索 在某个公众号中搜索历史文章 TODO工具 TODO 列表 新增一个 TODO 更新一个 TODO 删除一个 Todo 仅更新完成状态TODO 积分 积分排行榜 获取个人积分 获取个人积分获取列表 广场 广场列表数据 分享人对应列表数据 自己的分享的文章列表（个人中心） 删除自己分享的文章（个人中心） 分享文章 问答 问答列表文章 设置 夜间模式 清除缓存 版本信息 退出登录 主题切换 切换App 主题 个人中心点击头像进入个人中心，仿B站个人中心效果 Thanks 感谢所有开源库的作者参考项目 flutter-go 使用的第三方库 第三方库 功能 fluro 页面跳转路由框架 shared_preferences 本地存储 dio 网络 json_annotation json 序列化 flutter_webview webview fluttertoast Toast provider 跨组件数据共享 event_bus 事件总线 flutter_spinkit 加载中指示器动画 extended_nested_scroll_view NestedScrollView 扩展 flutter_easyrefresh 配合NestedScrollView扩展下拉刷新以及上拉加载 flutter_staggered_grid_view 瀑布流 package_info 方便获取应用信息 flutter_html 加载html 字符串 expandable 扩展显示隐藏 date_format 日期转换 share 分享 版本更新日志v1.0.5 (2020/03/15)完善功能 个人中心添加积分显示 修复文章item显示越界问题 v1.0.4 (2020/03/12)完善功能 添加侧边栏个人中心入口 完善文章tag显示 修复上个版本存在的bug v1.0.3 (2020/03/10)完善功能 添加文章分享功能 优化主题切换功能 修复上个版本存在的bug v1.0.2 (2020/03/08)添加TODO模块 TODO 列表 新增一个 TODO 更新一个 TODO 删除一个 Todo 仅更新完成状态TODO 修复上个版本存在的bug v1.0.1 (2020/02/18) 添加问答模块 修复上个版本存在的bug v1.0.0 (2020/02/15) Flutter 项目第一个版本， 完成WanAndroid基本功能 Statement项目中的 API 均来自于 wanandroid.com 网站，纯属学习交流使用，不得用于商业用途。]]></content>
      <categories>
        <category>Flutter探索</category>
      </categories>
      <tags>
        <tag>dart</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重看 Android 消息机制]]></title>
    <url>%2F2020%2F01%2F12%2F%E9%87%8D%E7%9C%8B-Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[谈起Android 消息机制，相信各位会首先想到Handler，Handler是Android 提供给给开发者实现线程间通信的工具。Android的消息机制包含四大内容，ThreadLocal保证每个线程都有自己的消息轮询器Looper，MessageQueue用来存放消息，Looper负责取消息，最后Handler负责消息的发送与消息的处理。 先来一张脑图回顾整体知识 ThreadLocal 我们知道，每个Handler 都有其所在线程对应的Looper，查看Handler构造方法 12345678910111213141516171819202122/**Handler 构造方法*/public Handler(Callback callback, boolean async) &#123; ....... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread " + Thread.currentThread() + " that has not called Looper.prepare()"); &#125; ...... &#125;/** Looper 中 sThreadLocal 声明*/ static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();/** Looper 中 myLooper方法*/ public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; /** Looper 中 prepare方法*/ private static void prepare(boolean quitAllowed) &#123; .... sThreadLocal.set(new Looper(quitAllowed)); &#125; 通过以上源码，可以知道，Looper.myLooper()获取不到Looper则会抛异常，所以创建Handler之前都要调用一下Looper.prepare方法，也就是在该方法中新建了Looper并存放到ThreadLocal中。这里就会产生一个疑问，ThreadLocal能保证每个线程有自己对应的Looper？没错，它就真能保证，接下来就看看什么是ThreadLocal。 什么是ThreadLocal ThreadLocal是一个线程内部数据存储类，但存放数据并不是它实现的，它只是帮助类，真正存放数据的是ThreadLocalMap。 先看一个简单的例子 12345678910111213141516171819202122232425262728public class Test &#123; static ThreadLocal&lt;String&gt; name =new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; name.set("xiaoming"); System.out.println("---------------"+name.get()+"-------------------"); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("---------------"+name.get()+"-------------------"); &#125; &#125;).start(); &#125;&#125;### 运行结果&gt; Task :Test.main()---------------xiaoming----------------------------------null------------------- 上面例子当中，两个线程访问的都是一个ThreadLocal对象，但是第二个线程没有设置初始值，则获取为null，也就可以说明每个线程操作的是自己对应的一份数据，虽然都是从ThreadLocal的get方法获取，但是get方法则是获取对应线程的ThreadLocal.ThreadLocalMap来获取值。 ThreadLocal分析ThreadLocal的set方法123456789101112131415161718192021222324252627282930313233343536373839/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */ public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; /** * Get the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @return the map */ ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; /** * Create the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @param firstValue value for the initial entry of the map */ void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; 通过以上代码，代码层面首先获取当前线程，然后获取ThreadLocalMap，如果存在，则获取当前线程的ThreadLocalMap；如果不存在则根据当前线程和当前需要存入的数据新建ThreadLocalMap来存放线程内部数据，也就是当前ThreadLocal作为key，而存储的值最为value来存储。 ThreadLocal的get方法123456789101112131415161718192021222324252627282930313233343536373839404142/** * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread's value of this thread-local */ public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; /** * Variant of set() to establish initialValue. Used instead * of set() in case user has overridden the set() method. * * @return the initial value */ private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; &#125; protected T initialValue() &#123; return null; &#125; 从以上代码，ThreadLocal的get方法根据当前线程来获取对应的ThreadLocalMap，如果获取不到，说明还没有创建，由createMap方法来创建ThreadLocalMap，initialValue方法则设置了value的初始值为null，也呼应前面的例子打印结果。 ThreadLocal原理 Thread类有一个类型为ThreadLocal.ThreadLocalMap的成员变量threadLocals，如果你了解Java内存模型，threadLocals的值都是new出来的话，很容易明白threadLocals是存放在堆内存中的，而每一个线程只是在堆内存中存放了自己的threadLocals，也就是每个线程本地内存（逻辑上），物理上本地内存只是在堆内存中占有一块区域，每个线程只玩自己对应的threadLocals，各个线程的对应ThreadLocal互不干扰，这也就实现了各个线程间数据的隔离，也就是每个Handler所在线程都有其对应的Looper对象。 Thread类中 threadLocals 声明 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; 简单来说就是数据复制很多份存放在堆内存，各个线程获取自己对应的那份数据。 这个可以举一个共享汽车的例子，假如刚开始共享汽车试运行，大街上只有一辆，大家都抢着去开，这就会出现问题，而后来发展普及，每辆车复制迅速生产，满大街都是共享汽车，每个人都可以通过专属二维码开对应共享汽车，这里开车人就对应线程，大家互不干扰，共享汽车就对应ThreadLocals，而大街就相当于堆内存。 ThreadLocalMap ThreadLocal中真正存放数据的是ThreadLocalMap，他的内部实现是一个环形数组来存放数据，具体分析可以查看以下文章，这里就不在进行展开了。 ThreadLocal源码解读 MessageQueue消息队列工作原理 MessageQueue字面意思是消息队列，而他的实现则不是消息队列，它的内部实现数据结构为单链表，单链表在频繁插入删除方面是有优势的，链表的插入删除操作对应消息的存储和取出，方法分别对应enqueueMessage和next方法。 存放消息enqueueMessage 查看Handler的源码，很容易发现发消息的方法最终都是调用了sendMessageAtTime方法，uptimeMillis为系统开机时间加上设置消息的延时时间，Handler的enqueueMessage方法将Message的Target设为当前Handler，存放消息则调用了MessageQueue的enqueueMessage方法。 123456789101112/** Handler的sendMessageAtTime方法*/public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; ...... return enqueueMessage(queue, msg, uptimeMillis); &#125;/** Handler的enqueueMessage方法*/private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; ....... return queue.enqueueMessage(msg, uptimeMillis); &#125; 接着存放消息看到MessageQueue的enqueueMessage方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** MessageQueue的enqueueMessage方法*/boolean enqueueMessage(Message msg, long when) &#123; ...... synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 通过以上源码，enqueueMessage逻辑主要为单链表的插入操作，如果链表中没有消息，或者当前存入消息延时为零，又或者当前存入消息延时小于链表P节点的延时，则将当前消息插入到链表的头节点，否则遍历链表中的每个节点，找延时小于当前消息的节点存入消息。话句话说，单链表里面消息是按Message的触发时间顺序排序的。 取消息 next 接着看MessageQueue取消息的方法next 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Message next() &#123; ...... //省略部分代码 int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; //省略部分代码 &#125; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; 通过以上代码，nextPollTimeoutMillis字段是关键，它代表next在获取下一个消息时需要等待的时长，他的取值有三种情况： 当nextPollTimeoutMillis小于零，表示消息队列中无消息，会一直等待下去 当nextPollTimeoutMillis等于零，则不会等待，直接出了取出消息 当nextPollTimeoutMillis大于零，则等待nextPollTimeoutMillis值的时间，单位是毫秒 通过对nextPollTimeoutMillis的了解，next方法是如何等待呢？换个词可能更准确，应该叫阻塞，这里注意到next方法循环中的nativePollOnce(ptr, nextPollTimeoutMillis)方法，它的实现在native层，可以实现阻塞的功能，具体原理是使用epoll，它是一种linux的I/O事件通知机制，I/O输入输出对象使用的是管道(pipe)，具体native层分析请看Gityuan大佬的分析文章Android消息机制2-Handler(Native层) 123private native static void nativeWake(long ptr);private native void nativePollOnce(long ptr, int timeoutMillis); /*non-static for callbacks*/ 到此，next方法的逻辑就很清晰了，开始nextPollTimeoutMillis的值是等于零的，获取消息过程就不会受到nativePollOnce方法的阻塞，然后判断取出的消息是否延时，有延时则计算nextPollTimeoutMillis进入下一循环进入nativePollOnce方法阻塞，否则返回取出的消息，有阻塞肯定就有唤醒，这个唤醒的方法就是nativeWake(long ptr)方法，它的实现也在native层，它的调用在我们前面分析enqueueMessage方法逻辑有出现，当有消息进入消息队列，如果当前线程正在被阻塞，调用nativeWake方法，nativePollOnce就会立即返回，取消阻塞，这样循环取到没有延时的消息，则直接返回消息；如果没有消息，nextPollTimeoutMillis等于 -1，继续阻塞状态。 经过前面的分析，消息插入链表是sendMessageAtTime方法触发的，而接下来就会有一个疑问，那又是谁调用 next() 方法取消息呢？没错，就是接下来要了解的Looper Looper 工作原理 Looper在Android消息机制中是消息轮询器的作用，他会不断到MessageQueue中去取消息，取消息根据前面next 方法分析，如果阻塞，则说明没有消息 先看Looper源码注释中有一段示例代码 12345678910111213141516171819/* This is a typical example of the implementation of a Looper thread, * using the separation of &#123;@link #prepare&#125; and &#123;@link #loop&#125; to create an * initial Handler to communicate with the Looper. */ class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125; &#125; 由example代码所示，使用 Handler 之前调用了Looper.prepare()，如下代码所示，就是在ThreadLocal中存放当前线程的Looper对象，在Looper构造方法中创建了MessageQueue 123456789101112131415public static void prepare() &#123; prepare(true); &#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 接着创建完Handler之后，又调用Looper.loop()方法，如下 12345678910111213141516171819202122232425262728/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; //省略部分代码..... for (;;) &#123; Message msg = queue.next(); // might block //省略部分代码..... try &#123; msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; finally &#123; //省略部分代码。。。。 &#125; //省略部分代码。。。。 &#125; &#125; 首先看到第一行myLooper()，前面在分析ThreadLocal已经了解过，myLooper就是获取ThreadLocal获取我们存储的Looper对象，如果获取不到就会报异常，提示我们我们没有调用Looper.prepare()，这也就是子线程使用Handler必须调用Looper.prepare()的原因。是不是有恍然大悟的感觉。然后就是就是根据构造方法创建的MessageQueue来获取消息queue.next()，该方法经过前面分析在没有消息或者消息延时时间还没到是阻塞的；获取到消息后，根据msg.target.dispatchMessage(msg)调用的便是Handler的dispatchMessage方法(前文分析中msg.target的值为当前Handler)。 主线程Looper.prepare() 经过前面的分析，你也许会有一个疑问，在Android使用Handler怎么不用调用Looper.prepare()方法？ 解下来我们看到Android的主线程ActivityThread的main方法，严格来说，ActivityThread并不是线程类，但是Android主线程肯定是存在的，只是主线程在ActivityThread的 main 方法中创建，并在该方法调用了Looper.prepareMainLooper() 方法和Looper.loop() 方法，所以我们在Android 主线程就可以直接使用Handler 12345678910111213141516171819202122232425/**ActivityThread 的 main 方法*/public static void main(String[] args) &#123; //省略部分代码.... Looper.prepareMainLooper(); //省略部分代码.... ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); //省略部分代码.... // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); &#125; //省略部分代码....&#125;/**Looper 的 prepareMainLooper 方法*/ public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125; &#125; Handler 工作原理 前面已经了解过Handler发送消息的sendMessageAtTime方法，接着我们来看看Handler的dispatchMessage方法 12345678910111213141516171819/** * Handle system messages here. */ public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; private static void handleCallback(Message message) &#123; message.callback.run(); &#125; 这里逻辑就很简单了，如果发送的消息设置了Runnable类型的callback对象，则调用他的run方法，没有则判断是否设置了Handler.Callback，设置则调用Handler.Callback接口的handleMessage方法，否则调用Handler空实现方法handleMessage。 Looper.loop()死循环，为什么不会导致主线程发生ANR？ 根据前面的分析，Looper.loop()的方法获取不到数据，则会阻塞，这个阻塞和卡死是两回事，阻塞是Linux pipe/epoll机制文件读写的等待，等待及休眠，则会释放占用CPU的资源，而我们开发遇见的卡死一般都是在主线程做了太多耗时操作，Activity 5s，BroadcastReceiver 10s和Service 20s未响应引起的ANR，具体背后分析还请看Gityuan的知乎解答Android中为什么主线程不会因为Looper.loop()里的死循环卡死？ 参考书籍 《Android开发艺术探索》 链接 ActivityThread.java源码 Handler.java源码 Looper.java源码 MessageQueue.java源码 Message.java源码]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
        <tag>消息机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter Pull Refresh]]></title>
    <url>%2F2020%2F01%2F11%2FFlutter-Pull-Refresh%2F</url>
    <content type="text"><![CDATA[基础页面实现 TabBar + TabBarView 实现页面切换联动（类似Android tablayout + ViewPage）效果 直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859List &lt;String&gt;_titles=['湖人','勇士','雄鹿','快船','凯尔特人','马刺','76人','猛龙'];TabController _tabController;///省略部分代码class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; ///省略部分代码class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin&#123; @override void initState() &#123; super.initState(); //初始化控制器 _tabController = new TabController(length: _titles.length,vsync: this); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( leading: Icon(Icons.menu), title: buildTabBar(), //bottom: buildTabBar(), ), body: TabBarViewLayout() ); &#125; Widget buildTabBar() &#123; return TabBar( //构造Tab集合 tabs: _titles.map((String title)&#123; return Tab( text: title, ); &#125;).toList(), ///省略部分代码 controller: _tabController, ); &#125;&#125;// TabBarView Widgetclass TabBarViewLayout extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; print("TabBarViewLayout build......."); return TabBarView( controller: _tabController, children: _titles.map((String title)&#123; return TabPageView(title); &#125;).toList(), ); &#125;&#125; 如果代码，可以看到在AppBar这个widget的title属性中加入TabBar，也就是AppBat的title模块显示TabBar，也可在AppBar的bottom属性加入；还需要注意TabBar和TabBarView正是通过同一个controller来实现菜单切换和滑动状态同步的，最终运行结果如下，分被设置tabbar在title 和bottom属性 下拉刷新，上拉加载更多实现（RefreshIndicator） 下拉刷新 Flutter SDK中已经提供了一个RefreshIndicator控件，所以结合RefreshIndicator控件，让其包裹ListView控件，结合滑动监听ScrollController，并且设置头部，尾部加载更多等界面，就可以完成一个通用的下拉刷新，上拉加载更多的通用控件。首先来看看RefreshIndicator构造方法 1234567891011const RefreshIndicator(&#123; Key key, @required this.child, //包装一个可滚动widget this.displacement = 40.0, @required this.onRefresh, //触发刷新调用方法 this.color, //指示器颜色 this.backgroundColor, this.notificationPredicate = defaultScrollNotificationPredicate, this.semanticsLabel, this.semanticsValue,&#125;) RefreshIndicator包装一个可滚动widget，这里使用ListView 123456789101112131415161718@override Widget build(BuildContext context) &#123; return RefreshIndicator( child: ListView.builder( ///保持ListView任何情况都能滚动，解决在RefreshIndicator的兼容问题。 physics: const AlwaysScrollableScrollPhysics(), itemBuilder: (context,index)&#123; return _getItem(index); &#125;, ///根据状态返回绘制 item 数量 itemCount: _getListCount(), ///滑动监听 controller: _scrollController, ), onRefresh: _handleRefresh, color: Theme.of(context).primaryColor, //指示器颜色 ); &#125; ListView有两个重要方法设置，一个是itemBuilder构建列表item的每一个页面，另一个构建item页面数量itemCount。首先看itemCount方法 123456789101112///根据配置状态返回实际列表数量 _getListCount() &#123; ///是否需要头部 if (widget.isHaveHeader) &#123; return (items.length &gt; 0) ? items.length + 2 : items.length + 1; &#125; else &#123; if (items.length == 0) &#123; return 1; &#125; return (items.length &gt; 0) ? items.length + 1 : items.length; &#125; &#125; 该方法中，做了几种内容类型判断，如果需要头部，用Item 0 的 Widget 作为ListView的头部，列表数量大于0时，因为头部和底部加载更多选项，需要对列表数据总数+2，如果不需要头部，在数据获取为零时，固定返回数量1用于空页面呈现或者错误页面；如果有数据，加上外部加载更多选项，需要对列表数据总数+1。接着看_getItem()方法，返回对应渲染页面。 12345678910111213141516171819202122232425///根据配置状态返回实际列表渲染Item _getItem(int index) &#123; if (!widget.isHaveHeader &amp;&amp; index == items.length &amp;&amp; items.length != 0) &#123; return _buildProgressIndicator(); &#125; else if (widget.isHaveHeader &amp;&amp; index == _getListCount()-1 &amp;&amp; items.length != 0) &#123; return _buildProgressIndicator(); &#125; else if (widget.isHaveHeader &amp;&amp; index == 0 &amp;&amp; items.length != 0) &#123; return widget.headerView(); &#125; else if (!widget.isHaveHeader &amp;&amp; items.length == 0) &#123; ///如果不需要头部，并且数据为0，渲染空页面 if(isLoading)&#123; return _buildIsLoading(); &#125;else&#123; return _buildEmpty(); &#125; &#125; else if(widget.isHaveHeader &amp;&amp; items.length == 0)&#123; if(isLoading)&#123; return _buildIsLoading(); &#125;else&#123; return _buildEmpty(); &#125; &#125; else &#123; return widget.renderItem(index, items[widget.isHaveHeader ? index-1 : index]); &#125; &#125; 该方法中，如果没有设置头部，并且数据不为0，当index等于数据长度时，渲染加载更多页面（因为index是从0开始）；如果设置了头部页面，并且数据不为0，当index等于实际渲染长度 - 1时，渲染加载更多页面（在该方法判断是否已经加载到底）；接着如果设置了头部widget，并且数据不为0，当index = 0 ，渲染头部widget；如果没设置头部，并且数据为0，如果当前正在刷新，渲染Loading页面，否则渲染空页面或者Error页面；同理，如果设置头部，并且数据为0，并且当前正在刷新，渲染Loading页面，否则渲染空页面或者Error页面；如果不是上面情况，则渲染正常渲染Item，如果这里有需要，可以直接返回相对位置的index，如果有头部 index 减一 ，保持不会忽略 index = 0 的数据。 接着封装一个统一网络请求方法，外部请求安装固定格式的 Map 将数据返回给下拉刷新上拉加载更多widget，达到通用的目的。 1234567891011121314151617181920//网络请求获取数据 isRefresh 是否为下拉刷新 Future&lt;List&gt; makeHttpRequest(bool isRefresh) async &#123; if (widget.requestApi is Function) &#123; Map listObj = new Map&lt;String, dynamic&gt;(); if(isRefresh)&#123; //下拉刷新 listObj = await widget.requestApi(&#123;'pageIndex': 0&#125;); &#125;else&#123; //上拉加载更多 listObj = await widget.requestApi(&#123;'pageIndex': _pageIndex&#125;); &#125; _pageIndex = listObj['pageIndex']; _pageTotal = listObj['total']; return listObj['list']; &#125; else &#123; return Future.delayed(Duration(seconds: 2), () &#123; return []; &#125;); &#125; &#125; 基础东西写好了，loading 加载动画这里直接就使用现成的轮子好了，推荐一个loading库，flutter_spinkit 贴上loading加载代码（更多实现细节请看文末demo地址代码） 12345678910111213141516171819202122Widget _buildIsLoading() &#123; return Container( width: MediaQuery.of(context).size.width, height: MediaQuery.of(context).size.height*0.85, child: new Center( child: Column( crossAxisAlignment: CrossAxisAlignment.center, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: &lt;Widget&gt;[ SpinKitCircle(size: 55.0, color: Theme.of(context).primaryColor), ], ), Padding( child: Text("正在加载..", style: TextStyle(color: Colors.black54, fontSize: 15.0)), padding: EdgeInsets.all(15.0),) ],) )); &#125; 最后，通过构造方法设置设置需要加载的item值和是否支持下拉刷新和上来加载更多等，灵活配置控件 123456789101112131415161718192021// 模块item final renderItem; //数据获取方法 final requestApi; //头部 final headerView; //是否添加头部 默认不添加 final bool isHaveHeader; //是否支持下拉刷新 默认可以下拉刷新 final bool isCanRefresh; //是否支持下拉加载更多 默认可以加载更多 final bool isCanLoadMore; const RefreshPage(&#123;@required this.requestApi, @required this.renderItem, this.headerView, this.isHaveHeader = false, this.isCanRefresh = true, this.isCanLoadMore = true &#125;) : assert(requestApi is Function), assert(renderItem is Function), super(); 最终demo 效果 Demo 地址 https://github.com/maoqitian/flutter_demo About meblog： 个人博客 掘金 简书 Githubmail： maoqitian@gmail.com maoqitian068@163.com]]></content>
      <categories>
        <category>Flutter探索</category>
      </categories>
      <tags>
        <tag>dart</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter 之数据共享 InheritedWidget]]></title>
    <url>%2F2019%2F12%2F01%2FFlutter-%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB-InheritedWidget%2F</url>
    <content type="text"><![CDATA[Flutter 中Widget 多种多样，有UI的，当然也有功能型的组件InheritedWidget 组件就是Flutter 中的一个功能组件，它可以实现Flutter 组件之间的数据共享，他的数据传递方向在Widget树传递是从上到下的。 InheritedWidget 实现组件数据共享 既然要使用InheritedWidget，首先写一个Widget继承InheritedWidget 实现ShareDataWidget123456789101112131415161718192021222324252627282930/// Created with Android Studio./// User: maoqitian/// Date: 2019/11/15 0015/// email: maoqitian068@163.com/// des: InheritedWidget是Flutter中非常重要的一个功能型组件，它提供了一种数据在widget树中从上到下传递、共享的方式import 'package:flutter/material.dart';class ShareDataWidget extends InheritedWidget &#123; final int data; //需要在子树中共享的数据，保存点击次数 ShareDataWidget( &#123;@required this.data,Widget child&#125;) :super(child:child); // 子树中的widget通过该方法获取ShareDataWidget，从而获取共享数据 static ShareDataWidget of(BuildContext context)&#123; return context.inheritFromWidgetOfExactType(ShareDataWidget); &#125; //继承 InheritedWidget 实现的方法 返回值 决定当data发生变化时，是否通知子树中依赖data的Widget 更新数据 @override bool updateShouldNotify(ShareDataWidget oldWidget) &#123; //如果返回true，则子树中依赖(build函数中有调用)本widget的子widget的`state.didChangeDependencies`会被调用 return oldWidget.data != data; &#125;&#125; 由以上实现我们可以看到updateShouldNotify 返回值 决定当data发生变化时，是否通知子树中依赖data的Widget 更新数据，并且实现了of 方法方便子widget获取共享数据。 测试ShareDataWidget数据共享 前面我们已经实现了InheritedWidget，现在我们来看看如何使用随便写一个widget，让其显示ShareDataWidget的data 数据 12345678910111213141516171819202122232425262728293031 /// Created with Android Studio./// User: maoqitian/// Date: 2019/11/15 0015/// email: maoqitian068@163.com/// des: 测试 ShareDataWidgetimport 'package:flutter/material.dart';import 'package:flutter_hellow_world/InheritedWidget/ShareDataWidget.dart';class TestShareDataWidget extends StatefulWidget &#123; @override _TestShareDataWidgetState createState() =&gt; _TestShareDataWidgetState();&#125;class _TestShareDataWidgetState extends State&lt;TestShareDataWidget&gt; &#123; @override void didChangeDependencies() &#123; super.didChangeDependencies(); //上层 widget中的InheritedWidget改变(updateShouldNotify返回true)时会被调用。 //如果build中没有依赖InheritedWidget，则此回调不会被调用。 print("didChangeDependencies"); &#125; @override Widget build(BuildContext context) &#123; //显示 ShareDataWidget 数据变化，如果build中没有依赖InheritedWidget，则此回调不会被调用。 return Text(ShareDataWidget.of(context).data.toString()); &#125;&#125; 接着新建widget 来使用ShareDataWidget，创建一个按钮，每点击一次，就将ShareDataWidget的值自增 1234567891011121314151617181920212223242526272829303132333435363738394041424344/// Created with Android Studio./// User: maoqitian/// Date: 2019/11/15 0015/// email: maoqitian068@163.com/// des: 创建一个按钮，每点击一次，就将ShareDataWidget的值自增import 'package:flutter/material.dart';import 'package:flutter_hellow_world/InheritedWidget/ShareDataWidget.dart';import 'package:flutter_hellow_world/InheritedWidget/TestShareDataWidget.dart';class InheritedWidgetTest extends StatefulWidget &#123; @override _InheritedWidgetTestState createState() =&gt; _InheritedWidgetTestState();&#125;class _InheritedWidgetTestState extends State&lt;InheritedWidgetTest&gt; &#123; int count = 0; @override Widget build(BuildContext context) &#123; return Center( child: ShareDataWidget( data: count, //共享数据 data child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.only(bottom: 20.0), child: TestShareDataWidget()//子widget中依赖ShareDataWidget ), RaisedButton( child: Text("计数增加"), onPressed: ()&#123; setState(() &#123; ++ count; &#125;); &#125;, ) ], ), ), ); &#125;&#125; 代码很简单，创建一个按钮，每点击一次，就将ShareDataWidget的data值加一，而前面创建的TestShareDataWidget中依赖了ShareDataWidget的data值，如果数据共享则它的值就会跟随变化。 运行效果 didChangeDependencies调用 运行上面的例子我们看到日志中会打印出如下日志，这就说明改变ShareDataWidget的data值时TestShareDataWidget的didChangeDependencies方法被调用了，该方法我们在写StatefulWidget时很少用到，我们可以在该方法中做一些耗时操作，比如数据持久化、网络请求等。 1I/flutter ( 7082): didChangeDependencies 如果不想调用让didChangeDependencies被调用，也是有办法的，如下改变ShareDataWidget的of方法 123456// 子树中的widget获取共享数据 方法 static ShareDataWidget of(BuildContext context)&#123; //return context.inheritFromWidgetOfExactType(ShareDataWidget); //使用 ancestorInheritedElementForWidgetOfExactType 方法当数据变化则不会调用 子widget 的didChangeDependencies 方法 return context.ancestorInheritedElementForWidgetOfExactType(ShareDataWidget).widget; &#125; 这里可以看到改变使用context.ancestorInheritedElementForWidgetOfExactType方法，而为什么使用这个方法didChangeDependencies就不会被调用呢？看源码就是最好的解释，我们直接翻到framework.dart中这两个方法的源码 12345678910111213141516171819202122/** * framework.dart inheritFromWidgetOfExactType和ancestorInheritedElementForWidgetOfExactType方法源码 */ @override InheritedWidget inheritFromWidgetOfExactType(Type targetType, &#123; Object aspect &#125;) &#123; assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement ancestor = _inheritedWidgets == null ? null : _inheritedWidgets[targetType]; if (ancestor != null) &#123; assert(ancestor is InheritedElement); return inheritFromElement(ancestor, aspect: aspect); &#125; _hadUnsatisfiedDependencies = true; return null; &#125; @override InheritedElement ancestorInheritedElementForWidgetOfExactType(Type targetType) &#123; assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement ancestor = _inheritedWidgets == null ? null : _inheritedWidgets[targetType]; return ancestor; &#125; 显然，一对比我们就可以看到inheritFromWidgetOfExactType多调用了inheritFromElement方法，继续看该方法源码 123456789101112/** * framework.dart inheritFromElement方法源码 */ @override InheritedWidget inheritFromElement(InheritedElement ancestor, &#123; Object aspect &#125;) &#123; assert(ancestor != null); _dependencies ??= HashSet&lt;InheritedElement&gt;(); _dependencies.add(ancestor); ancestor.updateDependencies(this, aspect); return ancestor.widget; &#125; 到这里，一切都变得很清晰， inheritFromWidgetOfExactType方法中调用了inheritFromElement方法，而在该方法中InheritedWidget将其子widget添加了依赖关系，所以InheritedWidget发生改变，依赖它的子widget就会更新，也就会调用刚刚所说的didChangeDependencies方法，而ancestorInheritedElementForWidgetOfExactType方法没有和子widget注册依赖关系，当然也不会调用didChangeDependencies方法。 小结 以上通过一个使用InheritedWidget的简单例子，实现了InheritedWidget的使用，了解了didChangeDependencies调用，可以说对InheritedWidget这个组件有了一定了解，接下来通过对InheritedWidget封装，实现一个简易的Provider实现跨组件数据共享。 实现跨组件数据共享组件 作为一个原生Android 开发者，跨组件数据共享对于我们来说并不陌生，比如Android 开发中的Eventbus 就可以实现对事件订阅者的状态更新，Flutter中也有Eventbus的实现，但是这里直接使用Flutter 提供给我们的组件InheritedWidget来实现跨组件数据共享，Flutter中比较有名的Provider核心也是通过InheritedWidget来实现的，接着我们来实现一个自己的简易Provider。 实现通用InheritedWidget 要共享的数据多种多样，使用泛型来声明需要共享的数据 1234567891011121314151617181920212223/// Created with Android Studio./// User: maoqitian/// Date: 2019-11-17/// email: maoqitian068@163.com/// des: 实现InheritedWidget 保存需要共享的数据InheritedWidgetimport 'package:flutter/material.dart';class InheritedProvider&lt;T&gt; extends InheritedWidget&#123; //共享数据 外部传入 final T data; InheritedProvider(&#123;@required this.data, Widget child&#125;):super(child:child); @override bool updateShouldNotify(InheritedProvider&lt;T&gt; oldWidget) &#123; ///返回true，则每次更新都会调用依赖其的子孙节点的`didChangeDependencies`方法。 return true; &#125;&#125; InheritedWidget 封装 通过上面的实现，可以看到InheritedProvider中并没有方让调用者可以获取InheritedWidget组件，别着急，这里需要先明确两点；首先，数据更新通知使用ChangeNotifier（FlultterSDK提供的一个Flutter风格的发布者-订阅者模式类）来进行通知，其次，接收到通知之后则由订阅者本身更新来重新构建InheritedProvider。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/// Created with Android Studio./// User: maoqitian/// Date: 2019-11-17/// email: maoqitian068@163.com/// des: 订阅者import 'package:flutter/material.dart';import 'package:flutter_theme_change/provider/InheritedProvider.dart';// 该方法用于在Dart中获取模板类型Type _typeOf&lt;T&gt;()&#123; return T;&#125;class ChangeNotifierProvider&lt;T extends ChangeNotifier&gt; extends StatefulWidget&#123; final Widget child; final T data; ChangeNotifierProvider(&#123;Key key,this.child,this.data&#125;); //方便子树中的widget获取共享数据 static T of&lt;T&gt; (BuildContext context,&#123;bool listen = true&#125;)&#123; //listen 是否注册依赖关系 默认注册 final type = _typeOf&lt;InheritedProvider&lt;T&gt;&gt;(); final provider = listen ? context.inheritFromWidgetOfExactType(type) as InheritedProvider&lt;T&gt; : context.ancestorInheritedElementForWidgetOfExactType(type)?.widget as InheritedProvider&lt;T&gt;; return provider.data; &#125; @override State&lt;StatefulWidget&gt; createState() &#123; return _ChangeNotifierProviderState&lt;T&gt;(); &#125;&#125;class _ChangeNotifierProviderState&lt;T extends ChangeNotifier&gt; extends State&lt;ChangeNotifierProvider&lt;T&gt;&gt;&#123; @override Widget build(BuildContext context) &#123; //构建 InheritedProvider return InheritedProvider&lt;T&gt;( data: widget.data, child: widget.child, ); &#125;&#125; 由上代码，创建了一个StatefulWidget，最终build构建的还是InheritedProvider，这时创建了返回对应data 数据的of方法，并且可以通过设置让子控件是否与InheritedWidget绑定（上一小节已经分析过），这样改变数据的控件就可以灵活的不与InheritedWidget绑定，也不用每次都更新改变数据的控件widget。 接着我们完善 _ChangeNotifierProviderState，当外部控件更新数据，并通过ChangeNotifier通知更新，ChangeNotifierProvider能够更新自身，让新数据生效，如何更新，那就是是使用setState方法，这也是创建StatefulWidget的目的。123456789101112131415161718192021222324252627282930313233343536class _ChangeNotifierProviderState&lt;T extends ChangeNotifier&gt; extends State&lt;ChangeNotifierProvider&lt;T&gt;&gt;&#123; @override void initState() &#123; // 给model添加监听器 widget.data.addListener(update); super.initState(); &#125; @override void didUpdateWidget(ChangeNotifierProvider&lt;T&gt; oldWidget) &#123; //当Provider更新时，如果新旧数据不"=="，则解绑旧数据监听，同时添加新数据监听 if(widget.data != oldWidget.data)&#123; oldWidget.data.removeListener(update); widget.data.addListener(update); &#125; super.didUpdateWidget(oldWidget); &#125; // build方法 省略 ........ @override void dispose() &#123; // 移除model监听器 widget.data.removeListener(update); super.dispose(); &#125; void update() &#123; //如果数据发生变化（model类调用了notifyListeners），重新构建InheritedProvider setState(() =&gt; &#123; &#125;); &#125; 数据消费者封装（Consumer） 数据有更新，有消息发出，还得有人消费，这样订阅者-消费者模式才完整，消费数说白了就是调用ChangeNotifierProvider的of方法来获取新数据，上一步我们已经触发订阅者的更新，间接就会重新构建它的子widget，子widget重新构建也就是对应消费消费数据，因为消费者依赖了订阅者本身，来看代码 1234567891011121314151617181920212223/// Created with Android Studio./// User: maoqitian/// Date: 2019/11/18 0018/// email: maoqitian068@163.com/// des: 事件 消费者 获得当前context和指定数据类型的Providerimport 'package:flutter/material.dart';import 'package:flutter_theme_change/provider/ChangeNotifierProvider.dart';class Consumer&lt;T&gt; extends StatelessWidget&#123; final Widget child; //获得当前context final Widget Function(BuildContext context, T value) builder; Consumer(&#123;Key key,@required this.builder,this.child&#125;):assert(builder !=null),super(key:key); @override Widget build(BuildContext context) &#123; //默认绑定 注册依赖关系 return builder(context,ChangeNotifierProvider.of&lt;T&gt;(context)); //自动获取Model 获取更新的数据 &#125;&#125; 由上代码，Consumer的build调用ChangeNotifierProvider.of方法默认就注册了依赖关系，所以由Consumer实现的widget就会由InheritedWidget的功能更新数据。 小结 以上小结可以用一个流程图代替 数据共享组件实践切换主题 上一节中手写了一个非常简单基于InheritedWidget的Provider数据共享组件，接下来通过一个切换主题的例子来使用刚刚写好的ChangeNotifierProvider。 主题切换这里简单的改变主题颜色，所以共享数据就是颜色值，Demo 思路为使用Dialog，提供可选择的主题颜色，然后点击对应颜色则切换应用主题颜色，接下来一起实现。 创建主题model model 也可以看做是共享数据，继承ChangeNotifier，这样就能够调用notifyListeners方法触发ChangeNotifierProvider收到数据改变通知 1234567891011121314151617/// Created with Android Studio./// User: maoqitian/// Date: 2019/11/18 0018/// email: maoqitian068@163.com/// des: 主题 modelimport 'package:flutter/material.dart';class ThemeModel extends ChangeNotifier &#123; int settingThemeColor ; ThemeModel(this.settingThemeColor); void changeTheme (int themeColor)&#123; this.settingThemeColor = themeColor; // 通知监听器（订阅者），重新构建InheritedProvider， 更新状态。 notifyListeners(); &#125;&#125; MaterialApp作为ChangeNotifierProvider子widget 改变主题颜色，也就是MaterialApp的theme 属性，所以讲 MaterialApp作为ChangeNotifierProvider子widget，这样MaterialApp就能收到共享的主题颜色数据值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int themeColor =0; @override void initState() &#123; super.initState(); themeColor = sp.getInt(SharedPreferencesKeys.themeColor); if(themeColor == null )&#123; themeColor = 0xFF3391EA;//默认蓝色 &#125; &#125; @override Widget build(BuildContext context) &#123; return Center( child: ChangeNotifierProvider&lt;ThemeModel&gt;( data: ThemeModel(themeColor), child: Consumer&lt;ThemeModel&gt;( builder: (BuildContext context,themeModel)&#123; return MaterialApp( theme: ThemeData( primaryColor: Color(themeModel.settingThemeColor), ), home: Scaffold( appBar: AppBar( title: Text("Flutter Theme Change"), actions: &lt;Widget&gt;[ Builder(builder: (context)&#123; return IconButton(icon: new Icon(Icons.color_lens), onPressed: ()&#123; _changeColor(context); &#125;); &#125;,) // onPressed 点击事件 ], ), body: Center( child: Text("主题变化测试"), ) ), ); &#125;, ), ), ); &#125; void _changeColor(BuildContext context) &#123; buildSimpleDialog(context); &#125; 在AppBar 加入IconButton 让其点击能显示颜色选择Dialog，Dialog 显示的是一个颜色值数组widget，每个widget实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142class SingleThemeColor extends StatelessWidget &#123; final int themeColor; final String colorName; const SingleThemeColor(&#123;Key key,this.themeColor, this.colorName&#125;): super(key:key); @override Widget build(BuildContext context) &#123; return InkWell( onTap: () async&#123; print("点击了改变主题"); //改变主题 ChangeNotifierProvider.of&lt;ThemeModel&gt;(context,listen: false).changeTheme(this.themeColor); await SpUtil.getInstance()..putInt(SharedPreferencesKeys.themeColor, this.themeColor); Navigator.pop(context); &#125;, child: new Column( // 竖直布局 children: &lt;Widget&gt;[ Container( width: 50, height: 50, margin: const EdgeInsets.all(5.0), decoration: BoxDecoration( //圆形背景装饰 borderRadius:BorderRadius.all( Radius.circular(50) ), color: Color(this.themeColor) ), ), Text( colorName, style: TextStyle( color: Color(this.themeColor), fontSize: 14.0), ), ], ), ); &#125;&#125; 可以看到每个widget点击响应onTap 则调用ChangeNotifierProvider.of获取ThemeModel对象调用changeTheme方法来触发notifyListeners方法。还有一些细节，比如通过SharedPreferences保存颜色值等代码，具体可以查看文末demo 项目源码地址。 Demo 运行效果 最后 看到这里，相信你应该对InheritedWidget有了比较好的理解，了解了原理，使用起轮子来也会更加得心应手吧。如果要使用跨组件数据共享，还是直接使用功能完整的Provider吧。又一篇文章完成了，相信多少都会对看到文章的你有帮助，文章中如果有错误，请大家给我提出来，大家一起学习进步，如果觉得我的文章给予你帮助，也请给我一个喜欢和关注，同时也欢迎访问我的个人博客。 Demo 地址 https://github.com/maoqitian/flutter_demo 参考 Flutter 实战电子书 About meblog： 个人博客 掘金 简书 Githubmail： maoqitian@gmail.com maoqitian068@163.com]]></content>
      <categories>
        <category>Flutter探索</category>
      </categories>
      <tags>
        <tag>dart</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter 与 Dart 语法初探]]></title>
    <url>%2F2019%2F12%2F01%2FFlutter-%E4%B8%8E-Dart-%E8%AF%AD%E6%B3%95%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[什么是flutter google 推出的跨平台UI框架 环境搭建(MAC环境) Flutter 依赖下面这些命令行工具1bash, mkdir, rm, git, curl, unzip, which 获取Flutter SDK flutter官网下载其最新可用的安装包 安装包下载完成则可以进行解压 1unzip /指定解压目录/flutter_macos_v1.9.1+hotfix.4-stable.zip 解压完成之后我们会在解压好的目录下会多出一个flutter目录，获取并记住该目录路径，下一步我们会用到 12# 使用pwd 命令查看目录路径/Users/XXXXX/development/flutter 设置环境变量 设置环境变量目的是以便我们可以运行flutter命令在任何终端会话中 确定Flutter SDK的目录，上一步我们解压获取了flutter的路径/Users/XXXXX/development/flutter 打开(或创建) $HOME/.bash_profile. 文件路径和文件名可能在您的机器上不同（注意$HOME 指的是 路径是 /Users/用户名XX/ ） 1vim $HOME/.bash_profile 文件加入环境变量 1234export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置//export PATH=/Users/XXXXX/development/flutter/bin:$PATH 最后我们执行创建好的.bash_profile文件 12source $HOME/.bash_profile注意: 如果你使用的是zsh，终端启动时 ~/.bash_profile 将不会被加载，解决办法就是修改 ~/.zshrc ，在其中添加：source ~/.bash_profile flutter dev 网站执行 flutter docter 检查本机软件环境，没安装的插件根据提示安装就行了 1flutter doctor 手动升级 Flutter flutter 版本升级迭代很快，前面我们下载SDK默认是stable分支，也就是稳定版，如何手动升级呢？只需要下面一条flutter命令 1flutter upgrade Dart 语法 我们知道Flutter框架是使用Dart 语言来编写的，Dart 是一个面向对象编程语言， 每个对象都是一个类的实例，所有的类都继承于 Object.如果熟悉Java，语言是很容易上手的。首先来熟悉一下Dart语法 Dart 变量 var 声明变量，和 kt 、js语法很像，需要注意的是如下示例 name 只要复制字符串，则他就是String类型，number就是int 类型，不能再更改它的类型，而没有初始化的变量自动获取一个默认值为 null。 12var name = 'maoqitian';var number = 1; Dart 常量 final 和 const声明都是表示常量，一个 final 变量只能赋值一次，可以省略变量类型，如下声明一个存放WordPair值的List 数组 123final List _suggestions = new List&lt;WordPair&gt;();final _suggestions = &lt;WordPair&gt;[]; const 关键字不仅仅只用来定义常量， 也可以用来创建不变的值 12//如下定义一个字体大小的值一直都是 18 ，不会改变final _biggerFont = const TextStyle(fontSize: 18.0) final 和 const区别 const 的值在编译期确定，final 的值要到运行时才确定 Dart 函数方法 Dart 是一个真正的面向对象语言，方法也是对象他的类型是 Function。 这意味着，方法可以赋值给变量，也可以当做其他方法的参数。 123456789101112//定义一个返回 bool(布尔)类型的方法 bool isNoble(int atomicNumber) &#123; return _nobleGases[atomicNumber] != null;&#125;//转换如下可以忽略类型定义isNoble(atomicNumber) &#123; return _nobleGases[atomicNumber] != null;&#125;//只有一个表达式的方法，你可以选择 使用缩写语法来定义// =&gt; expr 语法是 &#123; return expr; &#125; 形式的缩写bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null; Dart 方法参数 方法可以定义两种类型的参数：必需的和可选的。 必需的参数在参数列表前面， 后面是可选参数，必选参数没啥好说的，我们来了解可选参数。可选参数可以是自己命名参数或者基于可选位置的参数，但是这两种参数不能同时当做可选参数来一起用。 可选命名参数 调用可选命名参数方法的时候可以使用 paramName: value （key:value形式，只不是过key 是参数名称）来指定参数值 1234567//调用有可选命名参数方法 playGamesplayGames(bold: true, hidden: false);//playGames 方法playGames(&#123;bool bold, bool hidden&#125;) &#123; // ...&#125; 可选位置参数 方法参数列表中用[]修饰的参数就是可选位置参数1234567891011121314// 定义可选位置参数方法String playGames (String from, String msg, [String sports]) &#123; var result = '$from suggest $msg'; if (sports != null) &#123; result = '$result playing $sports together'; &#125; return result;&#125; // 不用可选参数 playGames('Bob', 'Howdy'); // 返回值 Bob suggest Howdy//使用可选参数playGames('I', 'Xiao Ming', 'basketball'); //返回值 I suggest Xiao Ming playing basketball together. Dart 方法参数默认值 在定义方法的时候，可以使用 = 来定义可选参数的默认值。 默认值只能是编译时常量。 如果没有提供默认值，则默认值为 null 12345678910// 定义可选位置参数方法String playGames (String from , String msg, [String sports = 'football']) &#123; var result = '$from suggest $msg'; if (sports != null) &#123; result = '$result playing $sports together'; &#125; return result;&#125;playGames('I', 'Xiao Ming'); //返回值 I suggest Xiao Ming playing football together. 入口函数（The main() function） 每个应用都需要有个顶级的 main() 入口方法才能执行 1234567// Android studio 创建Demo 项目 main.dart 文件开头 void main() =&gt; runApp(MyApp());//可以转换为void main()&#123; runApp(MyApp());&#125; 异步操作 async 方法和 await 异步操作，直接看看一个网络请求例子就能够了解 123456static Future&lt;ArticleListData&gt; getArticleData(int pageNum) async&#123; String path = '/article/list/$pageNum/json'; Response response = await HttpUtils.get(Api.BASE_URL+path); ArticleBaseData articleBaseData = ArticleBaseData.fromJson(response.data); return articleBaseData.data; &#125; 先了解这么多，更多Dart 相关内容可以查看Dart语言官网 Flutter官方文档 flutter.dev Flutter中文网 Flutter Hello world 在开始Flutter Hello world程序之前，作为一名Android 开发者，首先我们要认识到Flutter中没有原生开发的XML，所有界面和逻辑代码都在.dart文件中，Flutter给我提供了一套视觉、结构、平台、和交互式的Widgets，所以在Flutter中一构架的一切界面都是Widgets。接下来我们先看一个简单的Hello World Flutter应用。 Android Studio 新建Flutter demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new MaterialApp( theme: ThemeData( primaryColor: Colors.blueAccent, ), home: new Scaffold( appBar: new AppBar( title: new Center( child: new Text("Welcome to Flutter"), ) ), body: DemoStatelessWidget("Flutter Hello World ! 无状态的Widget"), ), ); &#125;&#125;//无状态 Widgetclass DemoStatelessWidget extends StatelessWidget&#123; final String text; //构造方法传入 text 值 DemoStatelessWidget(this.text); @override Widget build(BuildContext context) &#123; // TODO: implement build return Container( constraints: BoxConstraints.expand( height: Theme.of(context).textTheme.display1.fontSize * 1.1 + 200.0, ), padding: const EdgeInsets.all(8.0), color: Colors.blue[600], alignment: Alignment.center, child: Text(text, style: Theme.of(context) .textTheme .display1 .copyWith(color: Colors.white)), transform: Matrix4.rotationZ(0.1), ); &#125;&#125; 运行结果 如上代码所示，首先main函数运行MyApp，MyApp 是一个DemoStatelessWidget，字面可以理解为一个没有状态的Widget，他的build 方法创建了MaterialApp这个Widget才使得应用可以跑在手机上，接着创建了Scaffold 这个Widget，可以让我们创建AppBar和页面内容，body 的页面内容又包含了一个无状态的DemoStatelessWidget，通过构造方法可以传入我们想要现实的页面内容，该widget包含白色背景和一个现实文字的Text widget。 Flutter ListView 上个小例子中我们提到无状态 StatelessWidget，想必也能猜到，肯定会有一个有状态的widget，这个widget就是StatefulWidget，该widget为何说是有状态的呢，主要是在其管理的State中我们可以调用setState来动态改变页面显示。接着我们看一个显示数据列表的例子，并加入一个可以点击收藏的按钮。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(MyApp());// StatelessWidget 无状态的widgetclass MyApp extends StatelessWidget &#123; //Stateless widgets是不可变的, 这意味着它们的属性不能改变 - 所有的值都是最终的. // This widget is the root of your application. @override Widget build(BuildContext context) &#123; return MaterialApp( //title: 'Welcome to Flutter', theme: ThemeData( primaryColor: Colors.blueAccent, ), home: new RandomWords(), ); &#125;&#125;//StatefulWidget 有状态的widgetclass RandomWords extends StatefulWidget&#123; @override createState() =&gt; new RandomWordsState();&#125;// 返回 显示单词对的ListView Widgetclass RandomWordsState extends State&lt;RandomWords&gt; &#123; //保存建议的单词对列表(变量以下划线（_）开头，在Dart语言中使用下划线前缀标识符，会强制其变成私有的) final _suggestions = &lt;WordPair&gt;[]; final List _suggestions = new List&lt;WordPair&gt;(); //设置字体大小的变量 final _biggerFont = const TextStyle(fontSize: 18.0); // 保存喜欢单词组的集合 set 集合不允许值重复 final Set _saved = new Set&lt;WordPair&gt;(); /// State 生命周期方法 @override void initState() &#123; // state 初始化 super.initState(); &#125; @override void didChangeDependencies() &#123; // 在 initState 之后调用，此时可以获取其他 State super.didChangeDependencies(); &#125; @override void dispose() &#123; // state 销毁 super.dispose(); &#125; @override Widget build(BuildContext context) &#123; //return new Text(new WordPair.random().asPascalCase); //返回单词对的ListView。 return new Scaffold( appBar: new AppBar( title:new Center( //居中显示 child: new Text('Flutter ListView'), ), ), body: _buildSuggestions(), ); &#125; //构建显示建议单词对的ListView。 Widget _buildSuggestions()&#123; return new ListView.builder( padding: const EdgeInsets.all(16.0), // 对于每个建议的单词对都会调用一次itemBuilder，然后将单词对添加到ListTile行中 // 在偶数行，该函数会为单词对添加一个ListTile row. // 在奇数行，该函数会添加一个分割线widget，来分隔相邻的词对。 //itemBuilder 值是一个匿名回调函数， 接受两个参数- BuildContext和行迭代器i。迭代器从0开始， // 每调用一次该函数，i就会自增1，对于每个建议的单词对都会执行一次。该模型允许建议的单词对列表在用户滚动时无限增长。 itemBuilder: (context,i)&#123; // 在每一列之前，添加一个1像素高的分隔线widget if(i.isOdd) return new Divider(); // 语法 "i ~/ 2" 表示i除以2，但返回值是整形（向下取整），比如i为：1, 2, 3, 4, 5 // 时，结果为0, 1, 1, 2, 2， 这可以计算出ListView中减去分隔线后的实际单词对数量 final index = i~/2; if(index &gt;= _suggestions.length)&#123; // 如果是建议单词列表中最后一个单词对 接着再生成10个单词对，然后添加到建议列表 _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125; ); &#125; //创建 ListTile中显示每个新词对 Widget _buildRow(WordPair suggestion) &#123; //获取是否保存了该单词状态 final isSaved = _saved.contains(suggestion); return new ListTile( // 设置 标题 title: new Text( suggestion.asPascalCase, style: _biggerFont, ), //图标 trailing: new Icon( //星型图标状态 isSaved ? Icons.favorite : Icons.favorite_border, color: isSaved ? Colors.deepOrange : null , ), onTap: ()&#123; // 当用户点击 ListTile 击时， ListTile 会调用它的onTap回调 setState(() &#123; //调用setState() 会为State对象触发build()方法，从而导致对UI的更新 if(isSaved)&#123; _saved.remove(suggestion); &#125;else&#123; _saved.add(suggestion); &#125; &#125;); &#125;, ); &#125;&#125; 运行效果 如上代码，将原来的无状态Widget改成了StatefulWidget，并在build中构建ListView，到此你可能有疑惑，不是说有状态的Widget，怎么还是创建Widget，有状态如何体现呢? 别急，我们看到_buildRow方法，方法中构建了ListTile 这个Widget，它响应点击事件回到为onTap方法，也就是当我们点击ListTile，我们在onTap方法中就可以调用setState方法来动态改变页面显示，也就是改变桃心收藏按钮变化（注意setState方法需要在State类中才能调用）。 State 是有周期的，其中包括三个函数： initState()：初始化方法 didChangeDependencies()：在 initState 之后调用，此时可以获取其他 State dispose()：state 销毁 如果你使用Android Studio 我们可以使用快捷键快速创建StatelessWidget和StatefulWidget，创建StatelessWidget快捷键为stl，创建StatefulWidget快捷键为stf。 小节总结 Flutter 页面都是由一个个 widget 搭建而来的 widget类型有两种，一种是无状态页面内容固定的StatelessWidget，一种是页面内容可以动态改变的 StatefulWidget Widget 速览 在开始开发实战之前，我们需要对基本常用的Widget有个大概的认识。 layout Widget 在刚开始写原生界面的时候，我们最先了解的也应该是布局，Flutter 也提供了不少布局widget，接下来列举一些常用的布局widget 布局名称 特点描述 Container 拥有单个子元素的布局widget，可以灵活设置 Padding 拥有单个子元素，给其子widget添加指定的填充 Center 将其子widget居中显示 Align 将其子widget对齐，并可以根据子widget的大小自动调整大小。 Row 可以拥有多个子元素，在水平方向上排列子widget的列表，和原生控件 LinerLayout orientation=”horizontal” 类似 Column 可以拥有多个子元素，在竖直方向上排列子widget的列表，和原生控件 LinerLayout orientation=”vertical” 类似 Stack 可以拥有多个子元素，允许其子widget简单的堆叠在一起 Flow 实现流式布局算法的widget ListView 可滚动的列表控件 了解更多的widget请参考 Flutter widget 目录. 界面 Widget 有了布局，还需要在布局中填放各种控件，才最终组成我们的页面，比如我们开发Material Design 风格的App，Flutter 就给我们提供了Material Components Widgets，接下来选取一些常用的控件来了解。了解更多的widget请参考 Material Components Widgets 目录。 Widget名称 特点描述 MaterialApp 封装了应用程序实现Material Design所需要的一些widget，由前面demo可以发现它一般为应用顶层入口widget Scaffold Material Design布局结构的基本实现。此类提供了用于显示drawer、snackbar和底部sheet的API。 Appbar 一般和Scaffold结合使用，可以设置页面标题和各种按钮等(Toolbar) BottomNavigationBar 底部导航条，可以很容易地在tap之间切换和浏览顶级视图 Drawer 和Scaffold结合使用，从Scaffold边缘水平滑动以显示应用程序中导航链接的Material Design面板 RaisedButton Material Design中的button，响应点击事件(button) IconButton 一个Material图标按钮，可以设置icon，点击时会有水波动画 TextField 文本输入框 （EditText） image 显示图片的widget(ImageView) Text 单一格式的文本 (TextView) 导航栏返回按钮监听 WillPopScope ，Flutter中可以通过WillPopScope来实现返回按钮拦截 以下示例提供两种效果，双击返回Toast提示（Toast库 fluttertoast: ^3.1.3），或者弹出提示dialog是否退出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import 'package:flutter/material.dart';class AppPage extends StatefulWidget &#123; @override _AppPageState createState() =&gt; _AppPageState();&#125;class _AppPageState extends State&lt;AppPage&gt; &#123; @override Widget build(BuildContext context) &#123; return WillPopScope( ///通过WillPopScope 嵌套，可以用于监听处理 Android 返回键的逻辑。 WillPopScope 并不是监听返回按键，只是当前页面将要被pop时触发的回调 child: Container(), onWillPop: () async&#123; return _doubleExitApp(); &#125; ); &#125; //双击返回 退出应用 bool _doubleExitApp()&#123; if (_lastPressedAt == null || DateTime.now().difference(_lastPressedAt) &gt; Duration(seconds: 1)) &#123; ToolUtils.ShowToast(msg: "再点一次退出应用"); //两次点击间隔超过1秒则重新计时 _lastPressedAt = DateTime.now(); return false; &#125; //应用关闭直接取消 Toast Fluttertoast.cancel(); return true;&#125; ///如果返回 return new Future.value(false); popped 就不会被处理 ///如果返回 return new Future.value(true); popped 就会触发 ///这里可以通过 showDialog 弹出确定框，在返回时通过 Navigator.of(context).pop(true);决定是否退出 /// 单击提示退出 Future&lt;bool&gt; _dialogExitApp(BuildContext context) &#123; return showDialog( context: context, builder: (context) =&gt; new AlertDialog( content: new Text("是否退出"), actions: &lt;Widget&gt;[ new FlatButton(onPressed: () =&gt; Navigator.of(context).pop(false), child: new Text("取消")), new FlatButton( onPressed: () &#123; Navigator.of(context).pop(true); &#125;, child: new Text("确定")) ], )); &#125; &#125; 最后 万事开头难，对于Flutter到此可以说是迈出了第一步，对于未尝试的东西，开始可能会有畏惧心理，但只要敢于尝试，敢于迈出第一步，相信难不难只在于自己的用心程度而言。本篇文章就先到这里，文章中如果有错误，请大家给我提出来，大家一起学习进步，如果觉得我的文章给予你帮助，也请给我一个喜欢和关注，同时也欢迎访问我的个人博客。 参考 Flutter 官方网站 Flutter中文网 Dart 官方网站 Dart 语言中文网 About meblog： 个人博客 掘金 简书 Githubmail： maoqitian@gmail.com maoqitian068@163.com]]></content>
      <categories>
        <category>Flutter探索</category>
      </categories>
      <tags>
        <tag>dart</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker容器学习（四）之Docker Compose]]></title>
    <url>%2F2019%2F09%2F30%2FDocker%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8BDocker-Compose%2F</url>
    <content type="text"><![CDATA[之前的文章中，我们使用docker run 命令来启动一个容器，而作为真正的线上业务环境，我们服务肯定不止一个，也就说明容器肯定不止一个，而如果还是手动的一个个来启动容器这未免会让人头皮发麻，幸好有Docker Compose，用于定义和运行多容器Docker应用程序的工具，有了它我们可以一次启动多个容器，这也非常适合与持续集成工具（Jenkins）来配合。 安装 Docker Compose 根据官方安装最新版本 1sudo curl -L "https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose 安装脚本添加执行权限 1chmod +x /usr/local/bin/docker-compose 注意： 根据前面的步骤理论上是安装完成了，但是我们执行官方命令只是下载到了/usr/local/bin/这个目录，添加脚本执行权限之后docker-compose并不能生效，依据官方文档提示复制该文件到/usr/bin/目录下，并未该文件添加脚本执行权限 123sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-composechmod +x /usr/bin/docker-compose 此时我们执行docker-compose版本命令就能看到版本号打印 12# docker-compose --versiondocker-compose version 1.24.0, build 0aa59064 命令补全工具 1sudo curl -L https://raw.githubusercontent.com/docker/compose/1.24.0/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose 版本 docker-compose.yml 命令 https://docs.docker.com/compose/compose-file/docker-compose 命令 和前面学习Docker容器命令一样，docker-compose也有不少命令 命令 含义 示例 build 构建或重新构建服务 build [options] [–build-arg key=val…] [SERVICE…]（使用 docker-compose help build 查看详细使用） help 查看docker-compose命令帮助文档 docker-compose help COMMAND（标识要看的命令） up 构建、创建、重新创建、启动，连接服务的相关容器。所有连接的服务都会启动，除非它们已经运行(前提该目录下已经存在docker-compose.yml文件) docker-compose up(直接启动，该命令退出，所有容器停止) docker-compose up -d (后台运行所有容器) kill 发送SIGKILL 信号停止指定服务的容器 docker-compose kill api-feign(注意该名称为docker-compose.yml中定义的服务名称) start 启动指定服务已存在的容器 docker-compose start api-feign stop 停止指定服务已存在的容器 docker-compose stop api-feign logs 查看服务的日志输出 docker-compose logs –tail=”all” api-feign（查看api-feign 全部日志输出） ps 列出所有容器 docker-compose ps （和docker ps -a 一样可以查看容器，显示信息不一样） rm 删除指定服务的容器 docker-compose rm api-feign 更多docker-compose命令查看docker-compose官方文档 编写docker-compose.yml 启动多服务 服务器任意目录编写文件 docker-compose.yml 1234567891011121314151617181920212223242526version: '3.4'services: configerver: # 指定一个服务名称 image: mao/configserver:0.0.1-SNAPSHOT # 镜像名称 ports: - 8666:8666 # 指定端口映射 eureka: image: test1/eureka1:0.0.1-SNAPSHOT ports: - 8805:8805 server-admin: image: mao/server-admin:0.0.1-SNAPSHOT ports: - 8806:8806 api-feign: image: mao/api-feign:0.0.1-SNAPSHOT ports: - 8840:8840 ribbon-consumer: image: mao/ribbon-consumer:0.0.1-SNAPSHOT ports: - 8830:8830 ribbon-provider: image: mao/ribbon-provider:0.0.1-SNAPSHOT ports: - 8820:8820 在docker-compose.yml目录下执行命令启动多个服务(安装好Docker Compose前提下) 12# docker compose 构建镜像并使用镜像启动容器（-d 表示后台启动）docker-compose up -d 由上图我们发现各个服务都已经启动在各自的容器当中，但是访问服务的时候只有configserver（配置中心）能够访问，其他服务都不能访问，我们仔细想想就能知道，除了配置中心，其他服务的配置文件都要通过配置中心来获取，但是docker-compose启动是同时的，所以配置中心服务还没提供其他服务就已经启动了，这显然会让其他服务报错，所以在生产环境中我们必须要控制服务的启动顺序，也就是最先启动配置中心，然后启动注册中心，最后再启动其他服务。 Docker Compose控制服务启动顺序 Docker Compose控制服务启动顺序官方文档说明，本文使用wait-for-it方案，除了wait-for-it，还有dockerize和 wait-for 方案。 wait-for-it是一个bash脚本，执行该脚本将等待主机和TCP端口的可用性。它可用于同步相互依赖的服务的启动，例如链接的docker容器如何使用 接下来我将介绍如何使用该脚本来控制我们服务启动顺序 首先我们可以将脚本打包到我们的镜像中，修改Dockerfile文件 12345#Dockerfile中 ....COPY wait-for-it.sh /wait-for-it.sh #在本项目模块根目录下复制wait-for-it.sh 到镜像/目录下RUN chmod +x /wait-for-it.sh # 修改脚本权限.... 再次使用docker-maven-plugin打包镜像 重新编写docker-compose.yml文件，添加entrypoint执行我们前面打包如镜像的wait-for-it.sh脚本监控配置中心是否已经提供服务，注意ENTRYPOINT指令是不会被覆盖的，最终会执行监控./wait-for-it.sh configerver:8666配置中心是否提供服务来通过配置中心获取配置来启动其他服务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253version: '3.7'services: configerver: # 指定一个服务名词 image: mao/configserver:0.0.1-SNAPSHOT # 镜像名称 ports: - 8666:8666 # 指定端口映射 depends_on: - eureka eureka: image: mao/eureka:0.0.1-SNAPSHOT ports: - 8805:8805 entrypoint: "./wait-for-it.sh configerver:8666 -- java -jar /app.jar" server-admin: image: mao/server-admin:0.0.1-SNAPSHOT ports: - 8806:8806 depends_on: - eureka - configerver entrypoint: "./wait-for-it.sh configerver:8666 -- java -jar /app.jar" api-feign: image: mao/api-feign:0.0.1-SNAPSHOT ports: - 8840:8840 depends_on: - eureka - configerver entrypoint: "./wait-for-it.sh configerver:8666 -- java -jar /app.jar" ribbon-consumer: image: mao/ribbon-consumer:0.0.1-SNAPSHOT ports: - 8830:8830 depends_on: - eureka - configerver entrypoint: "./wait-for-it.sh configerver:8666 -- java -jar /app.jar" ribbon-provider: image: mao/ribbon-provider:0.0.1-SNAPSHOT ports: - 8820:8820 depends_on: - eureka - configerver entrypoint: "./wait-for-it.sh configerver:8666 -- java -jar /app.jar" gateway: image: mao/gateway:0.0.1-SNAPSHOT ports: - 8081:8081 depends_on: - eureka - configerver entrypoint: "./wait-for-it.sh configerver:8666 -- java -jar /app.jar" 然后我们在服务器中执行docker-compose命令后台一键启动服务，不出意外服务就能够全部启动 1docker-compose up -d 最后 本篇文章我们学习了如何使用Docker Compose来启动多个容器，而多个容器改如何管理呢？谷歌已经给了我们答案，那就是使用k8s，而k8s是什么呢，请看我的这一篇文章Kubeadm 部署 Kubernetes 1.14.2 集群 参考链接 Docker is installed but Docker Compose is not ? why? wait for it Usage with Docker]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Maven</tag>
        <tag>Git</tag>
        <tag>CentOs</tag>
        <tag>docker-compose</tag>
        <tag>wait-for-it</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker容器学习（三）之Docker 镜像构建]]></title>
    <url>%2F2019%2F09%2F22%2FDocker%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8BDocker-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Docker 镜像构建一般使用Dockerfile，首先我们需要了解Dockerfile语法（Dockerfile官方文档），然后我们编写好Dockerfile文件之后就可以开始构建我们的项目对应Docker镜像，如果构建呢？我们可以手动使用docker命令构建，也可以使用开源插件帮助构建，请往下看。 Dockerfile 构建镜像自己手动构建 首先我们使用maven 命令将项目打包成 jar 包（jar包一般生成在项目的target目录中） 1mvn install 将jar包复制到服务器我们想要的位置，使用docker命令构建docker镜像 12# 格式：docker build -t 标签名称 Dockerfile的相对位置docker build -t configserver . Dockerfile 内容 1234567891011121314# 基于哪个镜像FROM java:8# 将本地文件夹挂载到当前容器VOLUME /data/cloudtest# 拷贝文件到容器，也可以直接写成ADD xxxxx.jar /app.jarADD configserver-0.0.1-SNAPSHOT.jar /app.jar# 声明需要暴露的端口EXPOSE 8666# 配置容器启动后执行的命令ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"] 启动构建好的镜像 1docker run -p 8666:8666 configserver 使用插件来构建镜像 使用插件之前，如果本地环境中没有安装docker，则我们也可以使用远程服务器安装的docker来帮助我们构建，如何使用远程docker呢，首先我们要开启docker的远程访问Centos7中docker开启远程访问 在/usr/lib/systemd/system/docker.service，配置远程访问。主要是在[Service]这个部分，加上下面两个参数 1234# vim /usr/lib/systemd/system/docker.service[Service]ExecStart=ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 以上配置完成之后我们需要重新读取docker配置文件，重新启动docker服务 12systemctl daemon-reloadsystemctl restart docker 看进程docker是否已经监听2375端口，命令为 ps aux | grep docker 12root 8902 0.5 0.1 637948 37388 ? Ssl 10:34 1:30 /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sockroot 8909 0.0 0.0 432312 10904 ? Ssl 10:34 0:09 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runc 此时docker已经开启远程访问地址为 服务器地址:2375(别忘了服务器防火墙需要开放2375端口) docker-maven-plugin（spotify） 使用docker-maven-plugin来构建镜像 配置POM build 模块，使用docker 镜像私服（nexus）作为镜像仓库 1234567891011121314151617181920212223242526&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;172.31.116.12:9290/mao/microservice-discovery-eureka:0.0.1&lt;/imageName&gt; &lt;dockerDirectory&gt;$&#123;project.basedir&#125;&lt;/dockerDirectory&gt; &lt;!--远程docker 地址--&gt; &lt;dockerHost&gt;http://172.31.76.16:2375&lt;/dockerHost&gt; &lt;!--&lt;dockerCertPath&gt;&lt;/dockerCertPath&gt;--&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 与maven配置文件settings.xml中配置的server.id一致，用于推送镜像 --&gt; &lt;serverId&gt;docker-nexus&lt;/serverId&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 创建并上传镜像执行 1mvn clean package docker:build -DpushImage 构建成功，使用docker 查看构建成功的镜像 可借助imageTags元素更为灵活地指定镜像名称和标签 1234567891011121314151617181920212223242526272829303132&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;172.31.116.12:9390/test/eureka&lt;/imageName&gt; &lt;dockerDirectory&gt;$&#123;project.basedir&#125;&lt;/dockerDirectory&gt; &lt;!--远程docker 地址--&gt; &lt;dockerHost&gt;http://172.31.76.16:2375&lt;/dockerHost&gt; &lt;!--&lt;dockerCertPath&gt;&lt;/dockerCertPath&gt;--&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;!--Dockerfile文件路径 此路径代表本项目根目录--&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--重复构建相同标签名称的镜像，可将forceTags设为true，这样就会覆盖构建相同标签的镜像--&gt; &lt;forceTags&gt;true&lt;/forceTags&gt; &lt;!--借助imageTags元素更为灵活地指定镜像名称和标签--&gt; &lt;imageTags&gt; &lt;imageTag&gt;0.0.1&lt;/imageTag&gt; &lt;imageTag&gt;latest&lt;/imageTag&gt; &lt;/imageTags&gt; &lt;!-- 与maven配置文件settings.xml中配置的server.id一致，用于推送镜像 --&gt; &lt;serverId&gt;docker-nexus&lt;/serverId&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 使用如下命令进行构建（注意构建命令和没有加入imageTags有所不同） 1mvn clean package docker:build -DpushImageTag docker-maven-plugin 多项目共同构建 以上配置我们只是针对单个项目配置，如果项目中包含多个子项目，我们希望一起打包成镜像并上传到私服，则需要用到phase 将镜像构建绑定到maven 命令上 平常打包构建命令为mvn clean package docker:build，而对应maven的命令格式为mvn phase:goal，所以打包构建命令中package docker对应为phase，build则对应goal，这样根据官方文档提示将POM改造得出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;!--将构建的触发绑定到对应的命令上--&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;build-image&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;build&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;tag-image&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;tag&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;image&gt;test1/eureka1:$&#123;project.version&#125;&lt;/image&gt; &lt;newName&gt;172.31.116.12:9290/test1/eureka1:$&#123;project.version&#125;&lt;/newName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;push-image&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;push&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;imageName&gt;172.31.116.12:9290/test1/eureka1:$&#123;project.version&#125;&lt;/imageName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;imageName&gt;test1/eureka1:$&#123;project.version&#125;&lt;/imageName&gt; &lt;!--镜像名--&gt; &lt;!--Dockerfile文件路径 此路径代表本项目根目录--&gt; &lt;dockerDirectory&gt;$&#123;project.basedir&#125;&lt;/dockerDirectory&gt; &lt;!--本地不安装 docker 使用远程docker 地址，该地址为docker 开启远程访问地址 --&gt; &lt;dockerHost&gt;http://172.31.76.16:2375&lt;/dockerHost&gt; &lt;!--&lt;dockerCertPath&gt;&lt;/dockerCertPath&gt;--&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- 指定资源文件 --&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;!-- 指定要复制的目录路径，这里是当前目录 --&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;!-- 指定要复制的根目录，这里是target目录 --&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;!-- 指定需要拷贝的文件，这里指最后生成的jar包 --&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--重复构建相同标签名称的镜像，可将forceTags设为true，这样就会覆盖构建相同标签的镜像--&gt; &lt;forceTags&gt;true&lt;/forceTags&gt; &lt;!--覆盖相同标签镜像--&gt; &lt;!-- 与maven配置文件settings.xml中配置的server.id一致，用于推送镜像 --&gt; &lt;serverId&gt;docker-nexus&lt;/serverId&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 如此我们只要在项目根目录使用命令，则项目就会自动打包构建镜像并上传到nexus私服 12## -DskipTests 表示 跳过Testmvn clean package -DskipTests Docker 私有仓库结合 nexus 搭建与使用 每次构建好的镜像我们存放在哪呢，这里可以搭建自己的私服仓库来存放docker镜像。安装nexus Centos下 Nexus 搭建Maven 私服创建私有仓库 docker连接私服仓库 上一小节我们创建好了私服仓库，还需配置，在docker服务器新建文件 12345678# 配置 vim /etc/docker/daemon.json 填写我们仓库地址和对应的仓库端口号&#123; "insecure-registries": ["xxx.xxx.xxx.xxx:9290"] &#125;# 重启dockersystemctl daemon-reloadsystemctl restart docker 登录仓库，输入nexus的用户名和密码，默认用户名为admin，密码为admin123 1docker login xxx.xxx.xxx.xxx:9290]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Maven</tag>
        <tag>Git</tag>
        <tag>CentOs</tag>
        <tag>Nexus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker容器学习（二）之Docker 命令]]></title>
    <url>%2F2019%2F09%2F22%2FDocker%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8BDocker-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker 命令 上一篇文章我们了解如何在CentOs安装Docker,接下来我们学习Docker 命令 Docker镜像常用命令 命令 解释 docker images 或者 docker image ls 列表本地所有镜像 docker search 关键词 在Docker Hub中搜索镜像 docker pull 镜像名称 下载Docker镜像 docker rmi 镜像id 删除Docker镜像。加参数-f表示强制删除。 docker run 镜像名称称 下载Docker镜像 docker build -t 标签名称 目录 构建Docker镜像，-t 表示指定一个标签 docker tag 为镜像打标签 Docker 容器常用命令 命令 解释 docker ps 列表所有运行中的Docker容器（包括已停止的容器）。该命令参数比较多，-a：列表所有容器；-f：过滤；-q 只列表容器的id。 docker version 查看docker 版本信息 docker –version 查看docker 版本 docker info 查看Docker系统信息，例如：CPU、内存、容器个数等等 docker kill 容器id 杀死id对应容器 docker start / stop / restart 容器id 启动、停止、重启指定容器 更多命令，请输入–help参数查询；如果想看docker命令可输入docker –help；如果想查询docker run命令的用法，可输入docker run –help。搜索、下载、删除镜像 1234567891011# 搜索镜像 nginxNAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 11281 [OK] jwilder/nginx-proxy Automated Nginx reverse proxy for docker c... 1586 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable ... 708 [OK]jrcs/letsencrypt-nginx-proxy-companion LetsEncrypt container to use with nginx as... 504 [OK]webdevops/php-nginx Nginx with PHP-FPM 125 [OK]zabbix/zabbix-web-nginx-mysql Zabbix frontend based on Nginx web-server ... 96 [OK]bitnami/nginx Bitnami nginx Docker Image 65 [OK]linuxserver/nginx An Nginx container, brought to you by Linu... 59 1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5 ubuntu-16-nginx-php-phpmyadmin-mysql-5 50 [OK] NAME：镜像仓库名称。 DESCRIPTION：镜像仓库描述。 STARS：镜像仓库收藏数，表示该镜像仓库的受欢迎程度，类似于GitHub的Stars。 OFFICAL：表示是否为官方仓库，该列标记为[OK]的镜像均由各软件的官方项目组创建和维护。由结果可知，java这个镜像仓库是官方仓库，而其他的仓库都不是镜像仓库。 AUTOMATED：表示是否是自动构建的镜像仓库。 12#下载镜像docker pull nginx 列出镜像 docker images 或者 docker image ls 123REPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 27a188018e18 7 days ago 109MBhello-world latest fce289e99eb9 3 months ago 1.84kB REPOSITORY：镜像所属仓库名称。 TAG：镜像标签。默认是latest，表示最新。 IMAGE ID：镜像ID，表示镜像唯一标识。 CREATED：镜像创建时间。 SIZE：镜像大小。 删除镜像 1234# 删除指定名称镜像docker rmi hello-world#删除所有镜像docker rmi -f $(docker images) docker run 命令启动容器 该命令即可新建并启动一个容器 选项 含义 -d 表示后台运行2 -P 随机端口映射（指定端口映射） 12345# 指定端口映射，有以下四种格式。 ip:hostPort:containerPort ip::containerPort hostPort:containerPort containerPort 例子 启动一个nginx容器123456789# 前面我们已经pull了一个nginx的镜像 # -d # 后台运行# -p 宿主机端口:容器端口 # 开放容器端口到宿主机端口 （服务器防火墙必须开放91端口）docker run -d -p 91:80 nginx浏览器访问 http://服务器地址:91/ 能够成功访问说明我们# 需要注意的是，使用docker run命令创建容器时，会先检查本地是否存在指定镜像。如果本地不存在该名称的镜像，Docker就会自动从Docker Hub下载镜像并启动一个Docker容器。 Docker基本命令实践列出容器 docker ps -a 12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESded3613de77d nginx "nginx -g 'daemon ..." 4 hours ago Up About an hour 0.0.0.0:91-&gt;80/tcp nervous_curie CONTAINER_ID：表示容器ID。 IMAGE：表示镜像名称。 COMMAND：表示启动容器时运行的命令。 CREATED：表示容器的创建时间。 STATUS：表示容器运行的状态。Up表示运行中，Exited表示已停止。 PORTS：表示容器对外的端口号。 NAMES：表示容器名称。该名称默认由Docker自动生成，也可使用docker run命令的–name选项自行指定。 停止、强制停止、重启、删除容器1234567891011121314# 停止容器docker stop ded3613de77d# 强制停止容器docker kill ded3613de77d# 启动或者重启已经停止的容器docker start ded3613de77ddocker restart ded3613de77d# 删除容器docker rm ded3613de77d# 删除所有容器docker rm -f $(docker ps -a -q) 进入、退出容器 使用nsenter工具进入容器（nsenter工具包含在util-linux 2.23或更高版本中） 1234# 找到容器第一个进程的PID，可通过以下命令获取docker inspect --format "&#123;&#123;.State.Pid&#125;&#125;" $CONTAINER_ID# 获得PID，使用nsenter命令进入容器nsenter --target "$PID" --mount --uts --ipc --net --pid 实战例子 1234567[root@gxst_docker_76_16 ~]# docker restart ded3613de77d ded3613de77d[root@gxst_docker_76_16 ~]# docker inspect --format "&#123;&#123;.State.Pid&#125;&#125;" ded3613de77d26878[root@gxst_docker_76_16 ~]# nsenter --target 26878 --mount --uts --ipc --net --pidmesg: ttyname failed: No such file or directoryroot@ded3613de77d:/# 退出容器，在容器中使用exit命令即可 123root@ded3613de77d:/# exitlogout[root@gxst_docker_76_16 ~]# 可以结合以上两条命令写一个进入容器脚本 12# 新建脚本文件 vim docker-enter.sh 脚本代码 123456789101112131415#!/bin/bash#Use nsenter to access dockerCNAME=$1CPID=$(docker inspect --format "&#123;&#123;.State.Pid&#125;&#125;" $CNAME)if [ "$#" -gt 1 ]; then nsenter --target $CPID --mount --uts --ipc --net --pid -- "$2"else nsenter --target $CPID --mount --uts --ipc --net --pid -- /bin/bashfi 使用脚本进入容器 1sh docker-enter.sh ded3613de77d（容器名称或者ID）]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Maven</tag>
        <tag>Git</tag>
        <tag>CentOs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker容器学习（一）之Docker安装和启动]]></title>
    <url>%2F2019%2F09%2F15%2FDocker%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8BDocker%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[什么是Docker 首先我们了解什么是Docker Docker介绍 Docker 准备工作 目前使用服务器为CentOS 7.6 使用Docker构建微服务首先我们需要Java环境（JDK）,Maven和Git 安装JDK 到Oracle官网下载好 jdk-8u211-linux-x64.rpm 备用 首先查看系统自带java，并卸载 123456# 如果有结果出来，则说明自带了javajava -version # 查询出已经安装的javarpm -qa|grep java yum -y remove [删除上面查出来的东西，多个用空格分隔] 安装JDK 123cd /usrmkdir /usr/javarpm -ivh jdk-8u65-linux-x64.rpm 配置环境变量，编辑/etc/profile文件找到： export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 这一行，并在其下面一行添加如下内容，最后使profile文件环境变量生效 12345678910#编辑/etc/profile文件vim /etc/profile# 设置java环境变量export JAVA_HOME=/usr/java/jdk1.8.0_211-amd64 # 根据情况修改export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar#使profile文件环境变量生效source /etc/profile 最后可以使用如下命令查看Java 版本1java -version Maven的安装 下载 maven 3.6.1 12345678910# 执行以下命令tar -zxvf apache-maven-3.6.1-bin.tar.gz -C /data/opt# 在/etc/profile文件末尾增加以下配置# 设置Maven环境变量export MAVEN_HOME=/data/opt/apache-maven-3.6.1/export PATH=$MAVEN_HOME/bin:$PATH # 重载/etc/profile这个文件 source /etc/profile 测试 1mvn -v Maven本地仓库配置（/data/opt/apache-maven-3.6.1/conf/settings.xml） 1&lt;localRepository&gt;/data/maven/repo&lt;/localRepository&gt; 配置maven私服地址 和 登录私服账号密码 123456789101112131415161718&lt;!--私服账号配置--&gt; &lt;server&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;3rdParty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;!--私服地址配置--&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;local nexus&lt;/name&gt; &lt;url&gt;http://172.31.116.12:9190/repository/maven-public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 安装Git12345678910111213141516171819202122232425安装依赖yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidocyum install gcc perl-ExtUtils-MakeMaker如果已经安装了git,但是版本太老，可以先卸载yum remove git 下载git包解压tar -vxf git-2.15.1.tar.gz -C /opt进入git 目录cd /opt/git-2.18.0/执行以下命令make prefix=/usr/local/git allmake prefix=/usr/local/git installecho "export PATH=$PATH:/usr/local/git/bin" &gt;&gt; /etc/profile //配置环境变量source /etc/profile //跟新配置文件git --version 查看git版本 Docker 安装 Docker 官方安装文档准备工作 卸载老版本的Docker 12345678yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 在新的一台机器上安装Docker，首先我们需要设置Docker的存储仓库，然后我们就可以从存储仓库中安装和更新Docker 12345678# 安裝所需的包。 yum-utils提供yum-config-manager實用程序，devicemapper存儲驅動程序需要device-mapper-persistent-data和lvm2。yum install -y yum-utils \ device-mapper-persistent-data \ lvm2# 使用以下命令设置稳定版本（stable）存储库。yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 需要安装epel源 才能yum安装container-selinux 123456# 安装wget 网络工具yum -y install wgetwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum install epel-release #阿里云上的epel源 开始安装 直接安装最新版本 1yum install docker-ce docker-ce-cli containerd.io 查看可以安装版本 1yum list docker-ce --showduplicates | sort -r 指定安装的版本 12# 官方方法yum install docker-ce-17.03.1 docker-ce-cli-17.03.1 containerd.io 1234# 直接安装yum install docker-ce-17.09.1.ce-1.el7.centos# 或者安装其他版本yum install docker-ce-18.09.6 Docker 启动1systemctl start docker 放入测试镜像 1docker pull library/hello-world 启动测试镜像 1docker run hello-world 出现如下输出说明安装成功1234567891011121314151617181920Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 参考链接 Docker官方文档]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Maven</tag>
        <tag>Git</tag>
        <tag>CentOs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源库上传 jcenter]]></title>
    <url>%2F2019%2F09%2F03%2F%E5%BC%80%E6%BA%90%E5%BA%93%E4%B8%8A%E4%BC%A0-jcenter%2F</url>
    <content type="text"><![CDATA[平时撸代码避免不了在有些功能会使用到别人已经写好的轮子，别人的轮子开源库一般都已经上传了 jcenter仓库，我只需要比如 implementation ‘com.mao:xxxxxxx:1.0.0’一句话就能引入别人的开源库，这是怎么弄的呢？一般可以使用bintray-release插件和gradle-bintray-plugin插件，gradle-bintray-plugin插件不够简便（想了解可以看这篇文章https://www.cnblogs.com/mingfeng002/p/10255486.html），所以接下来我们就了解一下如何使用bintray-release插件将自己的开源库上传到jcenter。 注册jcenter账号注册 进入注册地址选择右边sign up here 进行注册 创建Repository（仓库） 注册成功之后创建Repository，作为存放开源库的仓库，选择为公共仓库（public），仓库名称和仓库类型为maven，仓库名称在后面上传时需要用到。 获取 API Key 登录bintray， Edit profile -&gt; API Key 可以获取上传的秘钥key，后面上传项目的时候需要用到 配置引入 bintray-release插件 项目根目录build.gradle配置，加入bintray-release插件 123456789101112131415161718buildscript &#123; repositories &#123; //原有配置 ，保持不变 &#125; dependencies &#123; // Android studio 原有IDE 配置，保持不变 classpath 'com.android.tools.build:gradle:3.4.1' //加入bintray-release插件 classpath 'com.novoda:bintray-release:0.9.1' &#125;&#125;allprojects &#123; //原有配置 ，保持不变&#125;....... 开源库目录build.gradle配置，每个配置描述都已经给出，完成这两个步骤，就可以准备上传开源库到jcenter了 12345678910111213141516171819202122232425262728293031apply plugin: 'com.android.library'apply plugin: 'com.novoda.bintray-release'//添加 bintray-release 配置android &#123; compileSdkVersion 28 defaultConfig &#123; //原有配置 ，保持不变 &#125; buildTypes &#123; release &#123; //原有配置 ，保持不变 &#125; &#125;&#125;dependencies &#123; //原有配置 ，保持不变 &#125;//添加publish &#123; userOrg = 'maoqitian'//bintray.com用户名 repoName = 'maolibrary' // bintray上仓库的名字 groupId = 'com.mao'//jcenter上的路径 artifactId = 'flexibleflowlayout'//项目名称 publishVersion = '1.0.0'//版本号 desc = 'Make flow layouts simpler'// 描述 website = 'https://github.com/maoqitian/FlowLayout'//一般填github 项目地址,一定是要有效的地址&#125; 上传开源库使用上传命令上传开源库 上传命令解析 1234gradlew clean build bintrayUpload //根命令-PbintrayUser=maoqitian //jcenter 账号用户名-PbintrayKey=Xxxxxxxxx //文章开头获取的API Key-PdryRun=false //配置参数，true 执行所以细节但是不上传开源库，false上传开源库 在项目根目录下执行上传命令 12345# window 下执行gradlew clean build bintrayUpload -PbintrayUser=maoqitian -PbintrayKey=Xxxxxxxxx -PdryRun=false# linux 下执行./gradlew clean build bintrayUpload -PbintrayUser=maoqitian -PbintrayKey=xxxxxxxxx -PdryRun=false 到这里，我们可以看到开源库已经上传成功，在jcenter也可以看到刚刚上传的开源库 Add to Jcenter提交审核开源库 经过上面的步骤，我确实已经把开源库上传到Jcenter了，但是我们还不能引用，要想引用上传的开源库还得提交人工审核，人工审核通过会收到站内message，并且开源库中的Add to Jcenter 也会消失。 版本更新 开源库有bug，或者我们进行迭代，就会涉及到版本更新，那就只需要修改开源库目录build.gradle配置中的版本号，其他配置保持不变，再次执行上传开源库命令就可以达到版本更新的目的。 123456789publish &#123; userOrg = 'maoqitian'//bintray.com用户名 repoName = 'maolibrary' // bintray上仓库的名字 groupId = 'com.mao'//jcenter上的路径 artifactId = 'flexibleflowlayout'//项目名称 publishVersion = '2.0.0'//版本号 desc = 'Make flow layouts simpler'// 描述 website = 'https://github.com/maoqitian/FlowLayout'//一般填github 项目地址,一定是要有效的地址&#125; 参考链接 Android 快速发布开源项目到jcenter]]></content>
      <categories>
        <category>development tool</category>
      </categories>
      <tags>
        <tag>jcenter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 基本架构之MVP分析与实践]]></title>
    <url>%2F2019%2F08%2F30%2FAndroidMVP%2F</url>
    <content type="text"><![CDATA[开发一个App，和起房子应该有异曲同工之处，起房子需要画好设计图纸，而我们开发App则需要先设计好App整个架构模式。目前Android一般有MVC、MVP和MVVM，本文则先来说说MVP架构。在了解MVP架构之前，有人可能会说，MVP架构是不是有点落后了，但是我想说，如果你公司有老项目，他就是用MVP架构写的，这时候我们MVP知识是不是就派上用场了；任何架构都有它存在的理由，学习架构的思想才是关键。MVP分别代表Model、View、Presenter三个英文字母，和传统的MVC 相比，C替换成了P。Presenter英文单词有主持人意思，也就是说Presenter是View 和 Model 的主持人，按照惯例我们先来看两张图。 MVC MVP 架构对比图mvc mvp 通过以上两张图对比，MVC在Android中就是我们刚开始学习Android时输出Android代码的真实写照，Activity不仅负责显示View，它还是Controller，我们可以在Activity开始网络请求，请求完成更新UI，也可以在Activity中通过UI组件获取用户输入数据，然后执行网络请求再更新UI，这样一来，一个功能复杂的页面一个Activity三四千行代码是很常见的事情，这也会导致后面维护代码人来读你的Activity代码可能会直接崩溃，同时代码的耦合度也很高。 而我们再看MVP架构，这就会很清晰，它把MVC中的VC进行解耦，也就是说把Activity中的UI逻辑抽象成View 接口 ,把业务逻辑抽象成 presenter 接口, model 还是原来的model，这样其实就呼应了文章我们所说presenter主持人的意思，model 更新UI需要通过presenter，view 更新model数据也需要通过presenter，相当于presenter主持大局。 说了这么多，其实MVC和MVP的区别可以用一句话代替，那就是View能否直接操作Model，接下来我们就看看MVP架构如何在Android中实践。 Android 实现 mvp 架构UI逻辑抽象成View接口1234567891011121314151617181920212223242526/** * @author maoqitian * @Description View 的基类 */public interface BaseView &#123; /** * 正常显示 */ void showNormal(); /** * 显示错误 */ void showError(); /** * 正在加载 */ void showLoading(); /** * 显示错误信息 * @param errorMsg 错误信息 */ void showErrorMsg(String errorMsg);&#125; 业务逻辑抽象成 Presenter 接口 抽象之前我们可以想一想，每个presenter都对应一个View 界面，所以我们需要一个方法来绑定对应的View，绑定的目的是为了方便我们在presenter中更新view，当界面销毁的时候也需要一个方法类解绑View。此外，界面肯定不止一个，并且肯定实现前面我们写的BaseView接口，我们用泛型代替，就有了如下BasePresenter 接口 1234567891011121314151617/** * @author maoqitian * @Description Presenter 基类接口 */public interface AbstractBasePresenter&lt;T extends BaseView&gt; &#123; /** * 绑定View * @param view */ void attachView(T view); /** * 解绑View */ void detachView();&#125; MVP工作流 前面我们已经抽象出了View、Presenter接口，接下来从结合文章开头MVP architectural pattern图从用户打开App获取数据开始展现整体MVP工作流。 View 与 Presenter 结合View 获取Presenter对象 View 获取数据需要通过Presenter对象，view在Android 中一般代表Avtivity、或者Fragment。先创建Avtivity和Fragment抽象类类做基础封装。 123456789101112131415161718192021222324252627282930313233/** * @author maoqitian * @Description activity基类 */public abstract class AbstractActivity extends AppCompatActivity&#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(getLayout()); onViewCreated(); initToolbar(); initEventAndData(); &#125; /** * view 的创建 留给子类实现 */ protected abstract void onViewCreated(); /** * 初始化 toolbar */ protected abstract void initToolbar(); /** * 初始化数据留给子类实现 */ protected abstract void initEventAndData(); /** * 获取布局对象 留给子类实现 */ protected abstract int getLayout();&#125; 接着我们实现MVP Activity基类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @author maoqitian * @Description MVP BaseActivity 基类 */public abstract class BaseActivity &lt;T extends AbstractBasePresenter&gt; extends AbstractActivity implements BaseView&#123; protected T mPresenter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; mPresenter = createPresenter(); super.onCreate(savedInstanceState); &#125; @Override protected void onViewCreated() &#123; if (mPresenter != null) &#123; mPresenter.attachView(this); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mPresenter != null)&#123; mPresenter.detachView(); mPresenter = null; &#125; &#125; /** * 创建Presenter */ protected abstract T createPresenter(); @Override public void showNormal() &#123; &#125; @Override public void showError() &#123; &#125; @Override public void showLoading() &#123; &#125; @Override public void showErrorMsg(String errorMsg) &#123; &#125;&#125; 到此，只要我们界面继承BaseActivity，并且实现createPresenter方法，我们就可以很直接在View中通过Presenter来获获取数据，如何获取呢？接着往下看。 Presenter 获取View 对象 现在我们创建一个Presenter基类将其与View结合，为后续步骤做准备，注意我们RxBasePresenter基类构造方法中需要传入DataClient，该类其实就可以概括代表Module。 12345678910111213141516171819202122232425/** * @author maoqitian * @Description 基于Presenter封装 */public class RxBasePresenter&lt;T extends BaseView&gt; implements AbstractBasePresenter&lt;T&gt;&#123; protected T mView; private DataClient mDataClient; public RxBasePresenter(DataClient dataClient)&#123; this.mDataClient=dataClient; &#125; @Override public void attachView(T view) &#123; this.mView=view; &#125; @Override public void detachView() &#123; this.mView = null; &#125;&#125; Presenter 与 View 之间连接 当我们创建View 对应Presenter让其继承 RxBasePresenter，则 Presenter便可以执行Updates view，如何操作呢？我们可以通过接口来进行数据获取与显示的扩展。以下举个例子 1234567891011public interface MainContract &#123; interface MainView extends BaseView&#123; void showMainData(); &#125; interface MainActivityPresenter extends AbstractBasePresenter&lt;MainView&gt;&#123; void getMainData(); &#125;&#125; 至此，我们基本MVP架构其实就已经搭建完成，我们来看看使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author maoqitian * @Description MainPresenter （Presenter） */public class MainPresenter extends RxBasePresenter&lt;MainContract.MainView&gt; implements MainContract.MainActivityPresenter &#123; //（Model） private DataClient mDataClient; public MainPresenter(DataClient dataClient) &#123; super(dataClient); this.mDataClient = dataClient; &#125; @Override public void attachView(MainContract.MainView view) &#123; super.attachView(view); &#125; //获取数据 @Override public void getMainData() &#123; //mDataClient 网络请求获取数据 ....... // 数据获取成功展示数据 mView.showMainData(); &#125;&#125;/** * @author maoqitian * @Description MainActivity （View） */public class MainActivity extends BaseActivity&lt;MainPresenter&gt;implements MainContract.MainView&#123; .......... @Override protected MainPresenter createPresenter() &#123; return new MainPresenter(new DataClient()); &#125; @Override protected void initEventAndData() &#123; mPresenter.getMainData(); &#125; @Override public void showMainData() &#123; //显示数据 &#125; &#125; 通过以上示例代码，再次对比文章开头的Android MVP architectural pattern图，从用户打开App获取数据开始展现整体MVP工作流已经走完。 谷歌官方示例MVP demo 当然上面只是简单的讲解了在Android中搭建基本MVP架构，其实谷歌官方也给我提供了MVP示例代码，具体代码可以自行去了解。 谷歌官方MVP示例Demo 使用dagger2优化MVP 架构 前面我们大致搭建了一个基础的MVP架构，每个Presnter需要我们在View 中去创建，创建Presnter的时候还需要传入Model，这就说明他们之间的解耦还不够。这里我们换一种思路，在原有基础，不管是DataClient（Model）还是对应的Presnter都可以直接提供对应的对象，然后对应的类创建我们就将其注入，这样不就省去了对象创建，Model、Presnter、View 之间耦合度就进一步降低，如何实现？还是强大的谷歌爸爸给我们提供了方案，使用Dagger2(Dagger是一个完全静态的编译时依赖注入框架，适用于Java和Android)。 项目添加对应dagger依赖 使用dagger对应版本为2.22.112345678dependencies &#123; implementation 'com.google.dagger:dagger:2.22.1' annotationProcessor 'com.google.dagger:dagger-compiler:2.22.1' // implementation 'com.google.dagger:dagger-android:2.22.1' implementation 'com.google.dagger:dagger-android-support:2.22.1' annotationProcessor 'com.google.dagger:dagger-android-processor:2.22.1'&#125; 改造Presnter类 这里我们以上面例子中MainPresenter为例，在其构造方法添加@Inject注解，表明Dagger2 可以从这获取对应MainPresenter实例，注意构造方法中需要DataClient对象，这里也使用Dagger来提供对象（稍后再说）12345678910public class MainPresenter extends RxBasePresenter&lt;MainContract.MainView&gt; implements MainContract.MainActivityPresenter &#123; private DataClient mDataClient; //@Inject注解表示Dagger2 可以从这获取Presenter 实例 @Inject public MainPresenter(DataClient dataClient) &#123; super(dataClient); this.mDataClient = dataClient; &#125;&#125; 改造View View 中结合 Dagger2 本应该继承 DaggerAppCompatActivity，但是我们基类为AbstractActivity，查看DaggerAppCompatActivity源码，直接手动实现DaggerAppCompatActivity中代码。1234567891011121314151617181920212223242526272829/** * @author maoqitian * @Description MVP BaseActivity 基类 */public abstract class BaseActivity &lt;T extends AbstractBasePresenter&gt; extends AbstractSimpleActivity implements BaseView, HasFragmentInjector,HasSupportFragmentInjector &#123; //Presenter 对象注入 (注意不能使用 private ) @Inject protected T mPresenter; //手动实现DaggerAppCompatActivity功能 @Inject DispatchingAndroidInjector&lt;Fragment&gt; supportFragmentInjector; @Inject DispatchingAndroidInjector&lt;android.app.Fragment&gt; frameworkFragmentInjector; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; //必须在super.onCreate之前调用AndroidInjection.inject AndroidInjection.inject(this); super.onCreate(savedInstanceState); &#125; @Override public AndroidInjector&lt;Fragment&gt; supportFragmentInjector() &#123; return supportFragmentInjector; &#125; @Override public AndroidInjector&lt;android.app.Fragment&gt; fragmentInjector() &#123; return frameworkFragmentInjector; &#125;&#125; 添加Dagger Module和Component创建MainActivityModule 抽象类MainActivityModule加入@Module注解，并添加返回我们对应MainActivityPresenter接口的抽象方法，@Binds注解就可以帮我们把MainActivityPresenter接口绑定到MainPresenter上。1234567891011/** * @author maoqitian * @Description MainActivity 可以提供的注入对象Module * @Time 2019/3/27 0027 23:59 */@Modulepublic abstract class MainActivityModule &#123; @ActivityScope @Binds abstract MainContract.MainActivityPresenter bindPresenter(MainPresenter presenter);&#125; 创建用于生成Activity注入器的Module类12345678910111213/** * @author maoqitian * @Description 用于生成Activity注入器的Module，使用@ContributesAndroidInjector注解并指定modules为 * @Time 2019/4/14 0014 14:09 */@Modulepublic abstract class ActivityBindingModule &#123; @ActivityScope @ContributesAndroidInjector(modules = MainActivityModule.class) abstract MainActivity contributeMainActivity(); &#125; 创建提供我们需要对象的Module类 与前文对应，这里我们提供了对应了DataClient对象，也就是MVP中的Model，在注入Presenter的时候将其一起注入。123456789@Modulepublic class MyAppModule &#123; @Provides @Singleton public DataClient providerDataClient()&#123; return new DataClient(); &#125;&#125; 使用@Component注解创建AppCompontent接口类 Dagger会帮我们自动生成DaggerAppComponent类，继承自AndroidInjector并指定我们自己的Application类，指定AndroidSupportInjectionModule帮助把Android中四大组件以及Fragment进行绑定，@Singleton注解指定单例12345678@Singleton@Component(modules = &#123; MyAppModule.class, ActivityBindingModule.class, AndroidSupportInjectionModule.class&#125;)public interface AppComponent extends AndroidInjector&lt;MyApplication&gt; &#123;&#125; 改造Application类继承自DaggerApplication 按照如下改造MyApplication之后我们从新编译编译一下代码，如果编译通过，dagger就会帮我们生成对应DaggerAppComponent.create()方法，将其返回在applicationInjector()方法中。 123456public class MyApplication extends DaggerApplication &#123; @Override protected AndroidInjector&lt;? extends DaggerApplication&gt; applicationInjector() &#123; return DaggerAppComponent.create(); &#125;&#125; 项目编译通过dagger会在build目录生成对应对象注入类，具体源码以后再出文章分析，这里就先告一段落了。到此，使用dagger2优化MVP 架构基本完成了，但是还有其他细节这里没有提及，比如每个Presenter之间该如何通信，可以使用EventBus，也可以Rxbus等等，具体细节可以看接下架构实践中我写的开源项目的代码。 架构实践项目介绍 通过前面对MVP架构分析介绍，接下来我给大家推荐我的一个开源项目，这是一款有较好用户体验的开源玩Android客户端。提供丰富完整的功能，更好的体验，旨在更好的浏览https://www.wanandroid.com/网站内容，更好的在手机上进行学习。项目使用Retrofit2 + RxJava2 + Dagger2 +MVP+RxBus架构，尽量使用Material Design控件进行开发。 项目架构图 项目地址 https://github.com/maoqitian/MaoWanAndoidClient 总结 以前所说的知识一种MVP架构的写法，我们也可以根据自己理解写出不一样的MVP，其实MVP架构看似不错，但也还是会有缺点，那就是写一个页面会产生很多个类，虽然结构清晰，但是要写的代码变多了，凡事都会有利弊。如果你不想自己写这么多的类，github上也有大神写好了轮子(MVPArms)专门帮我们生成MVP架构的框架，但是用框架生成代码总归是别人的，只有自己撸一遍，把逻辑流程梳理清楚才会变成自己的东西，才会成长。文章中如果有错误，请大家给我提出来，大家一起学习进步，如果觉得我的文章给予你帮助，也请给我一个喜欢和关注，同时也欢迎访问我的个人博客。]]></content>
      <categories>
        <category>Android架构</category>
      </categories>
      <tags>
        <tag>MVP</tag>
        <tag>Dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[撸一个既能学习Android知识又能提升技术的App]]></title>
    <url>%2F2019%2F08%2F27%2FWanAndroid%2F</url>
    <content type="text"><![CDATA[项目地址 https://github.com/maoqitian/MaoWanAndoidClient MaoWanAndoidClient项目简介 首先感谢鸿洋大佬提供的玩Android开放API，这是一款有较好用户体验的开源玩Android客户端。提供丰富完整的功能，更好的体验，旨在更好的浏览https://www.wanandroid.com/网站内容，更好的在手机上进行学习。项目使用Retrofit2 + RxJava2 + Dagger2 +MVP+RxBus架构，尽量使用Material Design控件进行开发。如果觉得本项目对你有帮助，希望您给我一个点一个Star. 下载本项目建议clone master分支,clone 本项目之后需编译生成dagger对应文件。项目基本架构 API玩Android开放API项目gif、截图展示 项目功能首页 首页文章列表 首页banner 常用网站 搜索热词（包含在搜索界面） 置顶文章 最新项目tab (首页的第二个tab) 知识体系 体系数据 知识体系下的文章 公众号 获取公众号列表 查看某个公众号历史数据 导航 导航数据 项目 项目分类 项目列表数据 登录与注册 登录、注册功能 收藏 收藏文章列表 收藏站内文章 收藏站外文章 取消收藏 收藏网站列表 收藏网址 编辑收藏网站 删除收藏网站 搜索 首页文章搜索 在某个公众号中搜索历史文章 积分 积分排行榜 获取个人积分 获取个人积分获取列表 广场 广场列表数据 分享人对应列表数据 自己的分享的文章列表（个人中心） 删除自己分享的文章（个人中心） 分享文章 设置 夜间模式 清除缓存 版本信息 退出登录 个人中心 点击头像进入个人中心，仿B站个人中心效果 Thanks参考项目 GeekNews 使用的第三方库 第三方库 功能 Dagger2 依赖注入 Retrofit2 网络 OKHttp3 网络 RxJava2 异步事件处理 greenDAO 数据库 SmartRefreshLayout 下拉刷新 Glide4 图片加载 Android-ConvenientBanner Banner BaseRecyclerViewAdapterHelper 数据适配器帮助类 butterknife 控件绑定 FlowLayout tag 显示 verticalTabLayout 纵向导航 图标 阿里巴巴矢量图标库 fontawesome 版本下载体验 历史版本下载地址最新版本下载二维码 可以手机浏览器输入以下地址下载 https://fir.im/kgy2 版本更新日志v1.0.5 (2019/10/12)新增广场模块 广场列表数据 分享人对应列表数据 自己的分享的文章列表（个人中心） 删除自己分享的文章（个人中心） 分享文章 个人中心页面支持加载更多 修复上个版本存在的bug v1.0.4 (2019/09/18)新增积分排行榜模块 添加积分排行榜入口，并完成数据展示页面，支持下拉刷新，加载更多 添加关于我们页面 修复上个版本存在的bug v1.0.3 (2019/09/09)新增个人中心模块 点击头像进入个人中心，仿B站个人中心效果 文章浏览页面增加收藏功能 修复上个版本存在的bug v1.0.2 (2019/09/03)新增我的积分模块 获取个人积分 获取个人积分获取列表 登录之后侧拉Drawer 显示等级和积分 修复上个版本存在的bug v1.0.1 (2019/08/29)完善收藏模块功能 收藏站外文章 收藏网站列表 收藏网址 编辑收藏网站 删除收藏网站 修复上个版本存在的bug v1.0.0 (2019/08/15) 项目第一个版本， 完成WanAndroid基本功能 Statement项目中的 API 均来自于 wanandroid.com 网站，纯属学习交流使用，不得用于商业用途。 LicenseCopyright 2019 maoqitian Licensed under the Apache License, Version 2.0 (the “License”);you may not use this file except in compliance with the License.You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an “AS IS” BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>MVP</tag>
        <tag>Dagger2</tag>
        <tag>App</tag>
        <tag>Retrofit2</tag>
        <tag>RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubeadm 部署 Kubernetes 1.14.2 集群]]></title>
    <url>%2F2019%2F07%2F31%2FKubernetes%2F</url>
    <content type="text"><![CDATA[kubernetes来源于希腊语，意为舵手或领航员，从k8s的logo也能看出这个船舵图标与其名称对应。而我们常说的k8s中的8代表的就是ubernete这个八个字符。这里引用k8s中文社区文档对k8s的描述：Kubernetes是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。 环境、主从节点规划各个节点规划 IP地址 角色 服务器系统 172.31.76.16 k8s从节点 CentOS 7.6 172.31.76.17 k8s从节点 CentOS 7.6 172.31.76.18 k8s主节点 CentOS 7.6 每个节点软件版本 软件名称 版本 作用 Docker 18.09.6 容器 Kubernetes 1.14.2 管理容器 Kubernetes安装组件介绍 组件名称 版本 作用 kubeadm 1.14.2-0 初始化k8s集群工具 kubectl 1.14.2-0 k8s命令行工具，命令控制部署管理应用，CRUD各种资源 kubelet 1.14.2-0 运行于所有节点上，负责启动容器和 Pod 准备工作每台节点服务器设置主机名12345# 主节点主机名对应 172.31.76.18hostnamectl --static set-hostname k8s-master# 从节点主机名对应 172.31.76.16 172.31.76.17hostnamectl --static set-hostname k8s-node-1hostnamectl --static set-hostname k8s-node-2 使用 hostnamectl命令可以查看是否设置成功 123456789101112# 使用hostnamectl命令 显示信息Static hostname: k8s-node-1Transient hostname: docker_76_16 Icon name: computer-vm Chassis: vm Machine ID: 8919fc90446b48fcbeb2c6cf267caba2 Boot ID: a684023646094b999b7ace62aed3cd2e Virtualization: vmware Operating System: CentOS Linux 7 (Core) CPE OS Name: cpe:/o:centos:centos:7 Kernel: Linux 3.10.0-327.el7.x86_64 Architecture: x86-64 每个节点的主机加入host 解析 12345# 编辑每台机器的 /etc/hosts文件，写入下面内容172.31.76.16 k8s-node-1172.31.76.17 k8s-node-2172.31.76.18 k8s-master 关闭每个节点的防火墙 123456789# 注意以下命令是下次生效systemctl disable firewalld.servicesystemctl stop firewalld.service# 关闭防火墙立即生效iptables -F# 防火墙关闭后可以使用以下命令查看防火墙状态systemctl status firewalld 临时禁用SELINUX(它是一个 Linux 内核模块，也是 Linux 的一个安全子系统)，我的机器默认是关闭的 12345setenforce 0 ##设置SELinux 成为permissive模式 （不用重启机器）# 修改配置文件 (重启机器生效)vim /etc/selinux/configSELINUX=disabled 每个节点关闭 swap 1swapoff -a 各个节点组件安装 经过前面的准备工作，接下来我们开始安装组件，注意一下组件每个节点都需要安装 Docker安装 请看我写的关于Docker的文章 安装 kubeadm、kubectl、kubelet 安装这几个组件前先准备repo 12345678910cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF 接着直接安装 kubeadm、kubectl、kubelet这个三个组件 1yum install -y kubelet kubeadm kubectl kubeadm、kubectl、kubelet组件下载安装成功 启动刚刚安装的kubelet1systemctl enable kubelet &amp;&amp; systemctl start kubelet k8s Master 节点配置准备镜像文件 国内环境由于网络不通畅问题，我们只能手动下载好镜像，再打上对应tag来制作本地镜像 Master 节点获取镜像文件 12345678docker pull mirrorgooglecontainers/kube-apiserver:v1.14.2docker pull mirrorgooglecontainers/kube-controller-manager:v1.14.2docker pull mirrorgooglecontainers/kube-scheduler:v1.14.2docker pull mirrorgooglecontainers/kube-proxy:v1.14.2docker pull mirrorgooglecontainers/pause:3.1docker pull mirrorgooglecontainers/etcd:3.3.10docker pull coredns/coredns:1.3.1docker pull registry.cn-shenzhen.aliyuncs.com/cp_m/flannel:v0.10.0-amd64 给拉取的镜像文件打tag 12345678docker tag mirrorgooglecontainers/kube-apiserver:v1.14.2 k8s.gcr.io/kube-apiserver:v1.14.2docker tag mirrorgooglecontainers/kube-controller-manager:v1.14.2 k8s.gcr.io/kube-controller-manager:v1.14.2docker tag mirrorgooglecontainers/kube-scheduler:v1.14.2 k8s.gcr.io/kube-scheduler:v1.14.2docker tag mirrorgooglecontainers/kube-proxy:v1.14.2 k8s.gcr.io/kube-proxy:v1.14.2docker tag mirrorgooglecontainers/pause:3.1 k8s.gcr.io/pause:3.1docker tag mirrorgooglecontainers/etcd:3.3.10 k8s.gcr.io/etcd:3.3.10docker tag coredns/coredns:1.3.1 k8s.gcr.io/coredns:1.3.1docker tag registry.cn-shenzhen.aliyuncs.com/cp_m/flannel:v0.10.0-amd64 quay.io/coreos/flannel:v0.10.0-amd64 删除拉取的初始镜像，留下我们加了tag的镜像 1234567891011121314151617docker rmi mirrorgooglecontainers/kube-apiserver:v1.14.2 docker rmi mirrorgooglecontainers/kube-controller-manager:v1.14.2 docker rmi mirrorgooglecontainers/kube-scheduler:v1.14.2 docker rmi mirrorgooglecontainers/kube-proxy:v1.14.2 docker rmi mirrorgooglecontainers/pause:3.1 docker rmi mirrorgooglecontainers/etcd:3.3.10 docker rmi coredns/coredns:1.3.1docker rmi registry.cn-shenzhen.aliyuncs.com/cp_m/flannel:v0.10.0-amd64docker rmi k8s.gcr.io/kube-apiserver:v1.14.2 docker rmi k8s.gcr.io/kube-controller-manager:v1.14.2 docker rmi k8s.gcr.io/kube-scheduler:v1.14.2 docker rmi k8s.gcr.io/kube-proxy:v1.14.2 docker rmi k8s.gcr.io/pause:3.1 docker rmi k8s.gcr.io/etcd:3.3.10 docker rmi k8s.gcr.io/coredns:1.3.1docker rmi quay.io/coreos/flannel:v0.10.0-amd64 开始安装kubernetes 输入以下命令开始安装kubernetes 1234# --kubernetes-version=v1.14.2 指定安装的k8s版本# --apiserver-advertise-address 用于指定使用k8s-master的哪个network 端口进行通信 # --pod-network-cidr 用于指定Pod的网络范围，下面采用的是flannel方案（https://github.com/coreos/flannel/blob/master/Documentation/kubernetes.md）kubeadm init --kubernetes-version=v1.14.2 --apiserver-advertise-address 172.31.76.18 --pod-network-cidr=10.244.0.0/16 如下为kubernetes初始化日志打印 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667[init] Using Kubernetes version: v1.14.2[preflight] Running pre-flight checks [WARNING Service-Docker]: docker service is not enabled, please run 'systemctl enable docker.service' [WARNING IsDockerSystemdCheck]: detected "cgroupfs" as the Docker cgroup driver. The recommended driver is "systemd". Please follow the guide at https://kubernetes.io/docs/setup/cri/[preflight] Pulling images required for setting up a Kubernetes cluster[preflight] This might take a minute or two, depending on the speed of your internet connection[preflight] You can also perform this action in beforehand using 'kubeadm config images pull'[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"[kubelet-start] Activating the kubelet service[certs] Using certificateDir folder "/etc/kubernetes/pki"[certs] Generating "etcd/ca" certificate and key[certs] Generating "etcd/peer" certificate and key[certs] etcd/peer serving cert is signed for DNS names [k8s-master localhost] and IPs [172.31.76.18 127.0.0.1 ::1][certs] Generating "etcd/healthcheck-client" certificate and key[certs] Generating "apiserver-etcd-client" certificate and key[certs] Generating "etcd/server" certificate and key[certs] etcd/server serving cert is signed for DNS names [k8s-master localhost] and IPs [172.31.76.18 127.0.0.1 ::1][certs] Generating "ca" certificate and key[certs] Generating "apiserver-kubelet-client" certificate and key[certs] Generating "apiserver" certificate and key[certs] apiserver serving cert is signed for DNS names [k8s-master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 172.31.76.18][certs] Generating "front-proxy-ca" certificate and key[certs] Generating "front-proxy-client" certificate and key[certs] Generating "sa" key and public key[kubeconfig] Using kubeconfig folder "/etc/kubernetes"[kubeconfig] Writing "admin.conf" kubeconfig file[kubeconfig] Writing "kubelet.conf" kubeconfig file[kubeconfig] Writing "controller-manager.conf" kubeconfig file[kubeconfig] Writing "scheduler.conf" kubeconfig file[control-plane] Using manifest folder "/etc/kubernetes/manifests"[control-plane] Creating static Pod manifest for "kube-apiserver"[control-plane] Creating static Pod manifest for "kube-controller-manager"[control-plane] Creating static Pod manifest for "kube-scheduler"[etcd] Creating static Pod manifest for local etcd in "/etc/kubernetes/manifests"[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory "/etc/kubernetes/manifests". This can take up to 4m0s[apiclient] All control plane components are healthy after 16.501690 seconds[upload-config] storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace[kubelet] Creating a ConfigMap "kubelet-config-1.14" in namespace kube-system with the configuration for the kubelets in the cluster[upload-certs] Skipping phase. Please see --experimental-upload-certs[mark-control-plane] Marking the node k8s-master as control-plane by adding the label "node-role.kubernetes.io/master=''"[mark-control-plane] Marking the node k8s-master as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule][bootstrap-token] Using token: y6awgp.6bvxt8l3rie2du5s[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster[bootstrap-token] creating the "cluster-info" ConfigMap in the "kube-public" namespace[addons] Applied essential addon: CoreDNS[addons] Applied essential addon: kube-proxyYour Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can join any number of worker nodes by running the following on each as root:kubeadm join 172.31.76.18:6443 --token y6awgp.6bvxt8l3rie2du5s \ --discovery-token-ca-cert-hash sha256:9989fe3160fe36c428ab2e05866f8d04a91704c5973dcf8025721c9e5e1b230c 注意： 看到上面Kubernetes初始化信息，我们需要注意最后一句话，等会我们子节点加入Kubernetes集群就是使用这一句话 12kubeadm join 172.31.76.18:6443 --token y6awgp.6bvxt8l3rie2du5s \ --discovery-token-ca-cert-hash sha256:9989fe3160fe36c428ab2e05866f8d04a91704c5973dcf8025721c9e5e1b230c 配置kubectl12345# root 模式下导入环境变量export KUBECONFIG=/etc/kubernetes/admin.conf# 重启 kubeletsystemctl restart kubelet 安装Pod的网络（flannel方案） flannel官方文档 1sysctl net.bridge.bridge-nf-call-iptables=1 然后在k8s-master节点上执行kube-flannel.yaml配置，也可根据官方文档来操作下载kube-flannel.yaml文件，下文也给出kube-flannel.yaml文件内容 1kubectl apply -f kube-flannel.yaml kube-flannel.yaml 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470---kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1beta1metadata: name: flannelrules: - apiGroups: - "" resources: - pods verbs: - get - apiGroups: - "" resources: - nodes verbs: - list - watch - apiGroups: - "" resources: - nodes/status verbs: - patch---kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1beta1metadata: name: flannelroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: flannelsubjects:- kind: ServiceAccount name: flannel namespace: kube-system---apiVersion: v1kind: ServiceAccountmetadata: name: flannel namespace: kube-system---kind: ConfigMapapiVersion: v1metadata: name: kube-flannel-cfg namespace: kube-system labels: tier: node app: flanneldata: cni-conf.json: | &#123; "name": "cbr0", "plugins": [ &#123; "type": "flannel", "delegate": &#123; "hairpinMode": true, "isDefaultGateway": true &#125; &#125;, &#123; "type": "portmap", "capabilities": &#123; "portMappings": true &#125; &#125; ] &#125; net-conf.json: | &#123; "Network": "10.244.0.0/16", "Backend": &#123; "Type": "vxlan" &#125; &#125;---apiVersion: extensions/v1beta1kind: DaemonSetmetadata: name: kube-flannel-ds-amd64 namespace: kube-system labels: tier: node app: flannelspec: template: metadata: labels: tier: node app: flannel spec: hostNetwork: true nodeSelector: beta.kubernetes.io/arch: amd64 tolerations: - operator: Exists effect: NoSchedule serviceAccountName: flannel initContainers: - name: install-cni image: quay.io/coreos/flannel:v0.10.0-amd64 command: - cp args: - -f - /etc/kube-flannel/cni-conf.json - /etc/cni/net.d/10-flannel.conflist volumeMounts: - name: cni mountPath: /etc/cni/net.d - name: flannel-cfg mountPath: /etc/kube-flannel/ containers: - name: kube-flannel image: quay.io/coreos/flannel:v0.10.0-amd64 command: - /opt/bin/flanneld args: - --ip-masq - --kube-subnet-mgr resources: requests: cpu: "100m" memory: "50Mi" limits: cpu: "100m" memory: "50Mi" securityContext: privileged: true env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace volumeMounts: - name: run mountPath: /run - name: flannel-cfg mountPath: /etc/kube-flannel/ volumes: - name: run hostPath: path: /run - name: cni hostPath: path: /etc/cni/net.d - name: flannel-cfg configMap: name: kube-flannel-cfg---apiVersion: extensions/v1beta1kind: DaemonSetmetadata: name: kube-flannel-ds-arm64 namespace: kube-system labels: tier: node app: flannelspec: template: metadata: labels: tier: node app: flannel spec: hostNetwork: true nodeSelector: beta.kubernetes.io/arch: arm64 tolerations: - operator: Exists effect: NoSchedule serviceAccountName: flannel initContainers: - name: install-cni image: quay.io/coreos/flannel:v0.10.0-arm64 command: - cp args: - -f - /etc/kube-flannel/cni-conf.json - /etc/cni/net.d/10-flannel.conflist volumeMounts: - name: cni mountPath: /etc/cni/net.d - name: flannel-cfg mountPath: /etc/kube-flannel/ containers: - name: kube-flannel image: quay.io/coreos/flannel:v0.10.0-arm64 command: - /opt/bin/flanneld args: - --ip-masq - --kube-subnet-mgr resources: requests: cpu: "100m" memory: "50Mi" limits: cpu: "100m" memory: "50Mi" securityContext: privileged: true env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace volumeMounts: - name: run mountPath: /run - name: flannel-cfg mountPath: /etc/kube-flannel/ volumes: - name: run hostPath: path: /run - name: cni hostPath: path: /etc/cni/net.d - name: flannel-cfg configMap: name: kube-flannel-cfg---apiVersion: extensions/v1beta1kind: DaemonSetmetadata: name: kube-flannel-ds-arm namespace: kube-system labels: tier: node app: flannelspec: template: metadata: labels: tier: node app: flannel spec: hostNetwork: true nodeSelector: beta.kubernetes.io/arch: arm tolerations: - operator: Exists effect: NoSchedule serviceAccountName: flannel initContainers: - name: install-cni image: quay.io/coreos/flannel:v0.10.0-arm command: - cp args: - -f - /etc/kube-flannel/cni-conf.json - /etc/cni/net.d/10-flannel.conflist volumeMounts: - name: cni mountPath: /etc/cni/net.d - name: flannel-cfg mountPath: /etc/kube-flannel/ containers: - name: kube-flannel image: quay.io/coreos/flannel:v0.10.0-arm command: - /opt/bin/flanneld args: - --ip-masq - --kube-subnet-mgr resources: requests: cpu: "100m" memory: "50Mi" limits: cpu: "100m" memory: "50Mi" securityContext: privileged: true env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace volumeMounts: - name: run mountPath: /run - name: flannel-cfg mountPath: /etc/kube-flannel/ volumes: - name: run hostPath: path: /run - name: cni hostPath: path: /etc/cni/net.d - name: flannel-cfg configMap: name: kube-flannel-cfg---apiVersion: extensions/v1beta1kind: DaemonSetmetadata: name: kube-flannel-ds-ppc64le namespace: kube-system labels: tier: node app: flannelspec: template: metadata: labels: tier: node app: flannel spec: hostNetwork: true nodeSelector: beta.kubernetes.io/arch: ppc64le tolerations: - operator: Exists effect: NoSchedule serviceAccountName: flannel initContainers: - name: install-cni image: quay.io/coreos/flannel:v0.10.0-ppc64le command: - cp args: - -f - /etc/kube-flannel/cni-conf.json - /etc/cni/net.d/10-flannel.conflist volumeMounts: - name: cni mountPath: /etc/cni/net.d - name: flannel-cfg mountPath: /etc/kube-flannel/ containers: - name: kube-flannel image: quay.io/coreos/flannel:v0.10.0-ppc64le command: - /opt/bin/flanneld args: - --ip-masq - --kube-subnet-mgr resources: requests: cpu: "100m" memory: "50Mi" limits: cpu: "100m" memory: "50Mi" securityContext: privileged: true env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace volumeMounts: - name: run mountPath: /run - name: flannel-cfg mountPath: /etc/kube-flannel/ volumes: - name: run hostPath: path: /run - name: cni hostPath: path: /etc/cni/net.d - name: flannel-cfg configMap: name: kube-flannel-cfg---apiVersion: extensions/v1beta1kind: DaemonSetmetadata: name: kube-flannel-ds-s390x namespace: kube-system labels: tier: node app: flannelspec: template: metadata: labels: tier: node app: flannel spec: hostNetwork: true nodeSelector: beta.kubernetes.io/arch: s390x tolerations: - operator: Exists effect: NoSchedule serviceAccountName: flannel initContainers: - name: install-cni image: quay.io/coreos/flannel:v0.10.0-s390x command: - cp args: - -f - /etc/kube-flannel/cni-conf.json - /etc/cni/net.d/10-flannel.conflist volumeMounts: - name: cni mountPath: /etc/cni/net.d - name: flannel-cfg mountPath: /etc/kube-flannel/ containers: - name: kube-flannel image: quay.io/coreos/flannel:v0.10.0-s390x command: - /opt/bin/flanneld args: - --ip-masq - --kube-subnet-mgr resources: requests: cpu: "100m" memory: "50Mi" limits: cpu: "100m" memory: "50Mi" securityContext: privileged: true env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace volumeMounts: - name: run mountPath: /run - name: flannel-cfg mountPath: /etc/kube-flannel/ volumes: - name: run hostPath: path: /run - name: cni hostPath: path: /etc/cni/net.d - name: flannel-cfg configMap: name: kube-flannel-cfg 查看Kubernetes的Pod 是否正常运行 1kubectl get pods --all-namespaces -o wide 查看Kubernetes主节点是否已经就绪1kubectl get nodes 最后别忘了执行（不执行使用kubectl命令会出现错误1） 12345mkdir -p $HOME/.kubecp -i /etc/kubernetes/admin.conf $HOME/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config k8s从节点（node）加入集群 前面准备工作中我们已经在各个节点中安装了kubelet kubeadm kubectl这三个组件，在搭建k8s master 主节点这一小节也提到过加入集群的操作（忘记了可以往上翻翻） 按照配置主节点的内容在docker 中加入镜像加入集群123# 基础命令示例 kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;kubeadm join 172.31.76.18:6443 --token pamsj1.4d5funpottlqofs1 --discovery-token-ca-cert-hash sha256:1152aa95b6a45e88211686b44a3080d643fa95b94ebf98c5041a7f88063f2f4e 我们可以在另一台node节点机器再次重复该操作 查看刚刚加入集群的子节点 至此集群的搭建完成。 子节点加入集群注意事项 加入集群前保证子节点服务器已经打开了docker服务 注意 token是否过期（默认24小时过期） 子节点注意保持镜像文件版本和主节点一致 子节点准备工作安装flannel网络 子节点如果加入集群不成功出现错误，下次再加入集群钱则使用 kubeadm reset 命令清除子节点加入集群自动生成的配置文件 k8s集群清理解散 删除子节点 123456# 查询k8s集群所以节点kubectl get nodes# 删除子节点 ，&lt;node name&gt; 代表子节点名称kubectl drain &lt;node name&gt; --delete-local-data --force --ignore-daemonsetskubectl delete node &lt;node name&gt; 重置节点 12# 不论主节点 还是 子节点该命令都能重置节点kubeadm reset k8s集群可视化管理工具Dashboard安装获取Dashboard镜像 官方地址 目前官方最新版本为v1.10.1，和前面获取国内镜像文件一样，我们先获取镜像，在把镜像打成对应tag的镜像（注意是每个节点都需要拉取镜像） 12345678# 拉取国内镜像docker pull mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.1# 重新标 tagdocker tag mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.1 k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1# 删除国内拉取的镜像docker rmi mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.1 安装Dashboard12345# 官方文档的安装操作kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml# 下载kubernetes-dashboard.yaml安装kubectl create -f kubernetes-dashboard.yaml Dashboard访问 Dashboard访问有四种方式（kubectl proxy、NodePort、API Server、Ingress），官方项目中提示我们用kubectl proxy 命令开启代理，然后直接访问地址http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/，如果是桌面电脑有浏览器当然可以，但是我们k8s部署在服务器上，这个方法显然不适合。此外，还有NodePort和Ingress等方式，由于由于API服务器是公开的，可以从外部访问，所以这里使用API Server的方式来访问dashboard，其他方式访问可以参考以下地址Kubernetes Dashboard v1.10.0安装、dashboard v1.10.1安装 API Server的方式访问 Dashboard 首先我们查看k8s运行的地址和端口号 123456#使用如下命令kubectl cluster-info# 集群正常会得到以下信息Kubernetes master is running at https://172.31.76.18:6443KubeDNS is running at https://172.31.76.18:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy 接着我们就可以开始访问Dashboard了 1234# 使用如下地址格式访问https://&lt;master-ip&gt;:&lt;apiserver-port&gt;/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/https://172.31.76.18:6443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/ 根据如上格式访问Dashboard会得到拒绝访问的信息，错误的原因是k8s基于安全性的考虑，浏览器必须要安装一个根证书，防止中间人攻击（官方描述），接下来我们来生成证书再操作。 12345678910111213&#123; "kind": "Status", "apiVersion": "v1", "metadata": &#123;&#125;, "status": "Failure", "message": "services \"https:kubernetes-dashboard:\" is forbidden: User \"system:anonymous\" cannot get resource \"services/proxy\" in API group \"\" in the namespace \"kube-system\"", "reason": "Forbidden", "details": &#123; "name": "https:kubernetes-dashboard:", "kind": "services" &#125;, "code": 403&#125; 生成证书（master 节点操作） 生成 crt 文件 1grep 'client-certificate-data' /etc/kubernetes/admin.conf | head -n 1 | awk '&#123;print $2&#125;' | base64 -d &gt;&gt; kubecfg.crt 生成 key 文件 1grep 'client-key-data' /etc/kubernetes/admin.conf | head -n 1 | awk '&#123;print $2&#125;' | base64 -d &gt;&gt; kubecfg.key 生成 p12 证书文件，需要设置生成证书密码 1openssl pkcs12 -export -clcerts -inkey kubecfg.key -in kubecfg.crt -out kubecfg.p12 -name "kubernetes-client" 将生产的p12证书导入到谷歌浏览器中，证书导入也需要密码，也就是上面步骤生成p12证书文件设置的密码，证书导入成功之后重启谷歌浏览器（如何导入证书这里就不细说了） 再次访问如下地址就会提示我们选择刚刚导入的证书，接下来就会显示如下图所示的认证界面1https://172.31.76.18:6443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/ 这里我们使用token认证，使用token认证前先创建dashboard用户， 1234567cat &lt;&lt;EOF | kubectl create -f -apiVersion: v1kind: ServiceAccountmetadata: name: admin-user namespace: kube-systemEOF 创建ClusterRoleBinding 1234567891011121314cat &lt;&lt;EOF | kubectl create -f -apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: admin-userroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-adminsubjects:- kind: ServiceAccount name: admin-user namespace: kube-systemEOF 然后我们在获取用户的token 1kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '&#123;print $1&#125;') 然后将token输入即可，至此Dashboard安装完成 删除部署的dashboard 如果dashboard部署不对，可以使用如下命令删除dashboard再重新部署1kubectl delete -f kubernetes-dashboard.yaml 搭建过程中出现的错误错误1： kubectl get nodes 命令出错错误描述 The connection to the server localhost:8080 was refused - did you specify the right host or port? node 节点使用kubectl get nodes命令不出意外也会出现上述错误描述，则我们应该把master 节点的/etc/kubernetes/admin.conf文件复制到node节点/etc/kubernetes/目录下再执行下面命令即可。 解决：（参考地址） 12345mkdir -p $HOME/.kubecp -i /etc/kubernetes/admin.conf $HOME/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config 其实以上解决答案在我们初始化master 节点的成功的打印信息中就已经提示我们配置了，不信可以翻看前文master 节点打印信息。 错误2： 子节点加入Kubernetes集群出现错误错误描述 FYI: You can look at this config file with ‘kubectl -n kube-system get cm kubeadm-config -oyaml’error execution phase preflight: unable to fetch the kubeadm-config ConfigMap: failed to get config map: Unauthorized 解决：（参考地址） 该错误的原因主要是因为token过期了（token默认有效期为24h）,所以我们只要在k8s master节点使用kubeadm命令重新创建新的token就好了12345# 创建新tokenkubeadm token create# 获取sha256openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //' 错误3：Kubeadm init 或者 join 出现错误错误描述1234[kubelet-check] It seems like the kubelet isn't running or healthy.[kubelet-check] The HTTP call equal to 'curl -sSL http://localhost:10248/healthz' failed with error: Get http://localhost:10248/healthz: dial tcp 127.0.0.1:10248: connect: connection refused.[kubelet-check] It seems like the kubelet isn't running or healthy.[kubelet-check] The HTTP call equal to 'curl -sSL http://localhost:10248/healthz' failed with error: Get http://localhost:10248/healthz: dial tcp 127.0.0.1:10248: connect: connection refused. 解决：（参考地址） 12sudo swapoff -asudo sed -i '/ swap / s/^/#/' /etc/fstab 重启机器 reboot the machine，机器重启之后如果docker 不是开机启动的记得启动docker服务 1234## 启动 docker 服务systemctl enable docker.service## 启动dockersystemctl start docker 重启服务器12# 重启命令reboot 错误4：子节点加入集群node节点DNS 服务 CrashLoopBackOff错误描述 解决： 查看有问题服务的日志123kubectl --namespace kube-system logs kube-flannel-ds-amd64-g997s错误日志：Error from server: Get https://172.31.76.17:10250/containerLogs/kube-system/kube-flannel-ds-amd64-g997s/kube-flannel: dial tcp 172.31.76.17:10250: connect: no route to host 从错误日志中可以看出是默认网关的问题，加入网卡默认网关即可，默认网关添加具体需要看自己服务器而定。 错误5：子节点加入集群node节点出现错误错误描述（路由异常问题）12error execution phase preflight: [preflight] Some fatal errors occurred: [ERROR FileContent--proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1 解决： （参考地址） 1234# 执行以下命令echo "1" &gt;/proc/sys/net/bridge/bridge-nf-call-iptables#再次执行 kubeadm join .......命令 参考链接 kubernetes官方文档 kubernetes中文社区 k8s 集群部署问题整理 Kubernetes安装Dashboard的方法和思路 利用Kubeadm部署 Kubernetes 1.13.1集群实践录、 简单的 Kubernetes 集群搭建 Kubernetes Dashboard v1.10.0安装]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
        <tag>kubeadm</tag>
        <tag>kubectl</tag>
        <tag>kubelet</tag>
        <tag>k8s Dashboard</tag>
        <tag>etcd</tag>
        <tag>flannel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos下 Nexus 3.x 搭建Maven 私服]]></title>
    <url>%2F2019%2F07%2F03%2FNexus%2F</url>
    <content type="text"><![CDATA[Maven的原理就是将jar从远程中央仓库下载到PC磁盘的本地仓库,当本地仓库没有发现需要的jar就会去Maven默认的远程中央仓库Maven Central（由Apache维护）中寻找,每次需要新的jar后都要从远程中央仓库上下载。那么问题来了？这个远程的中央仓库一定有很多人使用那下载速度一定很慢，这个暂且不用考虑。 重要的是万一哪天公司外网连不上了咋办？而Nexus私服恰好可以解决这个问题。搭建私服的好处是Nexus有效解决了Maven对Apache的远程中央仓库的依赖，当项目需要新的jar时会先在nexus私服下载好以后才会下载到本地。如果发现私服已经存在这个jar包，则会直接从私服下载到本地Maven库，如果没有再去网络上下载。同时，我们也可打包自己的代码变成jar包上传到私服中供公司其他同事下载使用。 准备工作 安装Nexus 之前先确定是否已经安装JDK,这里安装的是jdk8版本（如何安装JDK步骤叙述，） 安装Nexus nexus下载地址 下载完成后解压安装 解压 1tar -zvxf nexus-3.13.0-01-unix.tar.gz -C /opt/ 环境变量配置 1234vim /opt/nexus-3.13.0-01/bin/nexus//配置JDK 路径INSTALL4J_JAVA_HOME_OVERRIDE=/opt/jdk1.8.0_181 启动Nexus 1/opt/nexus-3.13.0-01/bin/nexus start 浏览器打开Nexus界面，默认端口号是8081（注意需要判断服务器是否开通了该端口号的监听，这里我将默认端口号改成9190） 1234567891011121314151617181920212223242526272829303132//加入9190端口的监听vim /etc/sysconfig/iptables查看是否监听端口(如果配置了自己定义的端口，需要先访问该端口一次才能看到监听)netstat -ntlp//重启防火墙配置（不重启端口还是无法生效）service iptables restart //修改端口号 vim /opt/nexus-3.13.0-01/etc/nexus-default.properties //重启Nexus /opt/nexus-3.13.0-01/bin/nexus restart Nexus其他命令 //停止 nexus stop //查看状态 nexus status 默认登录用户名密码 admin admin123 卸载 rm -rf nexus-3.13删除掉安装目录即可 //可以看到Nexus在浏览器中可以打开界面，部署成功，如下图 配置jenkins,maven更新到Nexus私服 修改Jenkins服务器上的Maven的settings.xml文件(路径是Maven安装路径 /opt/apache-maven-3.5.4/conf/)，加入maven访问nexus认证，访问Nexus的帐号密码为上面登录nexus的默认登录用户名密码 maven 项目pom文件配置私服仓库1234567891011121314151617181920212223&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;!--id要和上一步配置的id一致--&gt; &lt;name&gt;local nexus&lt;/name&gt; &lt;url&gt;http://xxxxx:9190/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt;&lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;local nexus&lt;/name&gt; &lt;url&gt;http://xxxxx:9190/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt;&lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; Nexus 默认的三种类型仓库，创建仓库的时候可以选择这三种123451.group(仓库组类型)：又叫组仓库，用于方便开发人员自己设定的仓库；2.hosted(宿主类型)：内部项目的发布仓库（内部开发人员，发布上去存放的仓库）3.proxy(代理类型)：从远程中央仓库中寻找数据的仓库（可以点击对应的仓库的 Configuration 页签下 Remote Storage Location 属性的值即被代理的远程仓库的路径） proxy(代理类型) 这里就是代理的意思，代理远程中央 Maven 仓库，当 项目构建访问中央库的时候，先通过代理去远程中央仓库下载依赖包到Nexus 仓库，然后再从Nexus仓库下载到本地。私服我们部署在内网服务器，只要其中一个人从远程中央库下来了，以后相同的依赖包就都是从Nexus私服上进行下载，这样大大加快下载速度，不怕远程中央仓库出现问题。 hosted(宿主类型) 创建布和代理方式创建差不多 Hosted 是宿主机的意思，就是怎么把第三方的 Jar 放到私服上。 Hosted 有三种方式，Releases、SNAPSHOT、Mixed group(仓库组类型) 将其他仓库类型合并一起（maven public就是group类型），如图所示将其他仓库合在一下提供对外使用 仓库属性说明 maven-central：maven中央库，默认从https://repo1.maven.org/maven2/拉取jar maven-releases：私库发行版jar maven-snapshots：私库快照（调试版本）jar maven-public：仓库分组，把上面三个仓库组合在一起对外提供服务，在本地maven基础配置settings.xml中使用。 Nexus jar 包上传与删除上传jar包 如果我们使用的远程maven中心库有jar包无法下载，或者是我们自己编译好的jar包提供给公司其他人，则可以将本地jar包上传到私服仓库 私服jar删除 私服jar出现问题，我们也可以删除私服的jar包重新下载或自行上传 到此，Nexus搭建Maven私服服务已经完成.]]></content>
      <categories>
        <category>Nexus Maven 私服</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>Nexus</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 使用]]></title>
    <url>%2F2019%2F05%2F07%2Fgit-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在日常开发的过程中，对于代码版本的控制已经是是一个习以为常的功能了，接下就记录一下使用Git来作为版本控制的一些常用操作命名，方便自己查看回顾。 git 基本操作 git 提交流程 12345678910111213git init (初始化本地仓库)git add .git commit -m "提交描述"git remote add origin git@github.com:maoqitian/MyPracticeView.git （首先确定ssh key 是否存在，否则会拉取失败）git pull --rebase origin master （合并操作）git push -u origin master (提交到远程仓库) master 分支链接成功之后，拉取分支代码 123git fetch origin wiki 把远程分支拉到本地git checkout -b wiki origin/wiki 在本地创建分支wiki并切换到该分支git pull origin wiki 拉分支 查看用户名 12git config user.namegit config user.email 修改配置用户名 12git config --global user.name "your name"git config --global user.email "your email" 分支切换与合并 参考链接 创建新分支 1git checkout -b dev 切换主分支 （切换分支出现Your local changes to the following files would be overwritten by checkout 解决办法，说白了就是有文件没跟踪到，重新提交一下就可以解决，也可强制切换(不推荐)） 1git checkout master 合并分支 1git merge dev 拉取、提交到远程代码 1234#拉取 git pull origin master# 提交git push origin master .gitignore 文件不起作用 清除对应文件夹的提交记录缓存 1git rm --cached --force -r gxxmt-admin/target/ 清除所有文件夹的缓存记录 1git rm -r --cached . 清除完成之后重复 add 和 commit操作则能使用新的忽略规则 删除GitLab 上的文件，首先克隆代码 123git rm -r --cached targetgit commit -m 'delete'git push -u origin master fork 同步远程代码到本账户仓库12345678910111213141516171819git remote -v(查看链接库情况)git remote add upstream git@172.17.118.127:activity/gxxmt.git（添加远程连接）git fetch upstream （拉取远程更新）git merge upstream/master （合并远程更新到本地，此时只是本地仓库和远程主分支同步，要保持gitlab 仓库和远程同步，还需提交）前两步合并操作 git pull upstream mastergit push origin master//分支获取git checkout wiki（切换分支）git pull upstream wiki （获取wiki分支更新 相当于git fetch 和merge 一起操作）git push origin wiki(提交更新到远程库（自己fork的库）) 获取代码并切换分支 123git clone git@172.31.116.11:maoqitian/gxxmt.gitgit checkout -b wiki origin/wiki 提交代码到github不显示正确的提交记录（github不显示小绿点），查询git 设置的邮箱和github对应的邮箱是否一致1234//查看设置的邮箱git config user.email “username@mail.com”//设置邮箱git config --global user.email “username@mail.com” git tag git tag 打标签(漫长版本迭代中比较重要) 正常提交一个版本流程 1234567git checkout master (切换主分支)git merge dev(开发分支)git add .git commit -m "提交说明"git tag -a v1.8.1 -m '版本说明'git push origin master (远程同步分支)git push --tag 对以前提交记录加入 tag 12345git log --pretty=oneline (显示提交历史)git tag -a v1.2 9fceb02 -m "版本说明" (提交对象的校验和（或前几位字符）) git push origin v1.2 (远程同步 tag )(或者 远程同步所有tags) git push origin --tags 删除 tag 123git tag (查看tag )git tag -d 标签名 (本地删除)git push origin :refs/tags/标签名 (远程标签删除)]]></content>
      <categories>
        <category>development tool</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解完全解析回顾]]></title>
    <url>%2F2019%2F03%2F25%2FJava-annotation%2F</url>
    <content type="text"><![CDATA[关于注解首先引入官方文档的一句话：Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。看完这句话也许你还是一脸懵逼，接下我将从注解的定义、元注解、注解属性、自定义注解、注解解析JDK 提供的注解这几个方面再次了解注解（Annotation） 注解的定义 日常开发中新建Java类，我们使用class、interface比较多，而注解和它们一样，也是一种类的类型，他是用的修饰符为 @interface 注解类的写法 我们新建一个注解MyTestAnnotation 123public @interface MyTestAnnotation &#123;&#125; 接着我们就可以在类或者方法上作用我们刚刚新建的注解 123456@MyTestAnnotationpublic class test &#123; @MyTestAnnotation public static void main(String[] args)&#123; &#125;&#125; 以上我们只是了解了注解的写法，但是我们定义的注解中还没写任何代码，现在这个注解毫无意义，要如何使注解工作呢？接下来我们接着了解元注解。 元注解 元注解顾名思义我们可以理解为注解的注解，它是作用在注解中，方便我们使用注解实现想要的功能。元注解分别有@Retention、 @Target、 @Document、 @Inherited和@Repeatable（JDK1.8加入）五种。@Retention Retention英文意思有保留、保持的意思，它表示注解存在阶段是保留在源码（编译期），字节码（类加载）或者运行期（JVM中运行）。在@Retention注解中使用枚举RetentionPolicy来表示注解保留时期 @Retention(RetentionPolicy.SOURCE)，注解仅存在于源码中，在class字节码文件中不包含 @Retention(RetentionPolicy.CLASS)， 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得 @Retention(RetentionPolicy.RUNTIME)， 注解会在class字节码文件中存在，在运行时可以通过反射获取到 如果我们是自定义注解，则通过前面分析，我们自定义注解如果只存着源码中或者字节码文件中就无法发挥作用，而在运行期间能获取到注解才能实现我们目的，所以自定义注解中肯定是使用 @Retention(RetentionPolicy.RUNTIME)1234@Retention(RetentionPolicy.RUNTIME)public @interface MyTestAnnotation &#123;&#125; @Target Target的英文意思是目标，这也很容易理解，使用@Target元注解表示我们的注解作用的范围就比较具体了，可以是类，方法，方法参数变量等，同样也是通过枚举类ElementType表达作用类型 @Target(ElementType.TYPE) 作用接口、类、枚举、注解 @Target(ElementType.FIELD) 作用属性字段、枚举的常量 @Target(ElementType.METHOD) 作用方法 @Target(ElementType.PARAMETER) 作用方法参数 @Target(ElementType.CONSTRUCTOR) 作用构造函数 @Target(ElementType.LOCAL_VARIABLE)作用局部变量 @Target(ElementType.ANNOTATION_TYPE)作用于注解（@Retention注解中就使用该属性） @Target(ElementType.PACKAGE) 作用于包 @Target(ElementType.TYPE_PARAMETER) 作用于类型泛型，即泛型方法、泛型类、泛型接口 （jdk1.8加入） @Target(ElementType.TYPE_USE) 类型使用.可以用于标注任意类型除了 class （jdk1.8加入） 一般比较常用的是ElementType.TYPE类型12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface MyTestAnnotation &#123;&#125; @Documented Document的英文意思是文档。它的作用是能够将注解中的元素包含到 Javadoc 中去。@Inherited Inherited的英文意思是继承，但是这个继承和我们平时理解的继承大同小异，一个被@Inherited注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。 下面我们来看个@Inherited注解例子 123456789101112131415161718192021222324/**自定义注解*/@Documented@Inherited@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface MyTestAnnotation &#123;&#125;/**父类标注自定义注解*/@MyTestAnnotationpublic class Father &#123;&#125;/**子类*/public class Son extends Father &#123;&#125;/**测试子类获取父类自定义注解*/public class test &#123; public static void main(String[] args)&#123; //获取Son的class对象 Class&lt;Son&gt; sonClass = Son.class; // 获取Son类上的注解MyTestAnnotation可以执行成功 MyTestAnnotation annotation = sonClass.getAnnotation(MyTestAnnotation.class); &#125;&#125; @Repeatable Repeatable的英文意思是可重复的。顾名思义说明被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。 下面我们看一个人玩游戏的例子 12345678910111213141516171819202122/**一个人喜欢玩游戏，他喜欢玩英雄联盟，绝地求生，极品飞车，尘埃4等，则我们需要定义一个人的注解，他属性代表喜欢玩游戏集合，一个游戏注解，游戏属性代表游戏名称*//**玩家注解*/@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface People &#123; Game[] value() ;&#125;/**游戏注解*/@Repeatable(People.class)@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface Game &#123; String value() default "";&#125;/**玩游戏类*/@Game(value = "LOL")@Game(value = "PUBG")@Game(value = "NFS")@Game(value = "Dirt4")public class PlayGame &#123;&#125; 通过上面的例子，你可能会有一个疑问，游戏注解中括号的变量是啥，其实这和游戏注解中定义的属性对应。接下来我们继续学习注解的属性。注解的属性 通过上一小节@Repeatable注解的例子，我们说到注解的属性。注解的属性其实和类中定义的变量有异曲同工之处，只是注解中的变量都是成员变量（属性），并且注解中是没有方法的，只有成员变量，变量名就是使用注解括号中对应的参数名，变量返回值注解括号中对应参数类型。相信这会你应该会对上面的例子有一个更深的认识。而@Repeatable注解中的变量则类型则是对应Annotation（接口）的泛型Class。123456789101112/**注解Repeatable源码*/@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Repeatable &#123; /** * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the * repeatable annotation type. * @return the containing annotation type */ Class&lt;? extends Annotation&gt; value();&#125; 注解的本质 注解的本质就是一个Annotation接口 123456789/**Annotation接口源码*/public interface Annotation &#123; boolean equals(Object obj); int hashCode(); Class&lt;? extends Annotation&gt; annotationType();&#125; 通过以上源码，我们知道注解本身就是Annotation接口的子接口，也就是说注解中其实是可以有属性和方法，但是接口中的属性都是static final的，对于注解来说没什么意义，而我们定义接口的方法就相当于注解的属性，也就对应了前面说的为什么注解只有属性成员变量，其实他就是接口的方法，这就是为什么成员变量会有括号，不同于接口我们可以在注解的括号中给成员变量赋值。注解属性类型 注解属性类型可以有以下列出的类型 1.基本数据类型 2.String 3.枚举类型 4.注解类型 5.Class类型 6.以上类型的一维数组类型注解成员变量赋值 如果注解又多个属性，则可以在注解括号中用“，”号隔开分别给对应的属性赋值，如下例子，注解在父类中赋值属性123456789101112@Documented@Inherited@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface MyTestAnnotation &#123; String name() default "mao"; int age() default 18;&#125;@MyTestAnnotation(name = "father",age = 50)public class Father &#123;&#125; 获取注解属性 前面我们说了很多注解如何定义，放在哪，现在我们可以开始学习注解属性的提取了，这才是使用注解的关键，获取属性的值才是使用注解的目的。 如果获取注解属性，当然是反射啦，主要有三个基本的方法 123456789101112131415/**是否存在对应 Annotation 对象*/ public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123; return GenericDeclaration.super.isAnnotationPresent(annotationClass); &#125; /**获取 Annotation 对象*/ public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123; Objects.requireNonNull(annotationClass); return (A) annotationData().annotations.get(annotationClass); &#125;/**获取所有 Annotation 对象数组*/ public Annotation[] getAnnotations() &#123; return AnnotationParser.toArray(annotationData().annotations); &#125; 下面结合前面的例子，我们来获取一下注解属性，在获取之前我们自定义的注解必须使用元注解@Retention(RetentionPolicy.RUNTIME) 1234567891011121314151617181920212223242526272829303132333435363738public class test &#123; public static void main(String[] args) throws NoSuchMethodException &#123; /** * 获取类注解属性 */ Class&lt;Father&gt; fatherClass = Father.class; boolean annotationPresent = fatherClass.isAnnotationPresent(MyTestAnnotation.class); if(annotationPresent)&#123; MyTestAnnotation annotation = fatherClass.getAnnotation(MyTestAnnotation.class); System.out.println(annotation.name()); System.out.println(annotation.age()); &#125; /** * 获取方法注解属性 */ try &#123; Field age = fatherClass.getDeclaredField("age"); boolean annotationPresent1 = age.isAnnotationPresent(Age.class); if(annotationPresent1)&#123; Age annotation = age.getAnnotation(Age.class); System.out.println(annotation.value()); &#125; Method play = PlayGame.class.getDeclaredMethod("play"); if (play!=null)&#123; People annotation2 = play.getAnnotation(People.class); Game[] value = annotation2.value(); for (Game game : value) &#123; System.out.println(game.value()); &#125; &#125; &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： JDK 提供的注解 注解 作用 注意事项 @Override 它是用来描述当前方法是一个重写的方法，在编译阶段对方法进行检查 jdk1.5中它只能描述继承中的重写，jdk1.6中它可以描述接口实现的重写,也能描述类的继承的重写 @Deprecated 它是用于描述当前方法是一个过时的方法 无 @SuppressWarnings 对程序中的警告去除。 无 注解作用与应用 现在我们再次回头看看开头官方文档的那句描述 Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。 经过我们前面的了解，注解其实是个很方便的东西，它存活的时间，作用的区域都可以由你方便设置，只是你用注解来干嘛的问题 使用注解进行参数配置 下面我们看一个银行转账的例子，假设银行有个转账业务，转账的限额可能会根据汇率的变化而变化，我们可以利用注解灵活配置转账的限额，而不用每次都去修改我们的业务代码。123456789101112131415161718192021222324252627282930313233343536373839/**定义限额注解*/@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface BankTransferMoney &#123; double maxMoney() default 10000;&#125;/**转账处理业务类*/public class BankService &#123; /** * @param money 转账金额 */ @BankTransferMoney(maxMoney = 15000) public static void TransferMoney(double money)&#123; System.out.println(processAnnotationMoney(money)); &#125; private static String processAnnotationMoney(double money) &#123; try &#123; Method transferMoney = BankService.class.getDeclaredMethod("TransferMoney",double.class); boolean annotationPresent = transferMoney.isAnnotationPresent(BankTransferMoney.class); if(annotationPresent)&#123; BankTransferMoney annotation = transferMoney.getAnnotation(BankTransferMoney.class); double l = annotation.maxMoney(); if(money&gt;l)&#123; return "转账金额大于限额，转账失败"; &#125;else &#123; return"转账金额为:"+money+"，转账成功"; &#125; &#125; &#125; catch ( NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return "转账处理失败"; &#125; public static void main(String[] args)&#123; TransferMoney(10000); &#125;&#125; 运行结果： 通过上面的例子，只要汇率变化，我们就改变注解的配置值就可以直接改变当前最大限额。第三方框架的应用 作为一个Android 开发者，平常我们所使用的第三方框架ButterKnife，Retrofit2，Dagger2等都有注解的应用，如果我们要了解这些框架的原理，则注解的基础知识则是必不可少的。注解的作用 提供信息给编译器： 编译器可以利用注解来检测出错误或者警告信息，打印出日志。 编译阶段时的处理： 软件工具可以用来利用注解信息来自动生成代码、文档或者做其它相应的自动处理。 运行时处理： 某些注解可以在程序运行的时候接受代码的提取，自动做相应的操作。 正如官方文档的那句话所说，注解能够提供元数据，转账例子中处理获取注解值的过程是我们开发者直接写的注解提取逻辑，处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool)。上面转账例子中的processAnnotationMoney方法就可以理解为APT工具类。 最后说点到此，对于Java中注解的解析就结束了。最后，也非常感谢您阅读我的文章，文章中如果有错误，请大家给我提出来，大家一起学习进步，如果觉得我的文章给予你帮助，也请给我一个喜欢和关注，同时也欢迎访问我的个人博客。 文中Demo地址]]></content>
      <categories>
        <category>Java基础回顾</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>annotation</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始 hexo 个人博客搭建完全指南]]></title>
    <url>%2F2019%2F03%2F12%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-hexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[个人博客对于我们知识的积累过程中起到温故而知新的作用，并且也能达到展示自我的目的。接下来就大致介绍一下以hexo为基础搭建个人博客的过程。 准备工作 安装 gitlink node.js（直接安装就行） 安装 Hexo 1npm install -g hexo-cli 假设你已经有了自己的github账号建站 选择一个目录初始化hexo 1hexo init 创建 hexo 1npm install 开启hexo本地服务 1hexo s hexo关联github 首先需要有github账号（没有则先注册） 其次创建github仓库，仓库名称为&lt;用户名&gt;.github.io 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可 1npm install hexo-deployer-git --save 修改_config.yml（在站点目录下）。文件末尾修改为（注意冒号之后必须添一个空格） 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:maoqitian/maoqitian.github.io.git branch: master 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 访问我们刚刚搭建好的githubPages博客 绑定域名 域名解析（需要到购买域名的网站设置） 1234567类型选择为 CNAME；主机记录即域名前缀，填写为www；记录值填写为自定义域名；解析线路，TTL 默认即可 绑定域名可能出现https连接不安全，可以获取免费证书，参照链接： Hexo绑定自定义Https域名 美化hexo博客样式安装主题 NexT （官方文档已经写得很详细） https://github.com/iissnan/hexo-theme-next 开启动效背景方式1 主题自带的效果 主题配置文件_config.yml将false改为 true 12# Canvas-nestcanvas_nest: true 方式2 设置不是主题自带的效果 主题中新添加内容 _layout.swig 文件 12345678# 找到themes\next\layout\_layout.swig文件，添加内容：# 在&lt;body&gt;里添加：&lt;div class="bg_content"&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt;&lt;/div&gt;# 仍是该文件，在末尾添加：&lt;script type="text/javascript" src="/js/src/dynamic_bg.js"&gt;&lt;/script&gt; 添加动效背景js代码 dynamic_bg.js 在themes\next\source\js\src中新建文件dynamic_bg.js，js代码详情可见：dynamic_bg.js 修改样式 custom.styl12345678# 在themes\next\source\css\_custom\custom.styl文件末尾添加内容：.bg_content &#123; position: fixed; top: 0; z-index: -1; width: 100%; height: 100%;&#125; 设置圆形头头像 /themes/next/source/css/_common/components/sidebar/sidebar-author.styl 1234567891011121314151617181920212223242526272829.site-author-image &#123;display: block;margin: 0 auto;padding: $site-author-image-padding;max-width: $site-author-image-width;height: $site-author-image-height;border: $site-author-image-border-width solid $site-author-image-border-color;border-radius: 60%;transition: 2.5s all; &#125;.site-author-image:hover &#123;transform: rotate(360deg);&#125; .site-author-name &#123;margin: $site-author-name-margin;text-align: $site-author-name-align;color: $site-author-name-color;font-weight: $site-author-name-weight;&#125;.site-description &#123;margin-top: $site-description-margin-top;text-align: $site-description-align;font-size: $site-description-font-size;color: $site-description-color;&#125; 主题NexT修改网站标志 themes\next\source\images 路径下替换favicon-16x16-next.png themes\next\source\images路径修改头像替换avatar.jpg，并且在主题配置文件中开启头像设置 1avatar: /images/avatar.jpg 修改网页头背景图 themes\next\source\css_common\components\header路径下 1.header &#123;background-image: url(图片地址 或者图片路径images\xxx.jpg);&#125; 修改logo字体、menu背景（字体文件需要自行下载） 在themes/*/source/css/_custom/custom.styl中添加如下代码： 123456789 // Custom styles. @font-face &#123; font-family: Bungasai; src: url('/fonts/Bungasai.ttf'); &#125; .site-title &#123; font-size: 45px !important;font-family: 'Bungasai' !important; &#125; 其中字体文件在 themes/next/source/fonts 目录下，里面有个 .gitkeep 的隐藏文件，打开写入你要保留的字体文件 去掉logo字体背景图 在theme/next/source/css/_common/components/header文件夹下打开site-meta.styl文件，找到.brand{},去掉background: $brand-bg 字段 修改menu样式（\blog\themes\next\source\css_common\components\header\menu.styl文件） 12345678910111213141516171819202122232425262728293031323334353637// Menu// --------------------------------------------------.menu &#123;margin-top: 20px;padding-left: 0;text-align: center;background: rgba(255,255,255,0.55);margin-left: auto;margin-right: auto;width: 470px;border-radius: initial;&#125;.menu .menu-item &#123;display: inline-block;margin: 0 10px;list-style: none; @media screen and (max-width: 767px) &#123; margin-top: 10px; &#125; a &#123; display: block; font-size: 18px; line-height: inherit; border-bottom: 1px solid $menu-link-border; transition-property: border-color; the-transition(); &amp;:hover &#123; border-bottom-color: $menu-link-hover-border; &#125; &#125; .fa &#123; margin-right: 5px; &#125; &#125;.use-motion .menu-item &#123; opacity: 0; &#125; 添加RSS 在博客文件夹下面 blog/ 使用git bash 下载插件 1npm install --save hexo-generator-feed 打开主题配置文件搜索rss并修改为如下 1rss: /atom.xml 重新启动发布博客hexo clean清除缓存后$ hexo g 生成静态文件，在文件夹(public)下看到 atom.xml 文件 设置侧边栏社交小图标 打开主题配置文件搜索social,把#去掉就可以启用，如需新增在图标库找自己喜欢的小图标，并将名字复制按social格式修改即可 123456789social:GitHub: https://github.com/maoqitian || github掘金: https://juejin.im/user/59e956626fb9a045204b57d4 || drupal 简书: https://www.jianshu.com/u/f58cd7ff1a08 || book（图标库图标名称）social_icons:enable: true #是否启用图标icons_only: false #是否启只显示图标不显示文字transition: false 自定义网站底部 打开主题配置文件搜索 footer 并按如下对应项修改 123456789footer:since: 2018 #指定建站时间，如果没有定义，则使用主题创建当年icon: heart #修改底部心型图形powered: false #关闭默认数据驱动支持#关闭主题名称和版本号theme: enable: false version: false 底部添加访客数和总访问量(编辑主题配置文件) 12345678910111213141516busuanzi_count:# count values only if the other configs are falseenable: true# custom uv span for the whole sitesite_uv: true#本站访客数site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 本站访客数site_uv_footer: 人次# custom pv span for the whole sitesite_pv: truesite_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 本站总访问量site_pv_footer: 次# custom pv span for one page onlypage_pv: truepage_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 本文阅读量page_pv_footer: 次 网页加载样式 编辑主题配置文件 1234567891011121314151617181920# 开启网页加载pace: true# 可以设置的加载样式列表:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simple# 设置网页加载样式pace_theme: pace-theme-center-atom 在右上角添加fork me on github 样式地址 样式1 样式2 在上面样式连接中 挑选自己喜欢的样式，并复制代码。然后把刚才复制的代码粘贴到 themes\next\layout_layout.swig 文件中(放在 的下面)，并把href改为你的github地址 1&lt;a href="https://your-url" class="github-corner" aria-label="View source on GitHub"&gt;&lt;svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"&gt;&lt;path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"&gt;&lt;/path&gt;&lt;path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"&gt;&lt;/path&gt;&lt;path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 自定义文章底部版权 打开主题配置文件搜索 post_copyright 并按如下对应项修改： 1234post_copyright:enable: truelicense: CC BY-NC-ND 4.0license_url: https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh 经过上面配置底部版权部分只能出现文章作者，文章链接和版权声明，我们可以修改next\layout_macro\post-copyright.swig 文件，添加文章标题和文章发布日期 123456789101112131415161718192021222324252627282930313233343536373839 &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;ul class="post-copyright"&gt; &lt;li class="post-copyright-title"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.title') + __('symbol.colon') &#125;&#125;&lt;/strong&gt; &#123;&#123; post.title | default(config.title) &#125;&#125; &lt;/li&gt; &lt;li class="post-copyright-author"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.author') + __('symbol.colon') &#125;&#125;&lt;/strong&gt; &#123;&#123; post.author | default(config.author) &#125;&#125; &lt;/li&gt; &lt;li class="post-copyright-created_at"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.created_at') + __('symbol.colon') &#125;&#125;&lt;/strong&gt; &#123;&#123; date(post.date, config.date_format) &#125;&#125; &lt;/li&gt; &lt;li class="post-copyright-link"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.link') + __('symbol.colon') &#125;&#125;&lt;/strong&gt; &lt;a href="&#123;&#123; post.url | default(post.permalink) &#125;&#125;" title="&#123;&#123; post.title &#125;&#125;"&gt;&#123;&#123; post.url | default(post.permalink) &#125;&#125;&lt;/a&gt;&lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="post-copyright-license"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.license_title') + __('symbol.colon') &#125;&#125; &lt;/strong&gt; &#123;&#123; __('post.copyright.license_content', theme.post_copyright.license_url, theme.post_copyright.license) &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制文章链接成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt; 经过如上配置，文章标题和发布日期都显示出来了，但是只能显示英文，中文配置文件没有对应的中文，打开 themes\next\languages\zh-Hans.yml 搜索 copyright： 自定义修改类别名称如下 12345678copyright: title: 本文标题 created_at: 发布时间 author: 本文作者 link: 本文链接 license_title: 版权声明 license_content: '本博客所有文章除特别声明外，均采用 &lt;a href="%s" rel="external nofollow" target="_blank"&gt;%s&lt;/a&gt; 许可协议。转载请注明出处！' 更好的管理文章 根据官方说明，编辑博客配置文件 12345方式一：（不管是方式一还是方式二，都是必须的）：_config.ymlpost_asset_folder: true方式二（下载插件，在bolg文件目录下执行命令）：npm install https://github.com/CodeFalling/hexo-asset-image --save hexo新建文章后的目录结构 123456 _posts├── demo文章| ├── demo1.jpg| ├── demo2.jpg| └── demo3.jpg└── demo文章.md 正确的引用图片方式是使用下列的标签插件 1234方式一：&#123;% asset_img example.jpg This is an example image %&#125;方式二：&lt;img src="/demo文章/demo1.jpg" alt="demo文章"&gt; 新建页面 比如新建标签页 123456789101112131415# 新建页面 tags hexo new page tags# \blog\source\tags目录下 index.md，编辑设置type类型为tagstitle: 标签date: 2018-2-22 23:39:04type: "tags"//编辑主题配置文件，tags 加上刚刚新建页面的相对目录menu:home: / || hometags: /tags/ || tags(图标代码 Font Awesome)categories: /categories/ || tharchives: /archives/ || archiveabout: /about/ || user 显示当前浏览进度 修主题配置文件config.yml，把 false 改为 true 12345# Scroll percent label in b2t button.scrollpercent: true# Enable sidebar on narrow view (only for Muse | Mist).onmobile: true 添加字数统计 下载插件（bolg目录下） 1npm install hexo-wordcount --save 在主题配置文件中找到如下配置，并修改配置如下 123456789101112post_meta: item_text: true created_at: true #发布时间 updated_at: false #更新时间 categories: true #分类post_wordcount: item_text: true wordcount: true #单篇字数统计 min2read: true #单篇阅读时长 totalcount: false #站点字数统计 separated_meta: true 显示样式加上“字”和“分钟”，则打开 themes\next\layout_macro\post.swig 文件分别搜索代码，并把“字”和“分钟”按如下添加到代码后面 1234567&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt;&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 添加浏览统计文章浏览统计 注册LeanCloud账号 创建一个项目，在项目的存储模块新建新建Class用来专门保存我们博客的文章访问量等数据，我们前面对NexT主题的修改兼容，此处的新建Class名字必须为Counter，由于LeanCloud升级了默认的ACL权限，如果你想避免后续因为权限的问题导致次数统计显示不正常，建议在此处选择无限制 获取我们前面新建项目的app_id和app_key，主题配置文件中设置对应信息 1234leancloud_visitors: enable: true app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt; Web安全因为AppID以及AppKey是暴露在外的，因此如果一些别用用心之人知道了之后用于其它目的是得不偿失的，为了确保只用于我们自己的博客，建议开启Web安全选项，这样就只能通过我们自己的域名才有权访问后台的数据了，可以进一步提升安全性。选择应用的设置的安全中心选项卡，加入我们域名保存。 站点浏览统计 不蒜子 显示站点统计 12345678910111213busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true #本站访客数 site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 本站访客数 site_uv_footer: 人次 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 本站总访问量 site_pv_footer: 次 # custom pv span for one page only 如果无法显示字数统计，原因为不蒜子域名过期的问题 解决：进入 hexo 博客项目的 themes 目录下，在 next 主题目录中的 layout/_third-party/analytics/ 下找到 busuanzi-counter.swig 文件把： 1&lt;script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 改为： 1&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 添加搜索功能（基于Next主题） 安装插件searchdb 1npm install hexo-generator-searchdb --save hexo博客配置文件中添加如下配置 12345search: path: search.xml field: post format: html limit: 10000 Next主题配置_config.yml文件中更改如下配置（enable设置为true） 1234567local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 能够显示大图 方法一：文章属性中加入图片链接 12345678910111213141516---title: demo title date: 2019-01-14 15:55:49toc: false #是否显示文章目录categories: - 持续集成（CI） #分类tags: - Jenkins- git- GitLab- CentOS- Maven- Tomcatphotos:- "https://github.com/maoqitian/MaoMdPhoto/raw/master/Jenkins/Jenkins.jpg"--- 方法二：由于markdown是支持原生html的，所以我们可以在正文引用img来为我们的文章设置摘要配图。 1234567891011121314151617//在“&lt;!-- more --&gt;”之前的内容都会展示到摘要中(同时与你主题文件中配置的摘要字数有关).---title: demo title date: 2019-01-14 15:55:49toc: false #是否显示文章目录categories: - 持续集成（CI） #分类tags: - Jenkins- git- GitLab- CentOS- Maven- Tomcat---&lt;img src="https://github.com/maoqitian/MaoMdPhoto/raw/master/Jenkins/Jenkins.jpg" width=50% /&gt;&lt;!--more--&gt; 添加评论 添加来必力评论系统 首先注册来必力账号（163邮箱可以注册） 安装创建（实际就是创建一个网站评论项目，填写你的） 获取livere_uid也就是（也就是代码管理的data-uid） 最后修改主题配置文件字段，填入上一步获取的livere_uid1livere_uid: you uid 修改文章代码显示样式 修改hexo配置文件12345highlight: enable: true line_number: true auto_detect: true tab_replace: 5.22 博客文章分页 hexo博客配置文件中123## 每页显示的文章量 (0 = 关闭分页功能)per_page: 10pagination_dir: page 博客文章阴影效果 修改主题目录下themes/next/source/css/_custom/custom.styl文件添加代码 123456789101112131415161718192021222324252627282930313233343536373839//文章添加阴影效果 1.post&#123; margin-top:60px; .post-block &#123; padding: 35px 30px; background: #fff; box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12); border-radius: initial; &#125; &#125;//文章添加阴影效果 2.post&#123; margin-top:30px; .post-block &#123; margin-bottom: 12px; background: #fff; background-image: initial; background-position-x: initial; background-position-y: initial; background-size: initial; background-repeat-x: initial; background-repeat-y: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: rgb(255, 255, 255); padding: 40px; padding-top: 40px; padding-right: 40px; padding-bottom: 40px; padding-left: 40px; box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12); border-radius: 10px 10px 10px 10px; border-top-left-radius: 10px; border-top-right-radius: 10px; border-bottom-right-radius: 10px; border-bottom-left-radius: 10px; &#125; &#125; 添加站点友情链接 主题配置文件中 1234567# Blog rollslinks_icon: pagelines #模块iconlinks_title: 友情链接 #模块标题links_layout: block #模块layout 样式#links_layout: inlinelinks: 玩Android: http://www.wanandroid.com/ # 链接名称：链接地址 添加文章分享功能 将主题配置_config.yml文件中关于baidushare部分的内容改为（其中type亦可以选择button） 123baidushare: type: slide baidushare: true 集成百度分享你会发现配置文件有一句话表明不支持https 1# Warning: Baidu Share does not support https. 不支持https解决方案 下载新的静态资源 static 下载压缩包到本地，解压后，将static文件夹保存至themes\next\source目录下 修改文件themes\next\layout_partials\share\baidushare.swig12345文件末尾 讲静态资源路径改为我刚刚下载好的静态资源.src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];改为 .src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)]; 页面点击桃心效果 创建clicklove.js文件，并写入如下内容代码 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\themes\next\layout_layout.swig文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/clicklove.js"&gt;&lt;/script&gt; 添加网页在线联系功能（DaoVoice） 首先注册DaoVoice，注册可以使用GitHub账号注册(这里我就是使用Github 关联注册) 注册完成之后还需要创建我们网站对应的DaoVoice项目，邀请码为 2e5d695d 创建成功之后DaoVoice会提示我们快速接入，如下图需要找到对应的app_id，然后需要修改/themes/next/layout/_partials/head.swig文件，并加入如下代码，注意”//widget.daovoice.io/widget/xxxx.js”中的xxxx就对应图中的app_id 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/xxxx.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 最后在主题配置文件中加入如下代码（注意冒号后面的空格），并填入对应的app_id 123# Online contactdaovoice: truedaovoice_app_id: # 这里填你刚才获得的 app_id 其他的一些设置可以自行在daovoice控制台中进行设置，这里就不展开了每篇文章末尾统一添加“本文结束”标记添加“本文结束”标记 在\themes\next\layout_macro下新建 passage-end-tag.swig 文件,并添加以下代码(新建文件格式必须是utf-8)： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-heart"&gt;&lt;/i&gt;感谢阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 打开\themes\next\layout_macro\post.swig文件，在post-body 之后， post-footer （post-footer之前有两个DIV）之前添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 在主题配置文件_config.yml在末尾添加以下字段： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 修改文章底部的的标签样式 打开模板文件/themes/next/layout/_macro/post.swig，找到rel=”tag”&gt;#字段，将# 换成,其中tag是你选择标签图标的名字,也是可以自定义的,如下: 1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 重新发布博客 经过我们各种修改美化后的博客，需要同步到github中，具体步骤为 123456# 在博客目录下hexo cleanhexo g hexo d 新建页面，发布文章 新建页面命令，在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局 1hexo new [layout] &lt;title&gt; layout的类型 布局 路径 布局含义 post source/_posts 文章 page source 页面 draft source/_drafts 草稿 默认三种layout模板的路径 \blog\scaffolds 如果需要删除文章，则到source/_posts目录下删除对应文章重新发布博客即可 博客同步管理 在github中默认博客仓库中新建hexo分支并且将博客仓库的默认分支变成hexo分支(setting中设置) 克隆刚刚的分支到本地电脑（存在blog源文件的目录） 1git clone git@github.com:maoqitian/maoqitian.github.io.git 将blog源文件的目录下所有文件复制到刚刚克隆hexo分支的文件目录username.github.io层级，并下载一下插件 123456789101112131415npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --savenpm install hexo-generator-search --savenpm install hexo-generator-searchdb --save 提交时考虑以下注意事项 将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，否则提交主题文件夹会失败 后期需要更新主题时在另一个地方git clone下来该主题的最新版本，然后将内容拷到当前主题目录即可 然后提交该 hexo 分支 其他电脑需要操作blog 首先你需要在电脑上配置相关环境 安装Node.js、git和hexo 新电脑上克隆username.github.io仓库的hexo分支到本地，此时本地git仓库处于hexo分支 切换到username.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以需要install下） 如果node_modules文件没有丢失, 可不执行该操作 到这里了就可以开始在自己的电脑上写博客了，新建文章，更新文章等 需要注意的是每次更新博客之后, 都要把相关修改上传到hexo分支，每次换电脑更新博客的时候, 在修改之前最好也要git pull拉取一下最新的更新 参考链接 Hexo官方文档 最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 HEXO搭配Next主题修改博客 百度分享集成 Hexo NexT主题添加点击爱心效果 Hexo NexT主题内接入网页在线联系功能]]></content>
      <categories>
        <category>hexo博客搭建</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>hexo</tag>
        <tag>Next主题</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从源码角度深入理解Glide（下）]]></title>
    <url>%2F2019%2F02%2F19%2F%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一篇文章从源码角度深入理解Glide（上）中，我们已经把Glide加载图片的基本流程走了一遍，想必你已经对Glide的加载原理有了新的认识并且见识到了Glide源码的复杂逻辑，在我们感叹Glide源码复杂的同时我们也忽略了Glide加载图片过程的其它细节，特别是缓存方面，我们在上一篇文章中对于缓存的处理都是跳过的，这一篇文章我们就从Glide的缓存开始再次对Glide进行深入理解。 Glide缓存 Glide加载默认情况下可以分为三级缓存，哪三级呢？他们分别是内存、磁盘和网络。 默认情况下，Glide 会在开始一个新的图片请求之前检查以下多级的缓存： 1.活动资源 (Active Resources) - 现在是否有另一个 View 正在展示这张图片 2.内存缓存 (Memory cache) - 该图片是否最近被加载过并仍存在于内存中 3.资源类型（Resource） - 该图片是否之前曾被解码、转换并写入过磁盘缓存 4.数据来源 (Data) - 构建这个图片的资源是否之前曾被写入过文件缓存 网络级别的加载我们已经在上一篇文章了解了，上面列出的前两种情况则是内存缓存，后两种情况则是磁盘缓存，如果以上四种情况都不存在，Glide则会通过返回到原始资源以取回数据（原始文件，Uri, Url（网络）等） 缓存的key 提起缓存，我们首先要明白，Glide中缓存的图片肯定不止一个，当我们加载图片的同时，如果缓存中有我们正在加载的图片，我们怎么找到这个图片的缓存呢？所以为了找到对应的缓存，则每一个缓存都有它对应的标识，这个标识在Glide中用接口Key来描述12345678910/**Key 接口*/public interface Key &#123; String STRING_CHARSET_NAME = "UTF-8"; Charset CHARSET = Charset.forName(STRING_CHARSET_NAME); void updateDiskCacheKey(@NonNull MessageDigest messageDigest); @Override boolean equals(Object o); @Override int hashCode();&#125; 缓存Key的生成 前面提到了缓存Key的接口，那这个缓存的Key实在哪里生成的，实现类又是什么呢？这我们就要看到加载发动机Engine类的load方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private final EngineKeyFactory keyFactory;/**Engine类的load方法*/public &lt;R&gt; LoadStatus load(GlideContext glideContext,Object model, Key signature,int width,int height,Class&lt;?&gt; resourceClass,Class&lt;R&gt; transcodeClass,Priority priority,DiskCacheStrategy diskCacheStrategy,Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,boolean isTransformationRequired,boolean isScaleOnlyOrNoTransform, Options options,boolean isMemoryCacheable,boolean useUnlimitedSourceExecutorPool,boolean useAnimationPool,boolean onlyRetrieveFromCache,ResourceCallback cb) &#123; Util.assertMainThread(); long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0; EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations, resourceClass, transcodeClass, options); //省略部分代码 .......... &#125;/**EngineKey类*/ class EngineKey implements Key &#123; private final Object model; private final int width; private final int height; private final Class&lt;?&gt; resourceClass; private final Class&lt;?&gt; transcodeClass; private final Key signature; private final Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations; private final Options options; private int hashCode; EngineKey( Object model, Key signature, int width, int height, Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations, Class&lt;?&gt; resourceClass, Class&lt;?&gt; transcodeClass, Options options) &#123; this.model = Preconditions.checkNotNull(model); this.signature = Preconditions.checkNotNull(signature, "Signature must not be null"); this.width = width; this.height = height; this.transformations = Preconditions.checkNotNull(transformations); this.resourceClass = Preconditions.checkNotNull(resourceClass, "Resource class must not be null"); this.transcodeClass = Preconditions.checkNotNull(transcodeClass, "Transcode class must not be null"); this.options = Preconditions.checkNotNull(options); &#125; @Override public boolean equals(Object o) &#123; if (o instanceof EngineKey) &#123; EngineKey other = (EngineKey) o; return model.equals(other.model) &amp;&amp; signature.equals(other.signature) &amp;&amp; height == other.height &amp;&amp; width == other.width &amp;&amp; transformations.equals(other.transformations) &amp;&amp; resourceClass.equals(other.resourceClass) &amp;&amp; transcodeClass.equals(other.transcodeClass) &amp;&amp; options.equals(other.options); &#125; return false; &#125; @Override public int hashCode() &#123; if (hashCode == 0) &#123; hashCode = model.hashCode(); hashCode = 31 * hashCode + signature.hashCode(); hashCode = 31 * hashCode + width; hashCode = 31 * hashCode + height; hashCode = 31 * hashCode + transformations.hashCode(); hashCode = 31 * hashCode + resourceClass.hashCode(); hashCode = 31 * hashCode + transcodeClass.hashCode(); hashCode = 31 * hashCode + options.hashCode(); &#125; return hashCode; &#125;&#125; 由以上源码我们知道，通过EngineKeyFactory的buildKey方法Glide创建了缓存的Key实现类EngineKey对象，由生成EngineKey对象传入的参数我们可以明白，只要有一个参数不同，所生成的EngineKey对象都会是不同的。内存的速度是最快的，理所当然如果内存中有缓存的对应加载图片Glide会搜先从内存缓存中加载。 LRU Glide官方文档说明LRU算法思想 从官方文档描述，我们可以知道Glide的缓存底层实现原理算法都是LRU（Least Recently Used），字面意思为最近最少使用。算法核心思想（个人理解）：在一个有限的集合中，存入缓存，每一个缓存都有唯一标识，当要获取一个缓存，集合中没有则存入，有则直接从集合获取，存入缓存到集合时如果集合已经满了则找到集合中最近最少的缓存删除并存入需要存入的缓存。 这样也就有效的避免了内存溢出（OOM）的问题。 接下来我们看一张图能够更好的理解LRU算法 横线上方每个数字代表要存入的数据，横线下方代表三个内存页（也可以理解为缓存结合），缓存集合最多可以存入三个缓存数据，则从1开始依次按照数字代码的缓存读取并存入缓存集合，首先开始时三个页内存是空的，前三个缓存数据不同，依次存入缓存集合，当数字4在内存中并进行缓存时，根据LRU算法思想，则2和3相较于1使用时间间隔更少，所以淘汰1，缓存数据4替换1的位置，接下去同理。 Glide内存缓存使用的是LruCache，磁盘缓存使用的DiskLruCache，他们核心思想都是LRU算法，而缓存集合使用的是LinkedHashMap，熟悉集合框架应该都明白LinkedHashMap集成HashMap，并且LinkedHashMap保证了key的唯一性，更符合LRU算法的实现。 更深入的了解LruCache和DiskLruCache可以查看郭霖大神的解析Android DiskLruCache完全解析，硬盘缓存的最佳方案内存缓存内存缓存相关API1234567//跳过内存缓存RequestOptions requestOptions =new RequestOptions().skipMemoryCache(true);Glide.with(this).load(IMAGE_URL).apply(requestOptions).into(imageView);//Generated API 方式GlideApp.with(this).load(IMAGE_URL).skipMemoryCache(true).into(imageView); //清除内存缓存，必须在主线程中调用Glide.get(context).clearMemory(); 内存缓存源码分析 内存缓存不需要你进行任何设置，它默认就是开启的，我们再次回到Engine类的load方法123456789101112131415/**Engine类的load方法*/public &lt;R&gt; LoadStatus load(GlideContext glideContext,Object model, Key signature,int width,int height,Class&lt;?&gt; resourceClass,Class&lt;R&gt; transcodeClass,Priority priority,DiskCacheStrategy diskCacheStrategy,Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,boolean isTransformationRequired,boolean isScaleOnlyOrNoTransform, Options options,boolean isMemoryCacheable,boolean useUnlimitedSourceExecutorPool,boolean useAnimationPool,boolean onlyRetrieveFromCache,ResourceCallback cb) &#123; //省略部分代码 .......... EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable); if (active != null) &#123; cb.onResourceReady(active, DataSource.MEMORY_CACHE); if (VERBOSE_IS_LOGGABLE) &#123; logWithTimeAndKey("Loaded resource from active resources", startTime, key); &#125; return null; &#125; //省略部分代码 .......... &#125; 活动资源 (Active Resources) 通过以上Engine类load的源码，首先调用loadFromActiveResources方法来从内存中获取缓存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private final ActiveResources activeResources;/**Engine类的loadFromActiveResources方法*/@Nullable private EngineResource&lt;?&gt; loadFromActiveResources(Key key, boolean isMemoryCacheable) &#123; if (!isMemoryCacheable) &#123; return null; &#125; EngineResource&lt;?&gt; active = activeResources.get(key); if (active != null) &#123; active.acquire(); &#125; return active; &#125;/**ActiveResources类*/final class ActiveResources &#123; @VisibleForTesting final Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = new HashMap&lt;&gt;(); //省略部分代码 ........ @VisibleForTesting static final class ResourceWeakReference extends WeakReference&lt;EngineResource&lt;?&gt;&gt; &#123; //省略部分代码 ........ &#125;&#125;/**Engine类的onEngineJobComplete方法*/@SuppressWarnings("unchecked") @Override public void onEngineJobComplete(EngineJob&lt;?&gt; engineJob, Key key, EngineResource&lt;?&gt; resource) &#123; Util.assertMainThread(); // A null resource indicates that the load failed, usually due to an exception. if (resource != null) &#123; resource.setResourceListener(key, this); if (resource.isCacheable()) &#123; activeResources.activate(key, resource); &#125; &#125; jobs.removeIfCurrent(key, engineJob); &#125;/**RequestOptions类的skipMemoryCache方法*/public RequestOptions skipMemoryCache(boolean skip) &#123; if (isAutoCloneEnabled) &#123; return clone().skipMemoryCache(true); &#125; this.isCacheable = !skip; fields |= IS_CACHEABLE; return selfOrThrowIfLocked(); &#125; 通过以上源码， 这里需要分几步来解读，首先如果是第一次加载，肯定没有内存缓存，所以如果第一次加载成功，则在加载成功之后调用了Engine对象的onEngineJobComplete方法，并在该方法中将加载成功的resource通过ActiveResources对象的activate方法保存在其内部维护的弱引用（WeakReference）HashMap中。下次再加载相同的资源，当你设置了skipMemoryCache（true），则表明你不想使用内存缓存，这时候Glide再次加载相同资源的时候则会跳过内存缓存的加载，否则可以从ActiveResources对象中获取，如果内存资源没被回收的话（关于弱引用的一下描述可以看看我以前写的一篇文章Android 学习笔记之图片三级缓存）。如果该弱引用资源被回收了(GC)，则下一步就到内存中寻找是否有该资源的缓存。 内存缓存 (Memory cache) 接着回到Engine类的load方法，如果弱引用缓存资源已经被回收，则调用loadFromCache方法在内存缓存中查找缓存资源 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/**Engine类的load方法*/public &lt;R&gt; LoadStatus load(GlideContext glideContext,Object model, Key signature,int width,int height,Class&lt;?&gt; resourceClass,Class&lt;R&gt; transcodeClass,Priority priority,DiskCacheStrategy diskCacheStrategy,Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,boolean isTransformationRequired,boolean isScaleOnlyOrNoTransform, Options options,boolean isMemoryCacheable,boolean useUnlimitedSourceExecutorPool,boolean useAnimationPool,boolean onlyRetrieveFromCache,ResourceCallback cb) &#123; //省略部分代码 .......... EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable); if (cached != null) &#123; cb.onResourceReady(cached, DataSource.MEMORY_CACHE); if (VERBOSE_IS_LOGGABLE) &#123; logWithTimeAndKey("Loaded resource from cache", startTime, key); &#125; return null; &#125; //省略部分代码 .......... &#125;/**Engine类的loadFromCache方法*/private EngineResource&lt;?&gt; loadFromCache(Key key, boolean isMemoryCacheable) &#123; if (!isMemoryCacheable) &#123; return null; &#125; EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key); if (cached != null) &#123; cached.acquire(); activeResources.activate(key, cached); &#125; return cached; &#125;/**Engine类的getEngineResourceFromCache方法*/private final MemoryCache cache;private EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123; Resource&lt;?&gt; cached = cache.remove(key); final EngineResource&lt;?&gt; result; if (cached == null) &#123; result = null; &#125; else if (cached instanceof EngineResource) &#123; // Save an object allocation if we've cached an EngineResource (the typical case). result = (EngineResource&lt;?&gt;) cached; &#125; else &#123; result = new EngineResource&lt;&gt;(cached, true /*isMemoryCacheable*/, true /*isRecyclable*/); &#125; return result; &#125;/**GlideBuilder类的build方法*/private MemoryCache cache;@NonNull Glide build(@NonNull Context context) &#123; //省略部分代码 .......... if (memoryCache == null) &#123; memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize()); &#125; if (diskCacheFactory == null) &#123; diskCacheFactory = new InternalCacheDiskCacheFactory(context); &#125; if (engine == null) &#123; engine = new Engine( memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, GlideExecutor.newUnlimitedSourceExecutor(), GlideExecutor.newAnimationExecutor(), isActiveResourceRetentionAllowed); &#125; //省略部分代码 ..........&#125; /**LruResourceCache类的实现继承关系*/ public class LruResourceCache extends LruCache&lt;Key, Resource&lt;?&gt;&gt; implements MemoryCache&#123;......&#125; 通过以上源码，在loadFromCache同样也判断了Glide是否设置了skipMemoryCache（true）方法，没有设置则调用getEngineResourceFromCache方法，在该方法中我们可以看到cache对象就是MemoryCache对象，而该对象实际是一个接口，他的实现类是LruResourceCache，该对象我们前面在GlideBuilder的build方法中进行了新建（在第一步with方法中调用了Glide.get方法，在get方法中初始化Glide调用了在GlideBuilder的build方法），这里也就说明Glide的内存缓存还是使用LruCache来实现，这里如果获取到了内存缓存，则获取内容缓存的同时移除该缓存，并在loadFromCache方法中将该资源标记为正在使用同时加入在弱引用中。这样在ListView或者Recyclerview中加载图片则下次加载首先从弱引用Map中获取缓存资源，并且标志当前资源正在使用，可以防止该资源被LRU算法回收掉。 内存缓存写入 前面我们只是分析了如何获取内存缓存，而内存缓存又是在哪里写入的呢？根据前面分析，首先获取在弱引用Map中的缓存资源，而前面我们在分析活动资源(Active Resources)时候已经说过是在onEngineJobComplete放中往弱引用Map存放缓存资源，而onEngineJobComplete方法是在哪里调用呢，这我们就要回想起上一篇文章中我们再网络加载图片成功后腰切换在主线程回调来显示图片，也就是EngineJob对象的handleResultOnMainThread方法 12345678910111213141516171819202122232425262728293031323334353637/**EngineJob类的handleResultOnMainThread方法*/@Synthetic void handleResultOnMainThread() &#123; //省略部分代码 .......... engineResource = engineResourceFactory.build(resource, isCacheable); hasResource = true; //省略部分代码 .......... engineResource.acquire(); listener.onEngineJobComplete(this, key, engineResource); engineResource.release(); //省略部分代码 .......... &#125;/**EngineJob类的EngineResourceFactory内部类*/ @VisibleForTesting static class EngineResourceFactory &#123; public &lt;R&gt; EngineResource&lt;R&gt; build(Resource&lt;R&gt; resource, boolean isMemoryCacheable) &#123; return new EngineResource&lt;&gt;(resource, isMemoryCacheable, /*isRecyclable=*/ true); &#125; &#125;/**Engine类的onEngineJobComplete方法*/@SuppressWarnings("unchecked") @Override public void onEngineJobComplete(EngineJob&lt;?&gt; engineJob, Key key, EngineResource&lt;?&gt; resource) &#123; //省略部分代码 .......... if (resource != null) &#123; resource.setResourceListener(key, this); if (resource.isCacheable()) &#123; activeResources.activate(key, resource); &#125; &#125; //省略部分代码 .......... &#125; 通过以上源码，EngineJob类的handleResultOnMainThread方法首先构建了获取好的包含图片的资源，标记当前资源正在使用，通过listener.onEngineJobComplete回调，而listener就是Engine对象，也就到了Engine类的onEngineJobComplete方法，并在该方法中存入了图片资源到弱引用Map中。 上面我是分析了弱引用资源的缓存存入，接着我们看看内存缓存是在哪里存入的，在次看回handleResultOnMainThread方法，我们看到onEngineJobComplete回调前后分别调用了EngineResource对象的acquire方法和release方法 123456789101112131415161718192021222324252627282930313233/**EngineResource类的acquire方法*/void acquire() &#123; if (isRecycled) &#123; throw new IllegalStateException("Cannot acquire a recycled resource"); &#125; if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123; throw new IllegalThreadStateException("Must call acquire on the main thread"); &#125; ++acquired; &#125;/**EngineResource类的release方法*/ void release() &#123; if (acquired &lt;= 0) &#123; throw new IllegalStateException("Cannot release a recycled or not yet acquired resource"); &#125; if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123; throw new IllegalThreadStateException("Must call release on the main thread"); &#125; if (--acquired == 0) &#123; listener.onResourceReleased(key, this); &#125; &#125;/**Engine类的onResourceReleased方法*/@Override public void onResourceReleased(Key cacheKey, EngineResource&lt;?&gt; resource) &#123; Util.assertMainThread(); activeResources.deactivate(cacheKey); if (resource.isCacheable()) &#123; cache.put(cacheKey, resource); &#125; else &#123; resourceRecycler.recycle(resource); &#125; &#125; 通过以上源码，其实我们应该能恍然大悟，Glide的内存缓存存入其实就是通过一个acquired变量来进行控制，如果当前弱引用资源不再使用，也就是acquired等于零的时候，则调用回调listener.onResourceReleased（listener就是Engine对象），在onResourceReleased方法中移除了弱引用资源资源，并且没有设置skipMemoryCache（true），则通过cache.put存入内存缓存。 总的来说Glide的内存缓存主要是结合了弱引用和内存来实现的。Glide内存缓存机制示意图磁盘缓存 说去磁盘缓存，上一篇文章我们在简单使用Glide的例子中就已经使用了Glide的磁盘缓存 123RequestOptions requestOptions = new RequestOptions() .diskCacheStrategy(DiskCacheStrategy.NONE);//不使用缓存 Glide.with(Context).load(IMAGE_URL).apply(requestOptions).into(mImageView); 既然知道如何使用Glide的磁盘缓存，首先我们要了解Glide4中给我提供了哪几种磁盘缓存策略 磁盘缓存策略 1.DiskCacheStrategy.NONE： 表示不使用磁盘缓存 2.DiskCacheStrategy.DATA： 表示磁盘缓存只缓存原始加载的图片 DiskCacheStrategy.RESOURCE： 表示磁盘缓存只缓存经过解码转换后的图片 DiskCacheStrategy.ALL： 表示磁盘缓存既缓存原始图片，也缓存经过解码转换后的图片 DiskCacheStrategy.AUTOMATIC： 表示让Glide根据图片资源智能地选择使用哪一种磁盘缓存策略，该选项也是我们在不进行手动设置的时候Glide的默认设置磁盘缓存源码分析 不知你是否还记得上一篇文章中在加载图片的时候我们是在开启子线程任务在线程池中进行的，我们来回顾一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/**DecodeJob类的start方法*/public void start(DecodeJob&lt;R&gt; decodeJob) &#123; this.decodeJob = decodeJob; GlideExecutor executor = decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor(); executor.execute(decodeJob); &#125;/**DecodeJob类的willDecodeFromCache方法*/ boolean willDecodeFromCache() &#123; Stage firstStage = getNextStage(Stage.INITIALIZE); return firstStage == Stage.RESOURCE_CACHE || firstStage == Stage.DATA_CACHE; &#125; /**DecodeJob类的getNextStage方法*/ private Stage getNextStage(Stage current) &#123; switch (current) &#123; case INITIALIZE: return diskCacheStrategy.decodeCachedResource() ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE); case RESOURCE_CACHE: return diskCacheStrategy.decodeCachedData() ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE); case DATA_CACHE: return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE; //省略部分代码 ...... &#125; &#125;/**DiskCacheStrategy类的ALL对象*/ public static final DiskCacheStrategy ALL = new DiskCacheStrategy() &#123; @Override public boolean isDataCacheable(DataSource dataSource) &#123; return dataSource == DataSource.REMOTE; &#125; @Override public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy) &#123; return dataSource != DataSource.RESOURCE_DISK_CACHE &amp;&amp; dataSource != DataSource.MEMORY_CACHE; &#125; @Override public boolean decodeCachedResource() &#123; return true; &#125; @Override public boolean decodeCachedData() &#123; return true; &#125; &#125;; /**GlideBuilder类的build方法*/ @NonNull Glide build(@NonNull Context context) &#123; //省略部分代码 ...... if (diskCacheExecutor == null) &#123; diskCacheExecutor = GlideExecutor.newDiskCacheExecutor(); &#125; //省略部分代码 ......&#125;/**GlideExecutor类的newDiskCacheExecutor方法*/ private static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;public static GlideExecutor newDiskCacheExecutor() &#123; return newDiskCacheExecutor( DEFAULT_DISK_CACHE_EXECUTOR_THREADS, DEFAULT_DISK_CACHE_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT); &#125;/**GlideExecutor类的newDiskCacheExecutor方法*/ public static GlideExecutor newDiskCacheExecutor( int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) &#123; return new GlideExecutor( new ThreadPoolExecutor( threadCount /* corePoolSize */, threadCount /* maximumPoolSize */, 0 /* keepAliveTime */, TimeUnit.MILLISECONDS, new PriorityBlockingQueue&lt;Runnable&gt;(), new DefaultThreadFactory(name, uncaughtThrowableStrategy, true))); &#125; 通过以上源码，可以分两个步骤来进行解读： 第一步在DecodeJob对象的start方法开启子线程来加载图片，这里使用了线程池，通过willDecodeFromCache方法和getNextStage放结合，主要通过Stage枚举来判断当前使用的缓存策略，而缓存策略的设置则通过DiskCacheStrategy对象的decodeCachedResource和decodeCachedData方法来进行设置，而这两个方法在DiskCacheStrategy抽象类都是抽象方法，而他们的实现就是我们前面提到的Glide磁盘缓存的五种策略，上面代码中列出其中一种ALL代码，decodeCachedResource和decodeCachedData方法都返回ture，也就说明磁盘缓存既缓存原始图片，也缓存经过解码转换后的图片；如果decodeCachedResource返回false和decodeCachedData方法返回true，也就代表DATA策略，磁盘缓存只缓存原始加载的图片，其他同理 第二步通过前面对设置策略的判断，如果有缓存策略，则拿到的线程池就是磁盘缓存加载的线程池（线程池的理解可以看看我以前写的一篇文章），该线程的初始化还是在GlideExecutor对象的build方法中，通过以上源码，该线程池只有唯一一个核心线程，这就保证所有执行的的任务都在这一个线程中执行，并且是顺序执行，也就不用在考虑线程同步的问题了。 根据前面官网的说明，不管是内存缓存还是磁盘缓存，都是使用LRU，接着看看Glide磁盘缓存在哪获取LRU对象，还是得看到GlideBuilder对象的build方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/**GlideBuilder类的build方法*/ private DiskCache.Factory diskCacheFactory;@NonNull Glide build(@NonNull Context context) &#123; //省略部分代码 .......... if (diskCacheFactory == null) &#123; diskCacheFactory = new InternalCacheDiskCacheFactory(context); &#125; //省略部分代码 ..........&#125;/**InternalCacheDiskCacheFactory类的继承关系*/public final class InternalCacheDiskCacheFactory extends DiskLruCacheFactory &#123; //省略实现代码 .......... &#125;/**DiskLruCacheFactory类的部分代码*/public class DiskLruCacheFactory implements DiskCache.Factory &#123; //省略部分代码 .......... @Override public DiskCache build() &#123; File cacheDir = cacheDirectoryGetter.getCacheDirectory(); //省略部分代码 .......... return DiskLruCacheWrapper.create(cacheDir, diskCacheSize); &#125;&#125;/**DiskLruCacheWrapper类的部分代码*/public class DiskLruCacheWrapper implements DiskCache &#123;//省略部分代码 .......... private synchronized DiskLruCache getDiskCache() throws IOException &#123; if (diskLruCache == null) &#123; diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize); &#125; return diskLruCache; &#125; //省略部分代码 ..........&#125;/**DiskLruCache类的部分代码*/public final class DiskLruCache implements Closeable &#123; //省略部分代码 .......... public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize) throws IOException &#123; DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize); //省略部分代码 .......... return cache; &#125; //省略部分代码 ..........&#125; 通过以上源码，我们在GlideBuilder对象的build方法中已经新建了InternalCacheDiskCacheFactory对象，也就是DiskLruCacheFactory对象，同样该对象已经被我们传入Engine对象的构造方法中，最终包装成LazyDiskCacheProvider对象（该对象代码就不贴出了），所以只要调用DiskLruCacheFactory对象的build方法就能够最终获取到DiskLruCache对象，该对象是Glide自己实现的，但是其原理和谷歌官方推荐的DiskLruCache也差不了太多，核心还是使用LRU算法来实现磁盘缓存。资源类型（Resource） 根据前面分分析，假定没有内存缓存，而是由磁盘缓存，则结合前面分析我们得到了磁盘缓存处理的线程池，也获得枚举Stage是RESOURCE_CACHE或DATA_CACHE，则在DecodeJob对象getNextGenerator方法，我们就能得到对应的Generator 123456789101112131415/**DecodeJob的getNextGenerator方法*/private DataFetcherGenerator getNextGenerator() &#123; switch (stage) &#123; case RESOURCE_CACHE: return new ResourceCacheGenerator(decodeHelper, this); case DATA_CACHE: return new DataCacheGenerator(decodeHelper, this); case SOURCE: return new SourceGenerator(decodeHelper, this); case FINISHED: return null; default: throw new IllegalStateException("Unrecognized stage: " + stage); &#125; &#125; 通过getNextGenerator方法的源码，如果之前设置磁盘缓存策略为DiskCacheStrategy.RESOURCE，则应该对应的就是枚举Stage.RESOURCE_CACHE，也就是说接下来使用的资源Generator是ResourceCacheGenerator，结合上一篇文章，我们分析网络加载流程是这里获取的是SourceGenerator，我们接着来看ResourceCacheGenerator的startNext()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** ResourceCacheGenerator类的startNext方法*/ @SuppressWarnings("PMD.CollapsibleIfStatements") @Override public boolean startNext() &#123; //省略部分代码 .......... currentKey = new ResourceCacheKey(// NOPMD AvoidInstantiatingObjectsInLoops helper.getArrayPool(), sourceId, helper.getSignature(), helper.getWidth(), helper.getHeight(), transformation, resourceClass, helper.getOptions()); cacheFile = helper.getDiskCache().get(currentKey); if (cacheFile != null) &#123; sourceKey = sourceId; modelLoaders = helper.getModelLoaders(cacheFile); modelLoaderIndex = 0; &#125; &#125; loadData = null; boolean started = false; while (!started &amp;&amp; hasNextModelLoader()) &#123; ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++); loadData = modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions()); if (loadData != null &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123; started = true; loadData.fetcher.loadData(helper.getPriority(), this); &#125; &#125; return started; &#125;/**DecodeHelper类的getDiskCache方法*/ DiskCache getDiskCache() &#123; return diskCacheProvider.getDiskCache(); &#125;/** LazyDiskCacheProvider类的getDiskCache方法 */@Override public DiskCache getDiskCache() &#123; if (diskCache == null) &#123; synchronized (this) &#123; if (diskCache == null) &#123; diskCache = factory.build(); &#125; if (diskCache == null) &#123; diskCache = new DiskCacheAdapter(); &#125; &#125; &#125; return diskCache; &#125; 通过以上源码其实已经很清晰，首先还是获取缓存的唯一key，然后helper.getDiskCache().get(currentKey)这一句话就是获取缓存，helper对象就是DecodeHelper，它的getDiskCache方法获取的对象也就是前面提到的包含DiskLruCacheFactory对象的LazyDiskCacheProvider对象，而LazyDiskCacheProvider对象的getDiskCache方法调用了factory.build()，factory对象DiskLruCacheFactory，也就是获取了我们前面所说的DiskLruCache对象。 接着继续看数据返回走的流程还是通过回调通cb.onDataFetcherReady将获取的缓存资源传递到DecodeJob，由DecodeJob继续执行剩余图片显示步骤，大致流程和网络加载差不多，这里就不进行讨论了123456/** ResourceCacheGenerator类的startNext方法*/ @Override public void onDataReady(Object data) &#123; cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE, currentKey); &#125; 数据来源 (Data) 同理资源类型（Resource），则设置磁盘缓存策略为DiskCacheStrategy.DATA，则应该对应的就是枚举Stage.DATA_CACHE，使用的资源Generator是DataCacheGenerator，所以直接看看DataCacheGenerator的startNext()方法，该方法源码如下，同样是根据key通过DiskLruCache对象来获取磁盘缓存（DATA），数据返回走的流程还是通过回调通cb.onDataFetcherReady将获取的缓存资源传递到DecodeJob，由DecodeJob继续执行剩余图片显示123456789101112131415161718192021222324252627282930313233/** DataCacheGenerator类的startNext方法*/ @Override public boolean startNext() &#123; //省略部分代码 .......... Key originalKey = new DataCacheKey(sourceId, helper.getSignature()); cacheFile = helper.getDiskCache().get(originalKey); if (cacheFile != null) &#123; this.sourceKey = sourceId; modelLoaders = helper.getModelLoaders(cacheFile); modelLoaderIndex = 0; &#125; &#125; loadData = null; boolean started = false; while (!started &amp;&amp; hasNextModelLoader()) &#123; ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++); loadData = modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions()); if (loadData != null &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123; started = true; loadData.fetcher.loadData(helper.getPriority(), this); &#125; &#125; return started; &#125;/** DataCacheGenerator类的onDataReady方法*/ @Override public void onDataReady(Object data) &#123; cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.DATA_DISK_CACHE, sourceKey); &#125; 磁盘缓存数据存入 前面我们只是了解了磁盘缓存的获取，磁盘缓存又是在哪里存入的，接着往下看。 根据上一篇文章的分析，加载图片会走到DecodeJob对象的decodeFromRetrievedData方法 123456789101112131415161718192021222324252627282930313233/** DecodeJob类的decodeFromRetrievedData方法*/ private void decodeFromRetrievedData() &#123; //省略部分代码 .......... notifyEncodeAndRelease(resource, currentDataSource); //省略部分代码 ..........&#125; /** DecodeJob类的notifyEncodeAndRelease方法*/ private final DeferredEncodeManager&lt;?&gt; deferredEncodeManager = new DeferredEncodeManager&lt;&gt;();private void notifyEncodeAndRelease(Resource&lt;R&gt; resource, DataSource dataSource) &#123;//省略部分代码 .......... stage = Stage.ENCODE; try &#123; if (deferredEncodeManager.hasResourceToEncode()) &#123; deferredEncodeManager.encode(diskCacheProvider, options); &#125; &#125; //省略部分代码 .......... &#125;/** DeferredEncodeManager类的encode方法**/void encode(DiskCacheProvider diskCacheProvider, Options options) &#123; GlideTrace.beginSection("DecodeJob.encode"); try &#123; diskCacheProvider.getDiskCache().put(key, new DataCacheWriter&lt;&gt;(encoder, toEncode, options)); &#125; finally &#123; toEncode.unlock(); GlideTrace.endSection(); &#125; &#125; 通过以上源码可以看到DecodeJob对象的decodeFromRetrievedData方法通过调用notifyEncodeAndRelease方法，在该方法中调用了内部类DeferredEncodeManager的encode方法存入了磁盘缓存，这里存入的是转换后的磁盘缓存（Resource）。 原始数据也就是SourceGenerator第一次网络下载成功之后获取的图片数据，之后再做磁盘缓存，所以再次回到看到SourceGenerator的onDataReady方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/**SourceGenerator类的onDataReady方法**/ private Object dataToCache;@Override public void onDataReady(Object data) &#123; DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy(); if (data != null &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123; dataToCache = data; cb.reschedule(); &#125; else &#123; cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher, loadData.fetcher.getDataSource(), originalKey); &#125; &#125; /**SourceGenerator类的startNext方法**/@Override public boolean startNext() &#123; if (dataToCache != null) &#123; Object data = dataToCache; dataToCache = null; cacheData(data); &#125; if (sourceCacheGenerator != null &amp;&amp; sourceCacheGenerator.startNext()) &#123; return true; &#125; //省略部分代码 .......... &#125;/**SourceGenerator类的cacheData方法**/ private void cacheData(Object dataToCache) &#123; long startTime = LogTime.getLogTime(); try &#123; Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache); DataCacheWriter&lt;Object&gt; writer = new DataCacheWriter&lt;&gt;(encoder, dataToCache, helper.getOptions()); originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature()); helper.getDiskCache().put(originalKey, writer); &#125; //省略部分代码 .......... sourceCacheGenerator = new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this); &#125;/**DecodeJob类的reschedule方法**/ @Override public void reschedule() &#123; runReason = RunReason.SWITCH_TO_SOURCE_SERVICE; callback.reschedule(this); &#125;/**Engine类的reschedule方法**/ @Override public void reschedule(DecodeJob&lt;?&gt; job) &#123; getActiveSourceExecutor().execute(job); &#125; 通过以上源码，其实逻辑已经很清晰，会让你有“柳暗花明又一村”的感觉，onDataReady网络请求成功并且设置了缓存策略，则将图片资源赋值给Object类型的dataToCache，执行回调cb.reschedule，cb就是DecodeJob对象，所以接着执行了DecodeJob对象的reschedule方法，该方法再次执行回调也就是执行了Engine对象的reschedule方法，该方法再次执行DecodeJob，也就会再次触发SourceGenerator类的startNext方法，该方法首先判断了Object类型的dataToCache是否有值，前面分析该对象已经赋值，所以就进入到SourceGenerator对象的cacheData方法存入了我们的原始下载图片的缓存。 仅从缓存加载图片 前面我基本把Glide的缓存模块梳理了一遍，但是还差个东西，那就是如果我只想Glide加载缓存呢？这种需求还是有的，比如说我们在有些应用看到的省流量模式，不就是正好对应这个需求，没关系Gldie也已经为我们考虑到了，那就是onlyRetrieveFromCache(true)，只要设置了这个，图片在内存缓存或在磁盘缓存中就会被加载出来，而没有缓存，则这一次加载失败。 我们看看如何使用 1234567RequestOptions requestOptions = new RequestOptions().onlyRetrieveFromCache(true);Glide.with(this).load(IMAGE_URL).apply(requestOptions).into(mImageView);//Generated API 方式 GlideApp.with(this) .load(url) .diskCacheStrategy(DiskCacheStrategy.ALL) .into(mImageView); 使用起来还是很方便的，只要设置onlyRetrieveFromCache(true)方法就行，而它的原理也其实也很简单，我们再次回到DecodeJob对象的getNextStage方法，如果前面获取了缓存，则相应得到对应的Generator加载图片，如果获取不到缓存，则枚举Stage.FINISHED，DecodeJob对象的getNextGenerator方法则会返回null。(如下代码所示) 1234567891011121314151617181920212223/**DecodeJob类的getNextStage方法**/ private Stage getNextStage(Stage current) &#123; switch (current) &#123; //省略部分代码 .......... case DATA_CACHE: return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE; case SOURCE: case FINISHED: return Stage.FINISHED; &#125; &#125;/**DecodeJob类的getNextGenerator方法**/ private DataFetcherGenerator getNextGenerator() &#123; switch (stage) &#123; //省略部分代码 .......... case FINISHED: return null; default: throw new IllegalStateException("Unrecognized stage: " + stage); &#125; &#125; Glide磁盘缓存机制示意图 Glide缓存小结 通过前面对Glide缓存的分析，让我再次认识到Glide的强大，使用时只是简单的几个方法设置或者不设置，Glide都能够在背后依靠其复杂的逻辑为我们快速的加载出图片并显示，缓存还有一些细节比如可以自定义key等，这里就不进行展开了，有兴趣的可以自行研究。 Glide 回调与监听图片加载成功回调原理 由上一篇文章分析，我们来回顾一下图片加载成功之后的逻辑。数据加载成功之后切换主线程最终调用SingleRequest类的onResourceReady方法，在该方法中加载成功的数据通过target.onResourceReady方法将数据加载出来，target就是DrawableImageViewTarget对象，他继续了实现了Target接口的基类ImageViewTarget，所以调用它实现的onResourceReady方法或者父类实现的onResourceReady方法就实现了加载成功数据的回调，并由DrawableImageViewTarget对象显示加载成功的图片，这就是数据加载成功回调原理。 12345678910111213141516171819202122232425262728293031323334353637383940414243/**SingleRequest类的onResourceReady方法**/ @Nullable private List&lt;RequestListener&lt;R&gt;&gt; requestListeners;private void onResourceReady(Resource&lt;R&gt; resource, R result, DataSource dataSource) &#123; //省略部分代码 .......... isCallingCallbacks = true; try &#123; boolean anyListenerHandledUpdatingTarget = false; //省略部分代码 .......... if (!anyListenerHandledUpdatingTarget) &#123; Transition&lt;? super R&gt; animation = animationFactory.build(dataSource, isFirstResource); target.onResourceReady(result, animation); &#125; &#125; //省略部分代码 .......... &#125;/**Target 接口**/ public interface Target&lt;R&gt; extends LifecycleListener &#123;&#125;/**ImageViewTarget类的onResourceReady方法**/ @Override public void onResourceReady(@NonNull Z resource, @Nullable Transition&lt;? super Z&gt; transition) &#123; if (transition == null || !transition.transition(resource, this)) &#123; setResourceInternal(resource); &#125; else &#123; maybeUpdateAnimatable(resource); &#125; &#125;/**ImageViewTarget类的setResourceInternal方法**/ private void setResourceInternal(@Nullable Z resource) &#123; setResource(resource); maybeUpdateAnimatable(resource); &#125;DrawableImageViewTarget/**DrawableImageViewTarget类的setResource方法**/ @Override protected void setResource(@Nullable Drawable resource) &#123; view.setImageDrawable(resource); &#125; Glide监听（listener） 再次看看Glide监听（listener）的例子 1234567891011Glide.with(this).load(IMAGE_URL).listener(new RequestListener&lt;Drawable&gt;() &#123; @Override public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123; return false; &#125; @Override public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123; return false; &#125; &#125;).into(mImageView); Glide监听的实现同样还是基于我们上面分析的SingleRequest对象的onResourceReady方法，使用的时候调用RequestBuilder对象的listener方法，传入的RequestListener对象加入到requestListeners，这样在SingleRequest对象的onResourceReady方法中遍历requestListeners，来回调listener.onResourceReady方法，布尔类型的anyListenerHandledUpdatingTarget则接收回调listener.onResourceReady方法的返回值，如果返回true，则不会执会往下执行，则接着的into方法就不会被触发，说明我们自己在监听中处理，返回false则不拦截。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/**RequestBuilder类的listener方法**/ @Nullable private List&lt;RequestListener&lt;TranscodeType&gt;&gt; requestListeners; public RequestBuilder&lt;TranscodeType&gt; listener( @Nullable RequestListener&lt;TranscodeType&gt; requestListener) &#123; this.requestListeners = null; return addListener(requestListener); &#125;/**RequestBuilder类的addListener方法**/ public RequestBuilder&lt;TranscodeType&gt; addListener( @Nullable RequestListener&lt;TranscodeType&gt; requestListener) &#123; if (requestListener != null) &#123; if (this.requestListeners == null) &#123; this.requestListeners = new ArrayList&lt;&gt;(); &#125; this.requestListeners.add(requestListener); &#125; return this; &#125;/**SingleRequest类的onResourceReady方法**/ @Nullable private List&lt;RequestListener&lt;R&gt;&gt; requestListeners;private void onResourceReady(Resource&lt;R&gt; resource, R result, DataSource dataSource) &#123; //省略部分代码 .......... isCallingCallbacks = true; try &#123; boolean anyListenerHandledUpdatingTarget = false; if (requestListeners != null) &#123; for (RequestListener&lt;R&gt; listener : requestListeners) &#123; anyListenerHandledUpdatingTarget |= listener.onResourceReady(result, model, target, dataSource, isFirstResource); &#125; &#125; anyListenerHandledUpdatingTarget |= targetListener != null &amp;&amp; targetListener.onResourceReady(result, model, target, dataSource, isFirstResource); if (!anyListenerHandledUpdatingTarget) &#123; Transition&lt;? super R&gt; animation = animationFactory.build(dataSource, isFirstResource); target.onResourceReady(result, animation); &#125; &#125; //省略部分代码 .......... &#125; Target（目标） Target在Glide中相当于中间人的作用，在图片的展示起到承上启下的功效，首先看看Target接口的继承关系图 通过该图，我们可以把Target分为三类，一种是简单的Target，一种是加载到特定View的Target(ViewTarget)，还有一种是FutureTarget，可以知道异步执行的结果，得到缓存文件 上一篇文章分析into方法时我们是分析into(ImageView)这个方法开始的，它内部还是会得到特定的Target对象，也就是我们一直说的DrawableImageViewTarget，而他是属于ViewTarget的子类简单的Target（SimpleTarget） SimpleTarget其实是在给我们更灵活的加载到各种各样对象准备的，只要指定我们加载获取的是什么对象asBitmap()，就能使用SimpleTarge或者集成它的我们自定义的对象，在其中通过获取的Bitmap显示在对应的控件上，比如上一篇文章例子提到的NotifivationTarget，就是加载到指定的Notifivation中，灵活加载。12345678//注意需要指定Glide的加载类型asBitmap，不指定Target不知道本身是是类型的TargetGlide.with(this).asBitmap().load(IMAGE_URL).into(new SimpleTarget&lt;Bitmap&gt;() &#123; @Override public void onResourceReady(@NonNull Bitmap resource, @Nullable Transition&lt;? super Bitmap&gt; transition) &#123; //加载完成已经在主线程 mImageView.setImageBitmap(resource); &#125; &#125;); 特定View的Target(ViewTarget) 由DrawableImageViewTarget和BitmapImageViewTarget我们就可以知道这是为了不同类型的图片资源准备的Target，但是还有一种需求，就是如果我们传入是要加载图片资源的View，但是该View不被Glide支持，目前into方法支持传入ImageView，没关系，ViewTarget可以帮上忙，比如我们需要加载到RelativeLayout123456789101112131415161718192021222324252627282930/** * @author maoqitian * @Description: 自定义RelativeLayout * @date 2019/2/18 0018 19:51 */public class MyView extends RelativeLayout &#123; private ViewTarget&lt;MyView, Drawable&gt; viewTarget; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); viewTarget =new ViewTarget&lt;MyView, Drawable&gt;(this) &#123; @Override public void onResourceReady(@NonNull Drawable resource, @Nullable Transition&lt;? super Drawable&gt; transition) &#123; setBackground(resource); &#125; &#125;; &#125; public ViewTarget&lt;MyView, Drawable&gt; getViewTarget() &#123; return viewTarget; &#125;&#125;//使用Glide加载MyView rl_view = findViewById(R.id.rl_view);Glide.with(this).load(IMAGE_URL).into(rl_view.getViewTarget()); FutureTarget FutureTarget的一大用处就是可以得到缓存文件 123456789101112131415161718192021new Thread(new Runnable() &#123; @Override public void run() &#123; FutureTarget&lt;File&gt; target = null; RequestManager requestManager = Glide.with(MainActivity.this); try &#123; target = requestManager .downloadOnly() .load(IMAGE_URL) .submit(); final File downloadedFile = target.get(); Log.i(TAG,"缓存文件路径"+downloadedFile.getAbsolutePath()); &#125; catch (ExecutionException | InterruptedException e) &#123; &#125; finally &#123; if (target != null) &#123; target.cancel(true); // mayInterruptIfRunning &#125; &#125; &#125; &#125;).start(); preload（预加载） 如何使用 1Glide.with(this).load(IMAGE_URL).preload(); 预加载其实也是属于Target的范围，只是他加载的对象为空而已，也就是没有加载目标 1234567891011121314151617181920212223242526272829303132333435363738/**RequestBuilder类的preload方法**/ @NonNull public Target&lt;TranscodeType&gt; preload() &#123; return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL); &#125;/**RequestBuilder类的preload方法**/ @NonNull public Target&lt;TranscodeType&gt; preload(int width, int height) &#123; final PreloadTarget&lt;TranscodeType&gt; target = PreloadTarget.obtain(requestManager, width, height); return into(target); &#125;/**RequestBuilder类的onResourceReady方法**/ public final class PreloadTarget&lt;Z&gt; extends SimpleTarget&lt;Z&gt; &#123;private static final Handler HANDLER = new Handler(Looper.getMainLooper(), new Callback() &#123; @Override public boolean handleMessage(Message message) &#123; if (message.what == MESSAGE_CLEAR) &#123; ((PreloadTarget&lt;?&gt;) message.obj).clear(); return true; &#125; return false; &#125; &#125;);//省略部分代码 ..........public static &lt;Z&gt; PreloadTarget&lt;Z&gt; obtain(RequestManager requestManager, int width, int height) &#123; return new PreloadTarget&lt;&gt;(requestManager, width, height); &#125; @Override public void onResourceReady(@NonNull Z resource, @Nullable Transition&lt;? super Z&gt; transition) &#123; HANDLER.obtainMessage(MESSAGE_CLEAR, this).sendToTarget(); &#125; //省略部分代码 ..........&#125; 通过以上源码，逻辑已经非常清晰，Glide的preload方法里使用的继承SimpleTarget的PreloadTarget对象来作为Target，在它的onResourceReady方法中并没有任何的加载操作，只是调用了Handler来释放资源，到这里也许你会有疑惑，不是说预加载么，怎么不加载。哈哈，其实到onResourceReady方法被调用经过前面的分析Glide已经走完缓存的所有逻辑，那就很容易理解了，预加载只是把图片加载到缓存当中，没有进行其他操作，自然是预加载，并且加载完成之后释放了资源。 Generated API Generated API说白了就是Glide使用注解处理器生成一个API（GlideApp），该API可以代替Glide帮助我们完成图片加载。 Generated API 目前仅可以在 Application 模块内使用，使用Generated API一方面在Application 模块中可将常用的选项组打包成一个选项在 Generated API 中使用，另一方面可以为Generated API 扩展自定义选项（扩展我们自定义的功能方法）。 在上一篇文章中例子中我们可以看到使用Generated API之后使用Glide的方式基本上和Glide3的用法一样流式API使用，先来回顾一下如何使用Generated API 1234567//在app下的gradle添加Glide注解处理器的依赖dependencies &#123; annotationProcessor 'com.github.bumptech.glide:compiler:4.8.0'&#125;//新建一个类集成AppGlideModule并添加上@GlideModule注解，重新rebuild项目就可以使用GlideApp了@GlideModulepublic final class MyAppGlideModule extends AppGlideModule &#123;&#125; 经过上的代码的操作，通过Glide注解处理器已经给我们生成了GlideApp类 123456789101112131415161718192021222324252627282930313233/**GlideApp类部分代码**/ public final class GlideApp &#123; //省略部分代码 .......... @NonNull public static GlideRequests with(@NonNull Context context) &#123; return (GlideRequests) Glide.with(context); &#125; //省略部分代码 ..........&#125;/**GlideApp类部分代码**/ public class GlideRequest&lt;TranscodeType&gt; extends RequestBuilder&lt;TranscodeType&gt; implements Cloneable &#123;//省略部分代码 .......... @NonNull @CheckResult public GlideRequest&lt;TranscodeType&gt; placeholder(@Nullable Drawable drawable) &#123; if (getMutableOptions() instanceof GlideOptions) &#123; this.requestOptions = ((GlideOptions) getMutableOptions()).placeholder(drawable); &#125; else &#123; this.requestOptions = new GlideOptions().apply(this.requestOptions).placeholder(drawable); &#125; return this; &#125; //省略部分代码 ..........&#125;/**RequestBuilder类的getMutableOptions方法**/ protected RequestOptions getMutableOptions() &#123; return defaultRequestOptions == this.requestOptions ? this.requestOptions.clone() : this.requestOptions; &#125; 通过以上源码，可以发现，GlideApp对象的with方法返回的是GlideRequests对象，GlideRequests对象继承的是RequestBuilder，这时应该又是豁然开朗的感觉，GlideApp能够适应流式API，其实就是对RequestBuilder包装了一层，GlideRequests对象通过其父类RequestBuilder对象的getMutableOptions方法获取到requestOptions，然后在相应的方法中操作requestOptions以达到可以使用流式API的功能。GlideExtension GlideExtension字面意思就是Glide扩展，它是一个作用于类上的注解，任何扩展 Glide API 的类都必须使用这个注解来标记，否则其中被注解的方法就会被忽略。被 @GlideExtension 注解的类应以工具类的思维编写。这种类应该有一个私有的、空的构造方法，应为 final 类型，并且仅包含静态方法。@GlideOption GlideOption注解是用来扩展RequestOptions，扩展功能方法第一个参数必须是RequestOptions。下面我们通过设置一个扩展默认设置占位符和错误符方法的例子来说明GlideOption注解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @author maoqitian * @Description: GlideApp 功能扩展类 * @date 2019/2/19 0019 12:51 */@GlideExtensionpublic class MyGlideExtension &#123; private MyGlideExtension() &#123; &#125; //可以为方法任意添加参数，但要保证第一个参数为 RequestOptions /** * 设置通用的加载占位图和错误加载图 * @param options */ @GlideOption public static void normalPlaceholder(RequestOptions options) &#123; options.placeholder(R.drawable.ic_cloud_download_black_24dp).error(R.drawable.ic_error_black_24dp); &#125;&#125;/**GlideOptions类中生成对应的方法**//** * @see MyGlideExtension#normalPlaceholder(RequestOptions) */ @CheckResult @NonNull public GlideOptions normalPlaceholder() &#123; if (isAutoCloneEnabled()) &#123; return clone().normalPlaceholder(); &#125; MyGlideExtension.normalPlaceholder(this); return this; &#125;/**GlideRequest类中生成对应的方法**/ /** * @see GlideOptions#normalPlaceholder() */ @CheckResult @NonNull public GlideRequest&lt;TranscodeType&gt; normalPlaceholder() &#123; if (getMutableOptions() instanceof GlideOptions) &#123; this.requestOptions = ((GlideOptions) getMutableOptions()).normalPlaceholder(); &#125; else &#123; this.requestOptions = new GlideOptions().apply(this.requestOptions).normalPlaceholder(); &#125; return this; &#125; 如上代码所示，我们可以通过@GlideExtension注解设置自己功能扩展类，使用@GlideOption注解标注对赢扩展功能静态方法，重构项目后Glide注解处理器则会自动在GlideOptions对象和GlideRequest对象中生成相应的方法能够被我们调用 1234//调用我们刚刚设置的扩展功能方法GlideApp.with(this).load(IMAGE_URL) .normalPlaceholder() .into(mImageView); GlideType GlideType注解是用于扩展RequestManager的，同理扩展的方法第一个参数必须是RequestManager，并设置类型为加载资源类型，该注解主要作用就是扩展Glide支持加载资源的类型，以下举出官方文档支持gif的一个例子，还是在我们刚刚扩展功能类中。 12345678910111213141516171819202122232425@GlideExtensionpublic class MyGlideExtension &#123; private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock(); @GlideType(GifDrawable.class) public static void asMyGif(RequestBuilder&lt;GifDrawable&gt; requestBuilder) &#123; requestBuilder .transition(new DrawableTransitionOptions()) .apply(DECODE_TYPE_GIF); &#125;&#125;/**GlideRequests类中生成的asMyGif方法**//** * @see MyGlideExtension#asMyGif(RequestBuilder) */ @NonNull @CheckResult public GlideRequest&lt;GifDrawable&gt; asMyGif() &#123; GlideRequest&lt;GifDrawable&gt; requestBuilder = this.as(GifDrawable.class); MyGlideExtension.asMyGif(requestBuilder); return requestBuilder; &#125; 同理在我们加载Gif资源的时候可以直接使用 12GlideApp.with(this).asMyGif().load(IMAGE_URL) .into(mImageView); 源码阅读方法思路 看了这么多源码，其实我想说说框架源码阅读的方法思路： 1.首先自己能把框架大体的流程走一遍，然后根据自己刚刚的思路把文章写出来，在写文章的同时也能发现自己刚刚的思路是否有问题，慢慢纠正 2.文章写完，把整体流程图画出来，画图的过程一个是复习思路，还可以让自己对源码逻辑更加清晰 3.阅读框架源码时看到英文注释可以先理解其含义，在你看源码没头绪的时候往往思路就在注释中，如果对源码中一个类很迷惑，可以直接看该类的头部注释往往注明了该类的作用。 最后说点 到此，真的很想大叫一声宣泄一下，Glide源码就像一座山，一座高峰，你必须沉住气，慢慢的解读，要不然稍不留神就会掉入代码的海洋，迷失方向。回头看看，你不得不感叹正式由于Glide源码中成千上万行的代码，才造就了这样一个强大的框架。最后，也非常感谢您阅读我的文章，文章中如果有错误，请大家给我提出来，大家一起学习进步，如果觉得我的文章给予你帮助，也请给我一个喜欢和关注，同时也欢迎访问我的个人博客。 参考链接 Gldie文档]]></content>
      <categories>
        <category>Android热门框架解析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
        <tag>Glide</tag>
        <tag>图片加载</tag>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从源码角度深入理解Glide（上）]]></title>
    <url>%2F2019%2F02%2F19%2F%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[谈到Glide，从英文字面意思有滑行、滑动的意思；而Android从开发的角度我们知道它是一款图片加载框架，这里引用官方文档的一句话“Glide是一个快速高效的Android图片加载库，注重于平滑的滚动”，从官方文档介绍我们了解到用Glide框架来加载图片是快速并且高效的，接下来就来通过简单使用Glide和源码理解两个方面看看Glide是否是快速和高效（文中代码基于Glide 4.8版本）。 Glide简单使用 1.使用前需要添加依赖 123implementation 'com.github.bumptech.glide:glide:4.8.0'//使用Generated API需要引入 annotationProcessor 'com.github.bumptech.glide:compiler:4.8.0' 2.简单加载网络图片到ImageView，可以看到简单一句代码就能将网络图片加载到ImageView，也可以使用Generated API方式 12345678910//直接使用Glide.with(Context).load(IMAGE_URL).into(mImageView)//使用Generated API， 作用范围Application 模块内使用//创建MyAppGlideModule类加上@GlideModule注解，make project 就能使用 GlideApp@GlideModulepublic final class MyAppGlideModule extends AppGlideModule &#123;&#125;//Generated API加载图片GlideApp.with(Context).load(IMAGE_URL).into(mImageView); 3.当加载网络图片的时候，网络请求是耗时操作，所以图片不可能马上就加载出来，网络请求这段时间ImageView是空白的，所以我们可以使用一个占位符显示图片来优化用户体验，占位符有三种 加载占位符（placeholder） 错误占位符（error） 后备回调符（Fallback） 12345678910111213141516171819//添加占位图 RequestOptions requestOptions = new RequestOptions() .placeholder(R.drawable.ic_cloud_download_black_24dp) .error(R.drawable.ic_error_black_24dp) .diskCacheStrategy(DiskCacheStrategy.NONE);//不使用缓存 Glide.with(Context).load(IMAGE_URL).apply(requestOptions).into(mImageView);//Generated API 方式(和Glide3 一样)GlideApp.with(Context).load(IMAGE_URL) .placeholder(R.drawable.ic_cloud_download_black_24dp) .error(R.drawable.ic_error_black_24dp) .diskCacheStrategy(DiskCacheStrategy.NONE) .into(mImageView); // 后备回调符(Fallback) Generated API 方式才有，在应用设置用户头像场景中，如果用户不设置，也就是为null的情况，可以使用后备回调符显示默认头像private static final String NULL_URL=null;GlideApp.with(Context).load(NULL_URL) .fallback(R.drawable.ic_account_circle_black_24dp) .into(mImageView); 4.指定加载图片的大小（override） 1234567RequestOptions requestOptions = new RequestOptions().override(200,100);Glide.with(Context).load(IMAGE_URL).apply(requestOptions).into(mImageView);//Generated API 方式GlideApp.with(Context).load(IMAGE_URL) .override(200,100) .into(mImageView); 5.缩略图 (Thumbnail) 这个其实和占位符（placeholder）有些相似，但是占位符只能加载本地资源，而缩略图可以加载网络资源，thumbnail方法与我们的主动加载并行运行，如果主动加载已经完成，则缩略图不会显示 12345678910111213141516//缩略图OptionsRequestOptions requestOptions = new RequestOptions() .override(200,100) .diskCacheStrategy(DiskCacheStrategy.NONE); Glide.with(Context) .load(IMAGE_URL) .thumbnail( Glide.with(this) .load(IMAGE_URL) .apply(requestOptions)) .into(mImageView);//Generated API 方式 GlideApp.with(Context). load(IMAGE_URL). thumbnail( GlideApp.with(this) .load(IMAGE_URL).override(200,100) .diskCacheStrategy(DiskCacheStrategy.NONE)).into(mImageView); 6.图像变化 Glide中内置了三种图片的变化操作，分别是CenterCrop（图片原图的中心区域进行裁剪显示），FitCenter（图片原始长宽铺满）和CircleCrop（圆形裁剪） 123456789101112131415161718192021//显示圆形裁剪到ImageViewRequestOptions requestOptions = new RequestOptions() .circleCrop() .diskCacheStrategy(DiskCacheStrategy.NONE);Glide.with(Context) .load(IMAGE_URL) .apply(requestOptions) .into(mImageView); //RequestOptions都内置了使用者三种变化的静态方法Glide.with(Context) .load(IMAGE_URL) .apply(RequestOptions.circleCropTransform()) .into(mImageView); //Generated API 方式GlideApp.with(Context).load(IMAGE_URL) .circleCrop() .diskCacheStrategy(DiskCacheStrategy.NONE) .into(mImageView); 如果想要更酷炫的变化，可以使用第三方框架glide-transformations来帮助我们实现，并且变化是可以组合的 12345678910111213141516171819//第三方框架glide-transformations引入implementation 'jp.wasabeef:glide-transformations:4.0.0'//使用glide-transformations框架 变换图片颜色和加入模糊效果 RequestOptions requestOptions=new RequestOptions() .placeholder(R.drawable.ic_cloud_download_black_24dp) .transforms(new ColorFilterTransformation(Color.argb(80, 255, 0, 0)),new BlurTransformation(30)) .diskCacheStrategy(DiskCacheStrategy.NONE); Glide.with(Context).load(IMAGE_URL). apply(requestOptions). into(mImageView); //Generated API 方式 GlideApp.with(Context).load(IMAGE_URL) .transforms(new ColorFilterTransformation(Color.argb(80, 255, 0, 0)),new BlurTransformation(30)) .placeholder(R.drawable.ic_cloud_download_black_24dp) .diskCacheStrategy(DiskCacheStrategy.NONE) .into(mImageView); 更多效果可以查看官方例子 7.加载目标（Target） Target是介于请求和请求者之间的中介者的角色，into方法的返回值就是target对象，之前我们一直使用的 into(ImageView) ，它其实是一个辅助方法，它接受一个 ImageView 参数并为其请求的资源类型包装了一个合适的 ImageViewTarget 12345678910//加载Target&lt;Drawable&gt; target = Glide.with(Context).load(url).into(new Target&lt;Drawable&gt;() &#123; ...&#125;);//清除加载Glide.with(Context).clear(target); 当我们使用Notification显示应用通知，如果想要自定义通知的界面，我们需要用到RemoteView，如果要给RemoteView设置ImageView，根据提供的setImageViewBitmap方法，如果通知界面需要加载网络图片，则需要将网络图片转换成bitmap，一般我们可以根据获取图片链接的流来转换成bitmap，或者使用本文的主题使用Glide框架，这些都是耗时操作，感觉操作起来很麻烦，而Glide框架很贴心的给我提供了NotificationTarget(继承SimpleTarget)，相对于我们加载目标变成Notification 123456789101112131415161718192021/** * 新建 NotificationTarget 对象参数说明，与Glide3不同，Glide4的asBitmap()方法必须在load方法前面 * @param context 上下文对象 * @param viewId 需要加载ImageView的view的 id * @param remoteViews RemoteView对象 * @param notification Notification对象 * @param notificationId Notification Id */String iamgeUrl = "http://p1.music.126.net/fX0HfPMAHJ2L_UeJWsL7ig==/18853325881511874.jpg?param=130y130"; NotificationTarget notificationTarget = new NotificationTarget(mContext,R.id.notification_Image_play,mRemoteViews,mNotification,notifyId);Glide.with(mContext.getApplicationContext()) .asBitmap() .load(iamgeUrl) .into( notificationTarget ); //Generated API 方式 GlideApp.with(mContext.getApplicationContext()) .asBitmap() .load(iamgeUrl) .into( notificationTarget ); 8.回调监听 使用Glide加载图片，虽然在加载中或者加失败都有占位符方法处理，但是我们还是希望可以知道图片到底是加载成功还是失败，Glide也给我们提供了监听方法来知道图片到底是加载成功还是失败，结合listener和into方法来使用回调 1234567891011121314151617181920212223242526272829Glide.with(this).load(IMAGE_URL). listener(new RequestListener&lt;Drawable&gt;() &#123; @Override public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123; Toast.makeText(getApplicationContext(),"图片加载失败",Toast.LENGTH_SHORT).show(); return false; &#125; @Override public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123; Toast.makeText(getApplicationContext(),"图片加载成功",Toast.LENGTH_SHORT).show(); return false; &#125; &#125;).into(mImageView);*/ //Generated API 方式 GlideApp.with(this).load(IMAGE_URL) .listener(new RequestListener&lt;Drawable&gt;() &#123; @Override public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123; Toast.makeText(getApplicationContext(),"图片加载失败",Toast.LENGTH_SHORT).show(); return false; &#125; @Override public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123; Toast.makeText(getApplicationContext(),"图片加载成功",Toast.LENGTH_SHORT).show(); return false; &#125; &#125;).into(mImageView); 可以看到监听实现的方法都有布尔类型的返回值，返回true，则代表处理了该回调事件，false则不进行处理，如果onResourceReady方法返回true，则into方法就不会执行，也就是图片不会加载到ImageView，同理onLoadFailed方法返回true，则error方法不会执行。 Glide还有其他的一些使用方法，这里就不继续展开了，有兴趣的可以自行继续研究。 Glide源码解析Glide加载图片到ImageView基本流程图 Glide加载图片到ImageView源码分析 在上一节简单的列出了一些Glide的使用方法，能用不代表你已经懂了，接下来就通过理解源码的方式来对Glide是如何工作的做深一层次理解，首先从最简单使用开始 1Glide.with(Context).load(IMAGE_URL).into(mImageView); with方法 来吧，开始是Glide的with()方法，直接上源码 1234567891011121314151617181920212223242526272829303132/** Glide类的with()方法*/@NonNull public static RequestManager with(@NonNull Context context) &#123; return getRetriever(context).get(context); &#125; @NonNull public static RequestManager with(@NonNull Activity activity) &#123; return getRetriever(activity).get(activity); &#125; @NonNull public static RequestManager with(@NonNull FragmentActivity activity) &#123; return getRetriever(activity).get(activity); &#125; @NonNull public static RequestManager with(@NonNull Fragment fragment) &#123; return getRetriever(fragment.getActivity()).get(fragment); &#125; @SuppressWarnings("deprecation") @Deprecated @NonNull public static RequestManager with(@NonNull android.app.Fragment fragment) &#123; return getRetriever(fragment.getActivity()).get(fragment); &#125; @NonNull public static RequestManager with(@NonNull View view) &#123; return getRetriever(view.getContext()).get(view); &#125; 通过源码，可以看到with有不同参数类型的重载方法，每个方法首先都是调用 getRetriever()方法 1234567891011/** Glide类的getRetriever()方法*/private static RequestManagerRetriever getRetriever(@Nullable Context context) &#123; // Context could be null for other reasons (ie the user passes in null), but in practice it will // only occur due to errors with the Fragment lifecycle. Preconditions.checkNotNull( context, "You cannot start a load on a not yet attached View or a Fragment where getActivity() " + "returns null (which usually occurs when getActivity() is called before the Fragment " + "is attached or after the Fragment is destroyed)."); return Glide.get(context).getRequestManagerRetriever(); &#125; Glide的get方法中通过new GlideBuilder()获取了Glide对象，并通过Glide的getRequestManagerRetriever()的方法最终得到RequestManagerRetriever对象，接下来我们看看RequestManagerRetriever对象的get方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** RequestManagerRetriever类的get()方法*/ @NonNull public RequestManager get(@NonNull Context context) &#123; if (context == null) &#123; throw new IllegalArgumentException("You cannot start a load on a null Context"); &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123; if (context instanceof FragmentActivity) &#123; return get((FragmentActivity) context); &#125; else if (context instanceof Activity) &#123; return get((Activity) context); &#125; else if (context instanceof ContextWrapper) &#123; return get(((ContextWrapper) context).getBaseContext()); &#125; &#125; return getApplicationManager(context); &#125; @NonNull public RequestManager get(@NonNull FragmentActivity activity) &#123; if (Util.isOnBackgroundThread()) &#123; return get(activity.getApplicationContext()); &#125; else &#123; assertNotDestroyed(activity); FragmentManager fm = activity.getSupportFragmentManager(); return supportFragmentGet( activity, fm, /*parentHint=*/ null, isActivityVisible(activity)); &#125; &#125; @NonNull public RequestManager get(@NonNull Fragment fragment) &#123; Preconditions.checkNotNull(fragment.getActivity(), "You cannot start a load on a fragment before it is attached or after it is destroyed"); if (Util.isOnBackgroundThread()) &#123; return get(fragment.getActivity().getApplicationContext()); &#125; else &#123; FragmentManager fm = fragment.getChildFragmentManager(); return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible()); &#125; &#125; @SuppressWarnings("deprecation") @NonNull public RequestManager get(@NonNull Activity activity) &#123; if (Util.isOnBackgroundThread()) &#123; return get(activity.getApplicationContext()); &#125; else &#123; assertNotDestroyed(activity); android.app.FragmentManager fm = activity.getFragmentManager(); return fragmentGet( activity, fm, /*parentHint=*/ null, isActivityVisible(activity)); &#125; &#125; @SuppressWarnings("deprecation") @NonNull public RequestManager get(@NonNull View view) &#123; if (Util.isOnBackgroundThread()) &#123; return get(view.getContext().getApplicationContext()); &#125; Preconditions.checkNotNull(view); Preconditions.checkNotNull(view.getContext(), "Unable to obtain a request manager for a view without a Context"); Activity activity = findActivity(view.getContext()); // The view might be somewhere else, like a service. if (activity == null) &#123; return get(view.getContext().getApplicationContext()); &#125; // Support Fragments. // Although the user might have non-support Fragments attached to FragmentActivity, searching // for non-support Fragments is so expensive pre O and that should be rare enough that we // prefer to just fall back to the Activity directly. if (activity instanceof FragmentActivity) &#123; Fragment fragment = findSupportFragment(view, (FragmentActivity) activity); return fragment != null ? get(fragment) : get(activity); &#125; // Standard Fragments. android.app.Fragment fragment = findFragment(view, activity); if (fragment == null) &#123; return get(activity); &#125; return get(fragment); &#125; 同样，RequestManagerRetriever对象的get方法也有不同类型参数的重载，分别针对Application、Activity、Fragmenet、view做了不同的处理，先看Context参数的get方法，在该方法中它把Context的参数分成了两个类型，一个Application类型的Context，另一个是非Application类型的Context。如果是Application类型的Context，则创建的Glide的生命周期则跟随ApplicationContext的生命周期，也就是下面的getApplicationManager所做的事情。 12345678910111213141516171819202122232425/** RequestManagerRetriever类的getApplicationManager()方法*/ @NonNull private RequestManager getApplicationManager(@NonNull Context context) &#123; // Either an application context or we're on a background thread. if (applicationManager == null) &#123; synchronized (this) &#123; if (applicationManager == null) &#123; // Normally pause/resume is taken care of by the fragment we add to the fragment or // activity. However, in this case since the manager attached to the application will not // receive lifecycle events, we must force the manager to start resumed using // ApplicationLifecycle. // TODO(b/27524013): Factor out this Glide.get() call. Glide glide = Glide.get(context.getApplicationContext()); applicationManager = factory.build( glide, new ApplicationLifecycle(), new EmptyRequestManagerTreeNode(), context.getApplicationContext()); &#125; &#125; &#125; return applicationManager; &#125; 接着，如果是非Application类型的，Activity、Fragmenet属于非Application；如果是Activity类型的Context，当前不再主线程，则继续跟随Application生命周期，否则给当前Activity添加一个隐藏的Fragment，然后Glide生命周期跟随这个隐藏的Fragment，分析到这里，我们再看Fragmenet类型的Context，或者是View类型，也是添加了一个隐藏的Fragment。这是为什么呢？首先Fragment的生命周期是和Activity同步的，Activity销毁Fragment也会销毁，其次，这也方便Glide知道自己什么时候需要停止加载，如果我们打开一个Activity并关闭它，如果Glide生命周期跟随Application，则Activity虽然已经销毁，但是应用还没退出，则Glide还在继续加载图片，这显然是不合理的，而Glide很巧妙的用一个隐藏Fragment来解决生命周期的监听。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** RequestManagerRetriever类的fragmentGet()方法*/ @SuppressWarnings(&#123;"deprecation", "DeprecatedIsStillUsed"&#125;) @Deprecated @NonNull private RequestManager fragmentGet(@NonNull Context context, @NonNull android.app.FragmentManager fm, @Nullable android.app.Fragment parentHint, boolean isParentVisible) &#123; RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; // TODO(b/27524013): Factor out this Glide.get() call. Glide glide = Glide.get(context); requestManager = factory.build( glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context); current.setRequestManager(requestManager); &#125; return requestManager; &#125; /** RequestManagerRetriever类的getRequestManagerFragment()方法*/ @SuppressWarnings("deprecation") @NonNull private RequestManagerFragment getRequestManagerFragment( @NonNull final android.app.FragmentManager fm, @Nullable android.app.Fragment parentHint, boolean isParentVisible) &#123; RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG); if (current == null) &#123; current = pendingRequestManagerFragments.get(fm); if (current == null) &#123; current = new RequestManagerFragment(); current.setParentFragmentHint(parentHint); if (isParentVisible) &#123; current.getGlideLifecycle().onStart(); &#125; pendingRequestManagerFragments.put(fm, current); fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss(); handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget(); &#125; &#125; return current; &#125; 经过对into方法的分析，最终获取的是跟随对应Context对象生命周期的RequestManager对象。 load方法 经过上一小节的分析，Glide.with方法最终获取的是RequestManager对象，所以继续看RequestManager对象里面load方法， 1234567891011121314151617181920212223242526272829303132333435/** RequestManager 类的as()方法*/ @NonNull @CheckResult public &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; as( @NonNull Class&lt;ResourceType&gt; resourceClass) &#123; return new RequestBuilder&lt;&gt;(glide, this, resourceClass, context); &#125;/** RequestManager 类的as()方法*/ @NonNull @CheckResult public RequestBuilder&lt;Drawable&gt; asDrawable() &#123; return as(Drawable.class); &#125;/** RequestManager 类的部分load()方法*/ @NonNull @CheckResult @Override public RequestBuilder&lt;Drawable&gt; load(@Nullable Bitmap bitmap) &#123; return asDrawable().load(bitmap); &#125; @NonNull @CheckResult @Override public RequestBuilder&lt;Drawable&gt; load(@Nullable Drawable drawable) &#123; return asDrawable().load(drawable); &#125; @NonNull @CheckResult @Override public RequestBuilder&lt;Drawable&gt; load(@Nullable String string) &#123; return asDrawable().load(string); &#125; //省略其他参数类型 load() 方法 ....... 通过以上load方法，可以发现虽然RequestManager对象的load方法有多个类型参数的重载，但是不管load方法传递什么类型参数，该方法都是调用RequestBuilder对象的load方法 123456789101112131415/** RequestBuilder 类的load()方法*/ @NonNull @CheckResult @SuppressWarnings("unchecked") @Override public RequestBuilder&lt;TranscodeType&gt; load(@Nullable Object model) &#123; return loadGeneric(model); &#125;/** RequestBuilder对象 类的loadGeneric()方法*/ @NonNull private RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) &#123; this.model = model; isModelSet = true; return this; &#125; 通过以上RequestBuilder对象的load()方法，我们可以明白不管RequestManager对象的load方法方法传递什么类型的加载资源参数，RequestBuilder对象都把它看成时Object对象，并在loadGeneric方法中赋值给RequestBuilder对象的model对象。 通过查看RequestBuilder对象，我们还注意到apply(RequestOptions)这个方法，前面我们的例子中使用缓存，加载图像大小，设置加载占位符和错误占位符都需要新建RequestOptions对象，并设置我们的配置，现在我们分析的加载并没有apply一个RequestOptions对象，则Glide会使用requestOptions.clone()去加载默认配置，这里就先不进行展开了，先继续关注接下来的into方法。 123456789101112131415/** RequestBuilder 类的apply方法*/ @NonNull @CheckResult public RequestBuilder&lt;TranscodeType&gt; apply(@NonNull RequestOptions requestOptions) &#123; Preconditions.checkNotNull(requestOptions); this.requestOptions = getMutableOptions().apply(requestOptions); return this; &#125; @SuppressWarnings("ReferenceEquality") @NonNull protected RequestOptions getMutableOptions() &#123; return defaultRequestOptions == this.requestOptions ? this.requestOptions.clone() : this.requestOptions; &#125; 经过以上对with()方法和load方法的分析，经过这两步之后得到了RequestBuilder对象，也就说明真正的图片加载操作是在into方法来完成，也就是RequestBuilder对象的into方法。into方法 通过上一小节的分析，经过load方法之后获取的对象是RequestBuilder，并且我们将load方法的参数赋值给了RequestBuilder对象的model参数，接下来就到了Glide最核心的方法，也就是RequestBuilder对象的into方法 获取DrawableImageViewTarget123456789101112131415161718192021222324252627282930313233343536373839/** RequestBuilder 类的into方法*/@NonNull public ViewTarget&lt;ImageView, TranscodeType&gt; into(@NonNull ImageView view) &#123; Util.assertMainThread(); Preconditions.checkNotNull(view); RequestOptions requestOptions = this.requestOptions; if (!requestOptions.isTransformationSet() &amp;&amp; requestOptions.isTransformationAllowed() &amp;&amp; view.getScaleType() != null) &#123; // Clone in this method so that if we use this RequestBuilder to load into a View and then // into a different target, we don't retain the transformation applied based on the previous // View's scale type. switch (view.getScaleType()) &#123; case CENTER_CROP: requestOptions = requestOptions.clone().optionalCenterCrop(); break; case CENTER_INSIDE: requestOptions = requestOptions.clone().optionalCenterInside(); break; case FIT_CENTER: case FIT_START: case FIT_END: requestOptions = requestOptions.clone().optionalFitCenter(); break; case FIT_XY: requestOptions = requestOptions.clone().optionalCenterInside(); break; case CENTER: case MATRIX: default: // Do nothing. &#125; &#125; return into( glideContext.buildImageViewTarget(view, transcodeClass), /*targetListener=*/ null, requestOptions); &#125; RequestBuilder 对象的into方法中首先获取传递进来的ImageView的ScaleType，让Glide加载出来的ImageView保持一样的ScaleType变化，然后我们看到最后一句话，该方法返回了RequestBuilder 对象的另一个into方法，先看glideContext.buildImageViewTarget()做了什么操作 123456789101112131415161718192021/** GlideContext 类的 buildImageViewTarget方法*/ @NonNull public &lt;X&gt; ViewTarget&lt;ImageView, X&gt; buildImageViewTarget( @NonNull ImageView imageView, @NonNull Class&lt;X&gt; transcodeClass) &#123; return imageViewTargetFactory.buildTarget(imageView, transcodeClass); &#125; public class ImageViewTargetFactory &#123; @NonNull @SuppressWarnings("unchecked") public &lt;Z&gt; ViewTarget&lt;ImageView, Z&gt; buildTarget(@NonNull ImageView view, @NonNull Class&lt;Z&gt; clazz) &#123; if (Bitmap.class.equals(clazz)) &#123; return (ViewTarget&lt;ImageView, Z&gt;) new BitmapImageViewTarget(view); &#125; else if (Drawable.class.isAssignableFrom(clazz)) &#123; return (ViewTarget&lt;ImageView, Z&gt;) new DrawableImageViewTarget(view); &#125; else &#123; //省略代码 ..... &#125; &#125;&#125; 通过以上源码，之前我们看RequestBuilder源码中as方法传入的是Drawable.class，所以以上的buildImageViewTarget方法最终返回的是DrawableImageViewTarget对象，接着我们继续看第一步into方法返回into方法中做了什么操作 构建Request12345678910111213141516171819/** RequestBuilder 类的into方法返回的into方法*/ private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into( @NonNull Y target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, @NonNull RequestOptions options) &#123; Util.assertMainThread(); Preconditions.checkNotNull(target); if (!isModelSet) &#123; throw new IllegalArgumentException("You must call #load() before calling #into()"); &#125; options = options.autoClone(); Request request = buildRequest(target, targetListener, options); //省略部分代码 ...... requestManager.clear(target); target.setRequest(request); requestManager.track(target, request); return target; &#125; 通过以上源码，我们应该先明白Request类是一个接口，他抽象了Glide加载图片请求(Request类源码这里就不贴了)，它是一个非常重要的类，这里我们先看看buildRequest(target, targetListener, options)方法是如何创建Request对象的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 private Request buildRequest( Target&lt;TranscodeType&gt; target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, RequestOptions requestOptions) &#123; return buildRequestRecursive( target, targetListener, /*parentCoordinator=*/ null, transitionOptions, requestOptions.getPriority(), requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight(), requestOptions); &#125;private Request buildRequestRecursive( Target&lt;TranscodeType&gt; target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, @Nullable RequestCoordinator parentCoordinator, TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions, Priority priority, int overrideWidth, int overrideHeight, RequestOptions requestOptions) &#123; //省略部分代码 error Request build ..... Request mainRequest = buildThumbnailRequestRecursive( target, targetListener, parentCoordinator, transitionOptions, priority, overrideWidth, overrideHeight, requestOptions); if (errorRequestCoordinator == null) &#123; return mainRequest; &#125; //省略部分代码 error Request build ..... &#125; private Request buildThumbnailRequestRecursive( Target&lt;TranscodeType&gt; target, RequestListener&lt;TranscodeType&gt; targetListener, @Nullable RequestCoordinator parentCoordinator, TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions, Priority priority, int overrideWidth, int overrideHeight, RequestOptions requestOptions) &#123; if (thumbnailBuilder != null) &#123; //省略部分代码 缩略图操作 ..... &#125; else &#123; // Base case: no thumbnail. return obtainRequest( target, targetListener, requestOptions, parentCoordinator, transitionOptions, priority, overrideWidth, overrideHeight); &#125; &#125; private Request obtainRequest( Target&lt;TranscodeType&gt; target, RequestListener&lt;TranscodeType&gt; targetListener, RequestOptions requestOptions, RequestCoordinator requestCoordinator, TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions, Priority priority, int overrideWidth, int overrideHeight) &#123; return SingleRequest.obtain( context, glideContext, model, transcodeClass, requestOptions, overrideWidth, overrideHeight, priority, target, targetListener, requestListeners, requestCoordinator, glideContext.getEngine(), transitionOptions.getTransitionFactory()); &#125; 通过上面的源码，我们可以看到buildRequest方法调用了buildRequestRecursive方法，在buildRequestRecursive方法中大部分代码都在处理缩略图（thumbnail），我们主流程中没有设置缩略图，这里就不进行展开分析，接着buildRequestRecursive方法又调用了obtainRequest方法，obtainRequest方法传递了非常多参数，比如有我们熟悉的RequestOptions，设置图片尺寸的 overrideWidth， overrideHeight，还有第一步into方法中的target对象，也就是DrawableImageViewTarget对象，model也就是我们load传入的图片地址，也就说明不管load方法还是apply方法传入的参数最终都给到了这里传入SingleRequest.obtain方法，我们继续看看SingleRequest类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final class SingleRequest&lt;R&gt; implements Request, SizeReadyCallback, ResourceCallback, FactoryPools.Poolable &#123;//省略部分代码....../**SingleRequest类的 obtain方法*/ public static &lt;R&gt; SingleRequest&lt;R&gt; obtain( Context context, GlideContext glideContext, Object model, Class&lt;R&gt; transcodeClass, RequestOptions requestOptions, int overrideWidth, int overrideHeight, Priority priority, Target&lt;R&gt; target, RequestListener&lt;R&gt; targetListener, @Nullable List&lt;RequestListener&lt;R&gt;&gt; requestListeners, RequestCoordinator requestCoordinator, Engine engine, TransitionFactory&lt;? super R&gt; animationFactory) &#123; @SuppressWarnings("unchecked") SingleRequest&lt;R&gt; request = (SingleRequest&lt;R&gt;) POOL.acquire(); if (request == null) &#123; request = new SingleRequest&lt;&gt;(); &#125; request.init( context, glideContext, model, transcodeClass, requestOptions, overrideWidth, overrideHeight, priority, target, targetListener, requestListeners, requestCoordinator, engine, animationFactory); return request; &#125; //省略部分代码 ......&#125; 通过SingleRequest对象的obtain方法，我们可以看到request = new SingleRequest&lt;&gt;()；也就是最终我们构建的Request是SingleRequest对象，并在init方法中将上一步obtainRequest方法传递进来的各种参数进行赋值。 Request执行 构建完成Request对象，接下来继续看刚刚的into方法下面的操作 1234requestManager.clear(target);target.setRequest(request);requestManager.track(target, request);return target 首先RequestManager对象清除target，此时不懂你是否还记得RequestManager，该对象是第一步with方法之后得到的，接着是将我们上一步得到的SingleRequest对象设置给target，接着又执行了RequestManager.track方法，继续跟进该方法看看 12345678910111213141516171819/** RequestManager 类的track方法*/void track(@NonNull Target&lt;?&gt; target, @NonNull Request request) &#123; targetTracker.track(target); requestTracker.runRequest(request); &#125;/** RequestTracker 类的runRequest方法*/ private final List&lt;Request&gt; pendingRequests = new ArrayList&lt;&gt;(); public void runRequest(@NonNull Request request) &#123; requests.add(request); if (!isPaused) &#123; request.begin(); &#125; else &#123; request.clear(); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, "Paused, delaying request"); &#125; pendingRequests.add(request); &#125; &#125; 通过上面的源码，RequestManager对象的track方法中执行了RequestTracker 类的runRequest方法，该方法中简单判断当前Glide是否在暂停状态，不是暂停状态则执行Request的begin方法，否则将这个Request加入到请求队列ListpendingRequests中.后备回调符、加载占位符和错误占位符加载 接下来我们看看Request的begin方法到底干了啥，要找到begin方法实现，根据前面分析，我们则应该去看SingleRequest对象的begin方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** SingleRequest 类的begin方法*/ @Override public void begin() &#123; assertNotCallingCallbacks(); stateVerifier.throwIfRecycled(); startTime = LogTime.getLogTime(); if (model == null) &#123; if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123; width = overrideWidth; height = overrideHeight; &#125; int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG; onLoadFailed(new GlideException("Received null model"), logLevel); return; &#125; if (status == Status.RUNNING) &#123; throw new IllegalArgumentException("Cannot restart a running request"); &#125; if (status == Status.COMPLETE) &#123; onResourceReady(resource, DataSource.MEMORY_CACHE); return; &#125; status = Status.WAITING_FOR_SIZE; if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123; onSizeReady(overrideWidth, overrideHeight); &#125; else &#123; target.getSize(this); &#125; if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE) &amp;&amp; canNotifyStatusChanged()) &#123; target.onLoadStarted(getPlaceholderDrawable()); &#125; if (IS_VERBOSE_LOGGABLE) &#123; logV("finished run method in " + LogTime.getElapsedMillis(startTime)); &#125; &#125; private void onLoadFailed(GlideException e, int maxLogLevel) &#123; //省略部分代码 ....... if (!anyListenerHandledUpdatingTarget) &#123; setErrorPlaceholder(); &#125; //省略部分代码 ....... &#125; 通过以上begin方法源码，如果model为空，也就是我们load传入的图片地址为空，则会调用onLoadFailed方法，而onLoadFailed方法又调用了setErrorPlaceholder方法，接着看看该方法中做了什么操作 1234567891011121314151617181920212223242526272829/** SingleRequest 类的setErrorPlaceholder方法*/ private void setErrorPlaceholder() &#123; if (!canNotifyStatusChanged()) &#123; return; &#125; Drawable error = null; if (model == null) &#123; error = getFallbackDrawable(); &#125; // Either the model isn't null, or there was no fallback drawable set. if (error == null) &#123; error = getErrorDrawable(); &#125; // The model isn't null, no fallback drawable was set or no error drawable was set. if (error == null) &#123; error = getPlaceholderDrawable(); &#125; target.onLoadFailed(error); &#125; private Drawable getErrorDrawable() &#123; if (errorDrawable == null) &#123; errorDrawable = requestOptions.getErrorPlaceholder(); if (errorDrawable == null &amp;&amp; requestOptions.getErrorId() &gt; 0) &#123; errorDrawable = loadDrawable(requestOptions.getErrorId()); &#125; &#125; return errorDrawable; &#125; 通过以上源码，如果我们传入图片地址为空，则首先查看是否有后备回调符设置，然后是错误占位符，最后是加载占位符，最终调用target.onLoadFailed方法，也就是ImageViewTarget的onLoadFailed方法 1234567891011121314151617181920212223public abstract class ImageViewTarget&lt;Z&gt; extends ViewTarget&lt;ImageView, Z&gt;implements Transition.ViewAdapter &#123; //省略部分代码 ....... public void setDrawable(Drawable drawable) &#123; view.setImageDrawable(drawable); &#125; @Override public void onLoadStarted(@Nullable Drawable placeholder) &#123; super.onLoadStarted(placeholder); setResourceInternal(null); setDrawable(placeholder); &#125; @Override public void onLoadFailed(@Nullable Drawable errorDrawable) &#123; super.onLoadFailed(errorDrawable); setResourceInternal(null); setDrawable(errorDrawable); &#125; //省略部分代码 .......&#125; 通过以上源码，我想你应该已经明白了后备回调符、错误占位符加载，这里还有一个疑问，加载占位符呢？我们回到之前SingleRequest对象的begin方法，相信你会马上看到在加载状态为RUNNING的时候调用了target.onLoadStarted，也实现了加载中的占位符，到这里我们已经分析完了后备回调符、加载占位符和错误占位符加载底层实现逻辑。加载图片网络请求 前面分析完各种占位符实现，我们再次回到SingleRequest对象的begin方法，我们可以注意到onSizeReady()和target.getSize()这两句就是加载图片的入口，如果我们在使用glide的时候设置图片加载的大小尺寸，则会调用target.getSize() 1234567891011/** ViewTarget 类的etSize方法*/ void getSize(@NonNull SizeReadyCallback cb) &#123; int currentWidth = getTargetWidth(); int currentHeight = getTargetHeight(); if (isViewStateAndSizeValid(currentWidth, currentHeight)) &#123; cb.onSizeReady(currentWidth, currentHeight); return; &#125; //省略部分代码 ...... &#125; 通过以上源码，target.getSize()会根据ImageView的宽高来得出图片的加载宽高，最终target.getSize()还是会调用onSizeReady()方法，所以我们就直接来看看SingleRequest对象onSizeReady()方法中做了什么操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** SingleRequest 类的onSizeReady方法*/@Override public void onSizeReady(int width, int height) &#123; stateVerifier.throwIfRecycled(); if (IS_VERBOSE_LOGGABLE) &#123; logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime)); &#125; if (status != Status.WAITING_FOR_SIZE) &#123; return; &#125; status = Status.RUNNING; float sizeMultiplier = requestOptions.getSizeMultiplier(); this.width = maybeApplySizeMultiplier(width, sizeMultiplier); this.height = maybeApplySizeMultiplier(height, sizeMultiplier); if (IS_VERBOSE_LOGGABLE) &#123; logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime)); &#125; loadStatus = engine.load( glideContext, model, requestOptions.getSignature(), this.width, this.height, requestOptions.getResourceClass(), transcodeClass, priority, requestOptions.getDiskCacheStrategy(), requestOptions.getTransformations(), requestOptions.isTransformationRequired(), requestOptions.isScaleOnlyOrNoTransform(), requestOptions.getOptions(), requestOptions.isMemoryCacheable(), requestOptions.getUseUnlimitedSourceGeneratorsPool(), requestOptions.getUseAnimationPool(), requestOptions.getOnlyRetrieveFromCache(), this); // This is a hack that's only useful for testing right now where loads complete synchronously // even though under any executor running on any thread but the main thread, the load would // have completed asynchronously. if (status != Status.RUNNING) &#123; loadStatus = null; &#125; if (IS_VERBOSE_LOGGABLE) &#123; logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime)); &#125; &#125; 在onSizeReady方法中，主要调用了engine.load()方法并返回加载状态，engine.load方法继续接收我们之前传入的各种参数，其中也有我们model对象，也就是之前load方法传入的图片地址。首先我们需要了解engine是什么，顾名思义，engine的英文意思是发动机，而在Glide框架中他就是负责启动图片加载的发动机，主要负责启动加载，我们在前面with方法获取glide对象中得到了engine对象（这里就不贴源码了），我们接着看engine.load()方法进行什么操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** Engine 类的load方法*/public &lt;R&gt; LoadStatus load(GlideContext glideContext, Object model,Key signature,int width,int height,Class&lt;?&gt; resourceClass,Class&lt;R&gt; transcodeClass, Priority priority,DiskCacheStrategy diskCacheStrategy, Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,boolean isTransformationRequired,boolean isScaleOnlyOrNoTransform,Options options,boolean isMemoryCacheable,boolean useUnlimitedSourceExecutorPool,boolean useAnimationPool,boolean onlyRetrieveFromCache,ResourceCallback cb) &#123; Util.assertMainThread(); long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0; EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations, resourceClass, transcodeClass, options); EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable); if (active != null) &#123; cb.onResourceReady(active, DataSource.MEMORY_CACHE); if (VERBOSE_IS_LOGGABLE) &#123; logWithTimeAndKey("Loaded resource from active resources", startTime, key); &#125; return null; &#125; EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable); if (cached != null) &#123; cb.onResourceReady(cached, DataSource.MEMORY_CACHE); if (VERBOSE_IS_LOGGABLE) &#123; logWithTimeAndKey("Loaded resource from cache", startTime, key); &#125; return null; &#125; EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache); if (current != null) &#123; current.addCallback(cb); if (VERBOSE_IS_LOGGABLE) &#123; logWithTimeAndKey("Added to existing load", startTime, key); &#125; return new LoadStatus(cb, current); &#125; EngineJob&lt;R&gt; engineJob = engineJobFactory.build( key, isMemoryCacheable, useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache); DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build( glideContext, model, key, signature, width, height, resourceClass, transcodeClass, priority, diskCacheStrategy, transformations, isTransformationRequired, isScaleOnlyOrNoTransform, onlyRetrieveFromCache, options, engineJob); jobs.put(key, engineJob); engineJob.addCallback(cb); engineJob.start(decodeJob); if (VERBOSE_IS_LOGGABLE) &#123; logWithTimeAndKey("Started new load", startTime, key); &#125; return new LoadStatus(cb, engineJob); &#125;/** DecodeJob 类的继承关系*/ class DecodeJob&lt;R&gt; implements DataFetcherGenerator.FetcherReadyCallback, Runnable, Comparable&lt;DecodeJob&lt;?&gt;&gt;, Poolable 通过以上源码，Engine对象的load方前面一段代码都是在处理缓存问题，这里先不进行展开，继续走我们加载图片的主线，往下看我们看到构建了一个EngineJob对象，还构建了一个DecodeJob对象，构建DecodeJob对象又继续接收我们之前传入的各种参数，由DecodeJob对象的继承关系我们可以知道它是Runnable对象，接着我们看到engineJob的start()方法，它直接传入了DecodeJob对象 1234567891011121314151617181920/** EngineJob 类的start方法*/public void start(DecodeJob&lt;R&gt; decodeJob) &#123; this.decodeJob = decodeJob; GlideExecutor executor = decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor(); executor.execute(decodeJob); &#125;/** GlideExecutor 类的newSourceExecutor方法*/ public static GlideExecutor newSourceExecutor( int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) &#123; return new GlideExecutor( new ThreadPoolExecutor( threadCount /* corePoolSize */, threadCount /* maximumPoolSize */, 0 /* keepAliveTime */, TimeUnit.MILLISECONDS, new PriorityBlockingQueue&lt;Runnable&gt;(), new DefaultThreadFactory(name, uncaughtThrowableStrategy, false))); &#125; 通过以上源码，EngineJob对象的start方法首先还是判断缓存，最终获取的GlideExecutor就是一个线程池执行器（Executor），GlideExecutor中有各种方法获得缓存线程池，还有资源线程池（SourceExecutor），以上源码贴出资源线程池。实际上EngineJob对象的start方法就是用来在线程池中启动DecodeJob这个Runnable对象，也就是说EngineJob的主要作用是开启线程来加载图片，接着我们来看看DecodeJob对象的run方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** DecodeJob 类的run方法*/public void run() &#123; DataFetcher&lt;?&gt; localFetcher = currentFetcher; try &#123; if (isCancelled) &#123; notifyFailed(); return; &#125; runWrapped(); &#125; catch (Throwable t) &#123; //省略部分代码 ....... &#125; finally &#123; if (localFetcher != null) &#123; localFetcher.cleanup(); &#125; GlideTrace.endSection(); &#125; &#125;/** DecodeJob 类的runWrapped方法*/ private void runWrapped() &#123; switch (runReason) &#123; case INITIALIZE: stage = getNextStage(Stage.INITIALIZE); currentGenerator = getNextGenerator(); runGenerators(); break; case SWITCH_TO_SOURCE_SERVICE: runGenerators(); break; case DECODE_DATA: decodeFromRetrievedData(); break; default: throw new IllegalStateException("Unrecognized run reason: " + runReason); &#125; &#125;/** DecodeJob 类的getNextStage方法*/ private Stage getNextStage(Stage current) &#123; switch (current) &#123; case INITIALIZE: return diskCacheStrategy.decodeCachedResource() ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE); case RESOURCE_CACHE: return diskCacheStrategy.decodeCachedData() ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE); case DATA_CACHE: // Skip loading from source if the user opted to only retrieve the resource from cache. return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE; case SOURCE: case FINISHED: return Stage.FINISHED; default: throw new IllegalArgumentException("Unrecognized stage: " + current); &#125; &#125; /** DecodeJob 类的getNextGenerator方法*/ private DataFetcherGenerator getNextGenerator() &#123; switch (stage) &#123; case RESOURCE_CACHE: return new ResourceCacheGenerator(decodeHelper, this); case DATA_CACHE: return new DataCacheGenerator(decodeHelper, this); case SOURCE: return new SourceGenerator(decodeHelper, this); case FINISHED: return null; default: throw new IllegalStateException("Unrecognized stage: " + stage); &#125; /** DecodeJob 类的runGenerators方法*/ private void runGenerators() &#123; currentThread = Thread.currentThread(); startFetchTime = LogTime.getLogTime(); boolean isStarted = false; while (!isCancelled &amp;&amp; currentGenerator != null &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123; stage = getNextStage(stage); currentGenerator = getNextGenerator(); if (stage == Stage.SOURCE) &#123; reschedule(); return; &#125; &#125; //省略部分代码 ....... &#125; 上面我们再次贴出了一堆代码，我们来好好梳理一下逻辑，DecodeJob对象的run方法中逻辑很简单，就是调用了自身的runWrapped方法，runWrapped方法中首先判断Stage枚举，前面在创建DecodeJob对象时候设置初始状态为Stage.INITIALIZE，然后接着调用getNextStage方法，这里我们还是继续跳过缓存，所以getNextStage方法最终返回的是Stage.SOURCE状态，接着在getNextGenerator()方法中我们获取就是SourceGenerator对象，也就是run方法中的第一句话DataFetcher&lt;?&gt; localFetcher = currentFetcher中localFetcher就是我们刚刚获得的SourceGenerator对象，接着继续执行runGenerators()方法，在该方法的while循环判断条件执行了currentGenerator.startNext()方法，也就是SourceGenerator对象的startNext()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** SourceGenerator 类的startNext()方法*/ @Override public boolean startNext() &#123; //省略部分代码，跳过缓存部分判断 ........ loadData = null; boolean started = false; while (!started &amp;&amp; hasNextModelLoader()) &#123; loadData = helper.getLoadData().get(loadDataListIndex++); if (loadData != null &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource()) || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123; started = true; loadData.fetcher.loadData(helper.getPriority(), this); &#125; &#125; return started; &#125;/** DecodeHelper 类的getLoadData() 方法*/List&lt;LoadData&lt;?&gt;&gt; getLoadData() &#123; if (!isLoadDataSet) &#123; isLoadDataSet = true; loadData.clear(); List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders = glideContext.getRegistry().getModelLoaders(model); //noinspection ForLoopReplaceableByForEach to improve perf for (int i = 0, size = modelLoaders.size(); i &lt; size; i++) &#123; ModelLoader&lt;Object, ?&gt; modelLoader = modelLoaders.get(i); LoadData&lt;?&gt; current = modelLoader.buildLoadData(model, width, height, options); if (current != null) &#123; loadData.add(current); &#125; &#125; &#125; return loadData; &#125;/** HttpGlideUrlLoader 类的buildLoadData 方法*/ @Override public LoadData&lt;InputStream&gt; buildLoadData(@NonNull GlideUrl model, int width, int height, @NonNull Options options) &#123; // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time // spent parsing urls. GlideUrl url = model; if (modelCache != null) &#123; url = modelCache.get(model, 0, 0); if (url == null) &#123; modelCache.put(model, 0, 0, model); url = model; &#125; &#125; int timeout = options.get(TIMEOUT); return new LoadData&lt;&gt;(url, new HttpUrlFetcher(url, timeout)); &#125; 通过上面源码，我们接着看到loadData=helper.getLoadData().get(loadDataListIndex++)这一句代码，helper就是DecodeHelper对象，在我们前面创建DecodeJob对象的时候已经把它创建，之前我们在load步骤中传入的model是图片url地址，所以经过DecodeHelper 类的getLoadData() 方法（更细的代码这里就不进行展开了），最终获取的ModelLoader&lt;Object, ?&gt; modelLoader对象则为HttpGlideUrlLoader对象，也就是laodData对象，所以modelLoader.buildLoadData创建则在HttpGlideUrlLoader对象的buildLoadData中实现，上方贴出的该方法源码中把我们model赋值给GlideUrl对象，也就是将其作为URL地址来进行处理，则经过modelLoader.buildLoadData获取的loadData.fetcher则对应HttpUrlFetcher对象，所以loadData.fetcher.loadData调用的就是HttpUrlFetcher对象loadData方法， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/**HttpUrlFetcher类的loadData方法 **/@Override public void loadData(@NonNull Priority priority, @NonNull DataCallback&lt;? super InputStream&gt; callback) &#123; long startTime = LogTime.getLogTime(); try &#123; InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders()); callback.onDataReady(result); &#125; catch (IOException e) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, "Failed to load data for url", e); &#125; callback.onLoadFailed(e); &#125; finally &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime)); &#125; &#125; &#125;/**HttpUrlFetcher类的loadDataWithRedirects方法 **/ private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map&lt;String, String&gt; headers) throws IOException &#123; if (redirects &gt;= MAXIMUM_REDIRECTS) &#123; throw new HttpException("Too many (&gt; " + MAXIMUM_REDIRECTS + ") redirects!"); &#125; else &#123; // Comparing the URLs using .equals performs additional network I/O and is generally broken. // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html. try &#123; if (lastUrl != null &amp;&amp; url.toURI().equals(lastUrl.toURI())) &#123; throw new HttpException("In re-direct loop"); &#125; &#125; catch (URISyntaxException e) &#123; // Do nothing, this is best effort. &#125; &#125; urlConnection = connectionFactory.build(url); for (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123; urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue()); &#125; urlConnection.setConnectTimeout(timeout); urlConnection.setReadTimeout(timeout); urlConnection.setUseCaches(false); urlConnection.setDoInput(true); // Stop the urlConnection instance of HttpUrlConnection from following redirects so that // redirects will be handled by recursive calls to this method, loadDataWithRedirects. urlConnection.setInstanceFollowRedirects(false); // Connect explicitly to avoid errors in decoders if connection fails. urlConnection.connect(); // Set the stream so that it's closed in cleanup to avoid resource leaks. See #2352. stream = urlConnection.getInputStream(); if (isCancelled) &#123; return null; &#125; final int statusCode = urlConnection.getResponseCode(); if (isHttpOk(statusCode)) &#123; return getStreamForSuccessfulRequest(urlConnection); &#125; else if (isHttpRedirect(statusCode)) &#123; String redirectUrlString = urlConnection.getHeaderField("Location"); if (TextUtils.isEmpty(redirectUrlString)) &#123; throw new HttpException("Received empty or null redirect url"); &#125; URL redirectUrl = new URL(url, redirectUrlString); // Closing the stream specifically is required to avoid leaking ResponseBodys in addition // to disconnecting the url connection below. See #2352. cleanup(); return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers); &#125; else if (statusCode == INVALID_STATUS_CODE) &#123; throw new HttpException(statusCode); &#125; else &#123; throw new HttpException(urlConnection.getResponseMessage(), statusCode); &#125; &#125; 通过以上源码，HttpUrlFetcher对象的loadData方法首先调用自身loadDataWithRedirects方法，接着我们看到该方法源码，这里使用了HttpURLConnection来执行了网络请求，看到这里内心还是有点开心的，前面看了这么多源码，终于看到Glide的网络请求了，开心之后还没完呢，还得接着往下看，执行完网络请求成功，loadDataWithRedirects方法中网络请求成功调用getStreamForSuccessfulRequest返回了一个InputStream流(记住这个InputStream，很关键)，然后执行了一个callback回调，而这个回调对象就是我们之前在SourceGenerator对象中调用loadData方法传入SourceGenerator对象本身，所以callback.onDataReady()调用的就是SourceGenerator对象的onDataReady方法 1234567891011121314/**SourceGenerator类的onDataReady方法 **/ @Override public void onDataReady(Object data) &#123; DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy(); if (data != null &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123; dataToCache = data; // We might be being called back on someone else's thread. Before doing anything, we should // reschedule to get back onto Glide's thread. cb.reschedule(); &#125; else &#123; cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher, loadData.fetcher.getDataSource(), originalKey); &#125; &#125; 通过以上源码，不走缓存的情况下则调用cb.onDataFetcherReady，这个cb也就是前面我们new SourceGenerator对象传入的 DecodeJob对象，也就是调用DecodeJob对象onDataFetcherReady方法 123456789101112131415161718192021/**DecodeJob类的onDataFetcherReady方法 **/ @Override public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey) &#123; this.currentSourceKey = sourceKey; this.currentData = data; this.currentFetcher = fetcher; this.currentDataSource = dataSource; this.currentAttemptingKey = attemptedKey; if (Thread.currentThread() != currentThread) &#123; runReason = RunReason.DECODE_DATA; callback.reschedule(this); &#125; else &#123; GlideTrace.beginSection("DecodeJob.decodeFromRetrievedData"); try &#123; decodeFromRetrievedData(); &#125; finally &#123; GlideTrace.endSection(); &#125; &#125; &#125; 通过以上源码，onDataFetcherReady方法中将之前网络请求得到的流赋值给当前的DecodeJob对象的currentData，其他数据都赋值给对应字段，最终调用的是decodeFromRetrievedData方法 加载图片（解码，转码）1234567891011121314151617181920212223242526272829303132333435363738394041424344/**DecodeJob类的decodeFromRetrievedData方法 **/ private void decodeFromRetrievedData() &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Retrieved data", startFetchTime, "data: " + currentData + ", cache key: " + currentSourceKey + ", fetcher: " + currentFetcher); &#125; Resource&lt;R&gt; resource = null; try &#123; resource = decodeFromData(currentFetcher, currentData, currentDataSource); &#125; catch (GlideException e) &#123; e.setLoggingDetails(currentAttemptingKey, currentDataSource); throwables.add(e); &#125; if (resource != null) &#123; notifyEncodeAndRelease(resource, currentDataSource); &#125; else &#123; runGenerators(); &#125; &#125;/**DecodeJob类的decodeFromData方法 **/ private &lt;Data&gt; Resource&lt;R&gt; decodeFromData(DataFetcher&lt;?&gt; fetcher, Data data, DataSource dataSource) throws GlideException &#123; try &#123; if (data == null) &#123; return null; &#125; long startTime = LogTime.getLogTime(); Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Decoded result " + result, startTime); &#125; return result; &#125; finally &#123; fetcher.cleanup(); &#125; &#125;/**DecodeJob类的decodeFromFetcher方法 **/ private &lt;Data&gt; Resource&lt;R&gt; decodeFromFetcher(Data data, DataSource dataSource) throws GlideException &#123; LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass()); return runLoadPath(data, dataSource, path); &#125; 通过以上源码，decodeFromRetrievedData方法调用了decodeFromFetcher方法，在该方法中首先通过decodeHelper.getLoadPath获取LoadPath对象，LoadPath对象其实是根据我们传入的处理数据来返回特定的数据解码转码处理器，我们跟进decodeHelper.getLoadPath看看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** DecodeHelper类的getLoadPath方法*/&lt;Data&gt; LoadPath&lt;Data, ?, Transcode&gt; getLoadPath(Class&lt;Data&gt; dataClass) &#123; return glideContext.getRegistry().getLoadPath(dataClass, resourceClass, transcodeClass); &#125;/** Registry类的getLoadPath方法*/ @Nullable public &lt;Data, TResource, Transcode&gt; LoadPath&lt;Data, TResource, Transcode&gt; getLoadPath( @NonNull Class&lt;Data&gt; dataClass, @NonNull Class&lt;TResource&gt; resourceClass, @NonNull Class&lt;Transcode&gt; transcodeClass) &#123; //省略部分代码 ....... List&lt;DecodePath&lt;Data, TResource, Transcode&gt;&gt; decodePaths = getDecodePaths(dataClass, resourceClass, transcodeClass); if (decodePaths.isEmpty()) &#123; result = null; &#125; else &#123; result = new LoadPath&lt;&gt;( dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool); &#125; loadPathCache.put(dataClass, resourceClass, transcodeClass, result); &#125; return result; &#125; /** Registry类的getDecodePaths方法*/ @NonNull private &lt;Data, TResource, Transcode&gt; List&lt;DecodePath&lt;Data, TResource, Transcode&gt;&gt; getDecodePaths( @NonNull Class&lt;Data&gt; dataClass, @NonNull Class&lt;TResource&gt; resourceClass, @NonNull Class&lt;Transcode&gt; transcodeClass) &#123; //省略部分代码，去除干扰 List&lt;ResourceDecoder&lt;Data, TResource&gt;&gt; decoders = decoderRegistry.getDecoders(dataClass, registeredResourceClass); ResourceTranscoder&lt;TResource, Transcode&gt; transcoder = transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass); @SuppressWarnings("PMD.AvoidInstantiatingObjectsInLoops") DecodePath&lt;Data, TResource, Transcode&gt; path = new DecodePath&lt;&gt;(dataClass, registeredResourceClass, registeredTranscodeClass, decoders, transcoder, throwableListPool); decodePaths.add(path); &#125; return decodePaths; &#125; /** Registry类的getDecoders方法*/ public synchronized &lt;T, R&gt; List&lt;ResourceDecoder&lt;T, R&gt;&gt; getDecoders(@NonNull Class&lt;T&gt; dataClass, @NonNull Class&lt;R&gt; resourceClass) &#123; List&lt;ResourceDecoder&lt;T, R&gt;&gt; result = new ArrayList&lt;&gt;(); for (String bucket : bucketPriorityList) &#123; List&lt;Entry&lt;?, ?&gt;&gt; entries = decoders.get(bucket); if (entries == null) &#123; continue; &#125; for (Entry&lt;?, ?&gt; entry : entries) &#123; if (entry.handles(dataClass, resourceClass)) &#123; result.add((ResourceDecoder&lt;T, R&gt;) entry.decoder); &#125; &#125; &#125; // TODO: cache result list. return result; &#125; 通过以上源码，我们接着前面跟进DecodeHelper.getLoadPath方法，它调用了Registry对象的getLoadPath方法，Registry对象的getLoadPath方法又调用了自身的getDecodePaths方法，现在我前面提到过得我们网络请求获取的是InputStream流，所以上面源码getDecodePaths方法中Data泛型就是InputStream，在根据getDecoders方法遍历得到解码器ResourceDecoder能处理InputStream流的有StreamBitmapDecoder和StreamGifDecoder，StreamGifDecoder处理的是Gif，我们这里处理图片就之能是StreamBitmapDecoder，它将InputStream流解码成bitmap，然后能将bitmap转换成Drawable的转码器ResourceTranscoder对象则是BitmapDrawableTranscoder，最后getDecodePaths将我们刚刚分析得到的解码器和转码器传递给了新建的DecodePath对象，DecodePath对象就是用来帮助我们进行解码和转码的。 接着我们继续上一步的decodeFromFetcher方法，该方法返回的runLoadPath最终调用了上面获得的DecodePath对象的decode方法 123456789101112131415161718192021222324252627282930313233343536/**DecodePath类的decode方法**/public Resource&lt;Transcode&gt; decode(DataRewinder&lt;DataType&gt; rewinder, int width, int height, @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback) throws GlideException &#123; Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options); Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded); return transcoder.transcode(transformed, options); &#125;/**DecodePath类的decodeResource方法**/@NonNull private Resource&lt;ResourceType&gt; decodeResource(DataRewinder&lt;DataType&gt; rewinder, int width, int height, @NonNull Options options) throws GlideException &#123; List&lt;Throwable&gt; exceptions = Preconditions.checkNotNull(listPool.acquire()); try &#123; return decodeResourceWithList(rewinder, width, height, options, exceptions); &#125; finally &#123; listPool.release(exceptions); &#125; &#125;/**DecodePath类的decodeResourceWithList方法**/ @NonNull private Resource&lt;ResourceType&gt; decodeResourceWithList(DataRewinder&lt;DataType&gt; rewinder, int width, int height, @NonNull Options options, List&lt;Throwable&gt; exceptions) throws GlideException &#123; Resource&lt;ResourceType&gt; result = null; //省略部分代码 ........ ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i); try &#123; DataType data = rewinder.rewindAndGet(); if (decoder.handles(data, options)) &#123; data = rewinder.rewindAndGet(); result = decoder.decode(data, width, height, options); &#125; //省略部分代码 ........ return result; &#125; 通过以上源码，DecodePath对象的decode方法调用了decodeResource方法，decodeResource又调用了decodeResourceWithList方法，经过前面分析，decodeResourceWithList方法中获得的decoder就是前面提到的解码器StreamBitmapDecoder对象，所以我们接着看StreamBitmapDecoder的decode方法 123456789101112131415161718192021222324252627282930/**StreamBitmapDecoder类的decode方法**/@Override public Resource&lt;Bitmap&gt; decode(@NonNull InputStream source, int width, int height, @NonNull Options options) throws IOException &#123; // Use to fix the mark limit to avoid allocating buffers that fit entire images. final RecyclableBufferedInputStream bufferedStream; final boolean ownsBufferedStream; if (source instanceof RecyclableBufferedInputStream) &#123; bufferedStream = (RecyclableBufferedInputStream) source; ownsBufferedStream = false; &#125; else &#123; bufferedStream = new RecyclableBufferedInputStream(source, byteArrayPool); ownsBufferedStream = true; &#125; ExceptionCatchingInputStream exceptionStream = ExceptionCatchingInputStream.obtain(bufferedStream); MarkEnforcingInputStream invalidatingStream = new MarkEnforcingInputStream(exceptionStream); UntrustedCallbacks callbacks = new UntrustedCallbacks(bufferedStream, exceptionStream); try &#123; return downsampler.decode(invalidatingStream, width, height, options, callbacks); &#125; finally &#123; exceptionStream.release(); if (ownsBufferedStream) &#123; bufferedStream.release(); &#125; &#125; &#125; 通过以上源码，StreamBitmapDecoder的decode方法中只是对InputStream进行包装（装饰模式），可以让Glide进行更多操作，最终调用了downsampler.decode，这个downsampler对象则是Downsampler对象（英文注释：Downsamples, decodes, and rotates images according to their exif orientation.），英文注释大致意思是对图像exif格式进行采样、解码和旋转。而我们这里调用了它的decode方法，也就是对我们前面包装的流进行解码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/**Downsampler类的decode方法**/public Resource&lt;Bitmap&gt; decode(InputStream is, int requestedWidth, int requestedHeight, Options options, DecodeCallbacks callbacks) throws IOException &#123; //省略部分代码 try &#123; Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions, downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth, requestedHeight, fixBitmapToRequestedDimensions, callbacks); return BitmapResource.obtain(result, bitmapPool); &#125; finally &#123; releaseOptions(bitmapFactoryOptions); byteArrayPool.put(bytesForOptions); &#125; &#125;/**Downsampler类的decodeFromWrappedStreams方法**/ private Bitmap decodeFromWrappedStreams(InputStream is, BitmapFactory.Options options, DownsampleStrategy downsampleStrategy, DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth, int requestedHeight, boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException &#123; //省略部分代码 ......... Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool); callbacks.onDecodeComplete(bitmapPool, downsampled); //省略部分代码 ......... Bitmap rotated = null; if (downsampled != null) &#123; //缩放效正处理 downsampled.setDensity(displayMetrics.densityDpi); rotated = TransformationUtils.rotateImageExif(bitmapPool, downsampled, orientation); if (!downsampled.equals(rotated)) &#123; bitmapPool.put(downsampled); &#125; &#125; return rotated; &#125;/**Downsampler类的decodeStream方法**/ private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options, DecodeCallbacks callbacks, BitmapPool bitmapPool) throws IOException &#123; if (options.inJustDecodeBounds) &#123; is.mark(MARK_POSITION); &#125; else &#123; callbacks.onObtainBounds(); &#125; int sourceWidth = options.outWidth; int sourceHeight = options.outHeight; String outMimeType = options.outMimeType; final Bitmap result; TransformationUtils.getBitmapDrawableLock().lock(); try &#123; result = BitmapFactory.decodeStream(is, null, options); &#125; catch (IllegalArgumentException e) &#123; //省略部分代码 ......... return result; &#125; 通过以上源码，Downsampler对象的decode方法首先调用了decodeFromWrappedStreams方法，在decodeFromWrappedStreams方法中又调用了decodeStream方法，在该方法中调用用了BitmapFactory.decodeStream，到这里我们终于看到了Glide将InputStream流解析成了bitmap，而最终Downsampler对象的decode方法返回的Resource对象就是BitmapResource对象 经过前面的分析，Glide已经将InputStream解码完成，这时我们还得再次回到DecodePath对象的decode方法，解码完成还需转码，这里再次贴一下ecodePath对象的decode方法，前面已经分析了转码器为BitmapDrawableTranscoder对象，所以我们继续看BitmapDrawableTranscoder对象transcode做了什么操作 123456789101112131415161718192021/**DecodePath类的decode方法**/ public Resource&lt;Transcode&gt; decode(DataRewinder&lt;DataType&gt; rewinder, int width, int height, @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback) throws GlideException &#123; Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options); Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded); return transcoder.transcode(transformed, options); &#125;/**BitmapDrawableTranscoder类的transcode方法**/ public Resource&lt;BitmapDrawable&gt; transcode(@NonNull Resource&lt;Bitmap&gt; toTranscode, @NonNull Options options) &#123; return LazyBitmapDrawableResource.obtain(resources, toTranscode); &#125; /**LazyBitmapDrawableResource类的obtain方法**/ @Nullable public static Resource&lt;BitmapDrawable&gt; obtain( @NonNull Resources resources, @Nullable Resource&lt;Bitmap&gt; bitmapResource) &#123; if (bitmapResource == null) &#123; return null; &#125; return new LazyBitmapDrawableResource(resources, bitmapResource); &#125; 通过以上源码，BitmapDrawableTranscoder对象transcode方法最终返回了LazyBitmapDrawableResource对象，也就是将我们解码拿到的BitmapResource对象转换成了LazyBitmapDrawableResource对象 到此，Glide整个图片解码转码已近完成，接着我们再回到DecodeJob对象的decodeFromRetrievedData方法 图片显示1234567891011121314151617181920212223242526272829303132/**DecodeJob类的decodeFromRetrievedData方法**/private void decodeFromRetrievedData() &#123; Resource&lt;R&gt; resource = null; try &#123; resource = decodeFromData(currentFetcher, currentData, currentDataSource); &#125; catch (GlideException e) &#123; e.setLoggingDetails(currentAttemptingKey, currentDataSource); throwables.add(e); &#125; if (resource != null) &#123; notifyEncodeAndRelease(resource, currentDataSource); &#125; else &#123; runGenerators(); &#125; &#125;/**DecodeJob类的notifyEncodeAndRelease方法**/ private void notifyEncodeAndRelease(Resource&lt;R&gt; resource, DataSource dataSource) &#123; //省略部分代码 ..... Resource&lt;R&gt; result = resource; //省略部分代码 ..... notifyComplete(result, dataSource); stage = Stage.ENCODE; //省略部分代码 ..... &#125;/**DecodeJob类的notifyComplete方法**/ private void notifyComplete(Resource&lt;R&gt; resource, DataSource dataSource) &#123; setNotifiedOrThrow(); callback.onResourceReady(resource, dataSource); &#125; 通过以上源码，DecodeJob对象的decodeFromRetrievedData方法调用notifyEncodeAndRelease方法，将我们上一步获取的LazyBitmapDrawableResource传入notifyComplete方法中，在notifyComplete调用了callback.onResourceReady，而这个callback对象就是EngineJob对象（它实现了DecodeJob.Callback接口），也许到这里你已经忘了EngineJob对象是什么，前面我们开启线程执行加载的start方法就在EngineJob对象中，所以我们去看看EngineJob对象的onResourceReady方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private static final Handler MAIN_THREAD_HANDLER = new Handler(Looper.getMainLooper(), new MainThreadCallback());/**EngineJob类的onResourceReady方法**/@Override public void onResourceReady(Resource&lt;R&gt; resource, DataSource dataSource) &#123; this.resource = resource; this.dataSource = dataSource; MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget(); &#125;/**EngineJob类的handleMessage方法**/ @Override public boolean handleMessage(Message message) &#123; EngineJob&lt;?&gt; job = (EngineJob&lt;?&gt;) message.obj; switch (message.what) &#123; case MSG_COMPLETE: job.handleResultOnMainThread(); break; case MSG_EXCEPTION: job.handleExceptionOnMainThread(); break; case MSG_CANCELLED: job.handleCancelledOnMainThread(); break; default: throw new IllegalStateException("Unrecognized message: " + message.what); &#125; return true; &#125; /**EngineJob类的handleResultOnMainThread方法**/ @Synthetic void handleResultOnMainThread() &#123; //省略部分代码 ...... engineResource = engineResourceFactory.build(resource, isCacheable); hasResource = true; //省略部分代码 ...... for (int i = 0, size = cbs.size(); i &lt; size; i++) &#123; ResourceCallback cb = cbs.get(i); if (!isInIgnoredCallbacks(cb)) &#123; engineResource.acquire(); cb.onResourceReady(engineResource, dataSource); &#125; &#125; //省略部分代码 ...... &#125;/**EngineJob类的addCallback方法**/ private final List&lt;ResourceCallback&gt; cbs = new ArrayList&lt;&gt;(2);void addCallback(ResourceCallback cb) &#123; Util.assertMainThread(); stateVerifier.throwIfRecycled(); if (hasResource) &#123; cb.onResourceReady(engineResource, dataSource); &#125; else if (hasLoadFailed) &#123; cb.onLoadFailed(exception); &#125; else &#123; cbs.add(cb); &#125; &#125; 通过以上源码，前面我们在Engine类的Load方法中已经将SingleRequest这个对象通过EngineJob对象的addCallback方法加入到了cbs这个List当中，EngineJob对象的onResourceReady方法中将我们加载好的图片对象通过Hanlder将数据又传递到了主线程（主线程更新UI），也就是handleResultOnMainThread方法中根据我们刚刚的分析通过cb.onResourceReady将数据回调通知，cb对象就是SingleRequest对象，我们接着看SingleRequest对象的onResourceReady回调方法 12345678910111213141516171819202122232425262728/**SingleRequest类的onResourceReady回调方法**/@SuppressWarnings("unchecked")@Overridepublic void onResourceReady(Resource&lt;?&gt; resource, DataSource dataSource) &#123; //省略部分代码 ....... Object received = resource.get(); //省略部分代码 ....... onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource); &#125;/**SingleRequest类的onResourceReady方法**/ private void onResourceReady(Resource&lt;R&gt; resource, R result, DataSource dataSource) &#123; //省略部分代码 ....... status = Status.COMPLETE; this.resource = resource; //省略部分代码 ....... if (!anyListenerHandledUpdatingTarget) &#123; Transition&lt;? super R&gt; animation = animationFactory.build(dataSource, isFirstResource); target.onResourceReady(result, animation); &#125; &#125; //省略部分代码 ....... &#125; 通过以上源码，这时候我们已经可以看到长征胜利的曙光了，SingleRequest对象的onResourceReady回调方法中调用了resource.get()，而这个resource就是前面我们经过解码、转码获取的LazyBitmapDrawableResource对象，然后又调用了SingleRequest对象的onResourceReady私有方法，在该方法中又调用了target.onResourceReady方法，在我们最开始进入into方法的时候我们已经分析过创建的target对象就是DrawableImageViewTarget对象，它继承了抽象类ImageViewTarget，所以我们看看抽象类ImageViewTarget的onResourceReady方法123456789101112131415161718192021222324/** LazyBitmapDrawableResource类的get()方法**/@NonNull @Override public BitmapDrawable get() &#123; return new BitmapDrawable(resources, bitmapResource.get()); &#125;/** ImageViewTarget类的onResourceReady方法**/ @Override public void onResourceReady(@NonNull Z resource, @Nullable Transition&lt;? super Z&gt; transition) &#123; if (transition == null || !transition.transition(resource, this)) &#123; setResourceInternal(resource); &#125; else &#123; maybeUpdateAnimatable(resource); &#125; &#125;/** ImageViewTarget类的setResourceInternal方法**/ private void setResourceInternal(@Nullable Z resource) &#123; // Order matters here. Set the resource first to make sure that the Drawable has a valid and // non-null Callback before starting it. setResource(resource); maybeUpdateAnimatable(resource); &#125; protected abstract void setResource(@Nullable Z resource); 通过以上源码，LazyBitmapDrawableResource对象的get()方法获取了BitmapDrawable（实际就是Drawable对象），ImageViewTarget对象的onResourceReady方法通过前面分析被调用，然后该方法再调用了ImageViewTarget对象setResourceInternal方法，setResourceInternal方法最终setResource方法，setResource在ImageViewTarget对象是抽象方法，它在DrawableImageViewTarget对象中实现，最后我们看看DrawableImageViewTarget对象setResource方法1234@Override protected void setResource(@Nullable Drawable resource) &#123; view.setImageDrawable(resource); &#125; 到此，我们的万里长征终于结束了一半，Glide的简单加载图片流程已经分析完了。 最后说点 最后我还是想要把那句简单的代码给贴出来 1Glide.with(Context).load(IMAGE_URL).into(mImageView); 就是这样一句简单的代码，它背后所走的逻辑却让人头皮发麻，此时我只想说一句话“read the fuck source code”。前面我们只是分析了Glide简单的加载图片流程，它的缓存使用，各种变换，回调和各种功能原理还没分析到，这只能等到下篇文章了。文章中如果有错误，请大家给我提出来，大家一起学习进步，如果觉得我的文章给予你帮助，也请给我一个喜欢和关注，同时也欢迎访问我的个人博客。 对本文感兴趣的朋友请继续阅读从源码角度深入理解Glide（下） 参考链接 Gldie文档]]></content>
      <categories>
        <category>Android热门框架解析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
        <tag>Glide</tag>
        <tag>图片加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View 的滑动方式]]></title>
    <url>%2F2019%2F02%2F03%2FAndroid-View-%E7%9A%84%E6%BB%91%E5%8A%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 自定义View作为Android进阶的基础，是我们开发者不得不学习的知识，而酷炫的自定义View效果，都离不开View的滑动，所以接下来我们来一起探究View的滑动方式，看看View是如何滑动的，为Android进阶的道路打下基础。 View 坐标系基本知识 了解View的滑动方式，首先我们得了解View在什么位置，我们可以把手机屏幕区域看成是像数学中坐标系一样的区域，只不过是手机屏幕坐标系的Y轴和数学中的坐标系的Y轴正方向相反 确定View的位置主要是根据View的left、top、right、bottom四个属性来决定，需要注意的是View的这四个属性是相对于它的父容器来说的，所以对应为left是View的左上角相对于父容器的横坐标，top为纵坐标，right为View右下角相对于父容器的横坐标，bottom为纵坐标。（具体可以看下方示意图A） 12345//获取view位置的值left = View.getLeft();top = View.getTop();right = View.getRight();bottom = View.getBottom(); 除了上面确定View位置的参数，还有x，y，translationX，translationY这四个参数，x和y代表View的左上角的坐标值，而translationX，translationY是左上角坐标相对于View的父容器的偏移量，默认为零，也就是view不移动，则x和y等于left和top，他们换算关系可看下面示意图A，在View的滑动过程中，left和top表示的是View原始位置的值，这是不会改变的，所以改变的是滑动偏移量加上原始值得到新的左上角坐标。 当我们触摸屏幕，则可以通过点击事件来获取当前点击位置的值和相较于手机屏幕左上角的偏移量坐标（如上图B所示）。 Android View 的滑动方式layout方法改变View位置滑动View 首先我们看看layout()方法源码 12345678910@SuppressWarnings(&#123;"unchecked"&#125;)public void layout(int l, int t, int r, int b) &#123; //省略部分代码 ....... if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); //省略部分代码 ........ &#125; &#125; 了解过自定义View的各位应该都知道，onLayout()是View绘制过程中的一个方法，可以通过它确定View的位置，也就是说我们通过layout()方法可以改变View的位置，下面我们通过onLayout方法做一个可以随意滑动 view的例子 1234567891011121314151617181920212223@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; //获取触屏时候的坐标 Log.e("毛麒添","getLeft:"+getLeft()+"getTop:"+getTop()+"getRight:"+getRight()+"getBottom:"+getBottom()); x = event.getRawX(); y = event.getRawY(); switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_MOVE: //手指移动偏移量 int offsetX = (int) (x-lastX); int offsetY = (int) (y-lastY); layout(getLeft()+offsetX,getTop()+offsetY,getRight()+offsetX,getBottom()+offsetY); break; case MotionEvent.ACTION_UP: Log.e("毛麒添","getLeft:"+getLeft()+"getTop:"+getTop()+"getRight:"+getRight()+"getBottom:"+getBottom()); break; &#125; lastX=x; lastY=y; return super.onTouchEvent(event);&#125; 通过打印left，top，right，bottom数值可以发现layout方法是真实改变了View的位置而不只是View的内容。 offsetLeftAndRight()与offsetTopAndBottom() 方法改变View的位置让其滑动 修改上面的方法，效果图和onLayout一样，同时offsetLeftAndRight()与offsetTopAndBottom()方法也是真实改变了View的位置而不只是View的内容。1234567case MotionEvent.ACTION_MOVE: //手指移动偏移量 int offsetX = (int) (x-lastX); int offsetY = (int) (y-lastY); offsetLeftAndRight(offsetX); offsetTopAndBottom(offsetY); break; 使用scrollTo()和scrollBy()滑动View scrollTo()和scrollBy()是View提供的滑动方法，scrollTo()移动到某个某个点，scrollBy()表示根据传入的偏移量进行移动。先看源码实现 123456789101112131415161718192021222324252627282930/** * Set the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */ public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125; &#125;/** * Move the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y);&#125; 通过源码我们可以看到scrollBy()的实现其实是调用了scrollTo()方法。这里有个mScrollX和mScrollY的规则我们需要明白：scrollTo()中mScrollX的值等于view左边缘和view内容左边缘在水平方向的距离，并且当view的左边缘在view的内容左边缘右边时，mScrollX为正，反之为负；同理mScrollY等于view上边缘和view内容上边缘在竖直方向的距离，并且当view的上边缘在view的内容上边缘下边时，mScrollY为正，反之为负。当View没有使用scrollTo()和scrollBy()进行滑动的时候，mScrollX和mScrollY默认等于零，也就是view的左边缘与内容左边缘重合。 根据上面的规则，我们假设将view内容右下滑动，得到下图 结合上面的知识，我们将上面滑动的例子改写一下，如果使用scrollTo()则只是滑动到我们手指滑动偏移量的距离的点，达不到要求，而scrollBy()是在scrollTo()的基础上偏移滑动的位置，正好符合我们自由滑动的要求，并且根据上面的分析mScrollX和mScrollY为负值，则滑动偏移也应该为负值才能达到我们想要的自由滑动效果（这个大家需要自己好好想明白可能才会更加清楚理解） 1234567case MotionEvent.ACTION_MOVE: //手指移动偏移量 int offsetX = (int) (x-lastX); int offsetY = (int) (y-lastY); //滑动方式1 ((View)getParent()).scrollBy(-offsetX,-offsetY); break; 根据滑动打印的日志我们可以看出，scrollBy()和scrollTo()在滑动的过程中只是改变了View内容的位置，而没有改变初始的left，right，top，bottom的值 使用动画让View滑动xml补间动画的方式让View滑动 定义一个xml文件，500ms移动到500,500的位置并保持位置 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:fillAfter="true" android:duration="500"&gt; &lt;translate android:fromXDelta="0" android:fromYDelta="0" android:toXDelta="500" android:toYDelta="500"/&gt;&lt;/set&gt; 代码调用 1startAnimation(AnimationUtils.loadAnimation(mContext, R.anim.testscroll)); 补间对View的滑动也只是改变了View的显示效果，不会对View的属性做真正的改变，也就是说补间动画也没有真正改变View的位置 属性动画让View滑动 自从Android3.0开始加入了属性动画(了解属性动画可以查看郭霖大佬博客)，属性动画不仅能作用于View产生动画效果，也能作用于其他属性来产生动画效果，可以说属性动画相较于补间动画是非常灵活的，并且属性动画是真正改变View的位置属性。 属性动画一般我们使用ObjectAnimator，让View2秒时间水平平移到300位置，并且移动完后我们点击View看还能响应点击事件（如下图所示） 1ObjectAnimator.ofFloat(testScroll,"translationX",0,300).setDuration(2000).start(); 改变布局参数 LayoutParams 滑动View 平常我们开发设置View的位置可以在xml中设定，也可以在代码中设置。LayoutParams有一个View的所有布局参数信息，所有我们可以通过设置View的LayoutParams参数的leftMargin和topMargin达到上面自由滑动View的效果。 123456789101112131415161718 //省略部分代码 ...... case MotionEvent.ACTION_MOVE: //手指移动偏移量 int offsetX = (int) (x-lastX); int offsetY = (int) (y-lastY); //滑动方式5 moveView(offsetX,offsetY); break;//省略部分代码 ...... private void moveView(int offsetX, int offsetY) &#123; ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams(); layoutParams.leftMargin = getLeft() + offsetX; layoutParams.topMargin = getTop() + offsetY; setLayoutParams(layoutParams); &#125; 既然布局参数已经改变，则View的实际位置肯定也已经改变。 Scroller弹性滑动 首先我们要明白什么是Scroller？ Scroller是弹性滑动的帮助类，它本身并不能实现View的弹性滑动，它必须要配合scrollTo()或scrollBy()和实现View的computeScroll的方法才能实现View的弹性滑动 Scroller实现弹性滑动的典型例子1234567891011121314151617181920212223242526Scroller mScroller=new Scroller(context);public void smoothScrollTo(int desx,int desy)&#123;int scaleX = (int) getScaleX();int scaleY = (int) getScaleY();int deltaX = desx-scaleX;int deltaY = desy-scaleY;//3秒内弹性滑到desx desy 位置mScroller.startScroll(scaleX,scaleY,deltaX,deltaY,3000);//重新绘制界面 会调用computeScroll方法invalidate();&#125;@Overridepublic void computeScroll() &#123;super.computeScroll();if(mScroller.computeScrollOffset())&#123;//还没滑动到指定位置 ((View)getParent()).scrollTo(mScroller.getCurrX(),mScroller.getCurrY()); postInvalidate(); &#125;&#125;//拿到自定View的实例对象调用smoothScrollTo实现右下方向3秒//内到指定位置的弹性滑动//为什么是-300 请看scrollTo()或scrollBy()滑动解析testScroll.smoothScrollTo(-300,-300); Scroller弹性滑动源码分析 下面我们从源码角度来分析一下Scroller是如何实现弹性滑动的 先看startScroll()方法 12345678910111213141516171819202122232425262728293031323334353637/** * Start scrolling by providing a starting point, the distance to travel, * and the duration of the scroll. * * @param startX Starting horizontal scroll offset in pixels. Positive * numbers will scroll the content to the left. * @param startY Starting vertical scroll offset in pixels. Positive numbers * will scroll the content up. * @param dx Horizontal distance to travel. Positive numbers will scroll the * content to the left. * @param dy Vertical distance to travel. Positive numbers will scroll the * content up. * @param duration Duration of the scroll in milliseconds. */ public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123; mMode = SCROLL_MODE; mFinished = false; mDuration = duration; mStartTime = AnimationUtils.currentAnimationTimeMillis(); mStartX = startX; mStartY = startY; mFinalX = startX + dx; mFinalY = startY + dy; mDeltaX = dx; mDeltaY = dy; mDurationReciprocal = 1.0f / (float) mDuration; &#125; //View 中 computeScroll()方法没有实现内容，需要子View 自行实现 /** * Called by a parent to request that a child update its values for mScrollX * and mScrollY if necessary. This will typically be done if the child is * animating a scroll using a &#123;@link android.widget.Scroller Scroller&#125; * object. */ public void computeScroll() &#123; &#125; 通过源码我们看到startScroll()方法只是传递了我们传入的参数，滑动的起点startX、startY，滑动的距离dx、dy，和弹性滑动的时间，没看到有滑动的操作，那Scroller是如何让View滑动呢？而答案就是我们再调用startScroll()方法之后又调用了invalidate()方法，该方法会引起view的重绘，而View的重绘会调用computeScroll()方法，通过上面的源码，我们知道computeScroll()方法在view中是空实现，所以我们自己实现该放法的时候则调用scrollTo方法获取scrollX和scrollY当前让view进行滑动，但是这只是滑动一段距离，好像还没有弹性滑动，别急，我们看看Scroller的computeScrollOffset()方法 12345678910111213141516171819202122232425/** * Call this when you want to know the new location. If it returns true, * the animation is not yet finished. */ public boolean computeScrollOffset() &#123; if (mFinished) &#123; return false; &#125; int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime); if (timePassed &lt; mDuration) &#123; switch (mMode) &#123; case SCROLL_MODE: final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal); mCurrX = mStartX + Math.round(x * mDeltaX); mCurrY = mStartY + Math.round(x * mDeltaY); break; ....... &#125; &#125; else &#123; ....... &#125; return true;&#125; 通过computeScrollOffset()的源码，我们已经可以一目了然，根据时间流逝的百分比算出scrollX和scrollY改变的百分比并计算出他们的值，类似动画中的插值器的概念。每次重绘缓慢滑动一段距离，在一段时间内缓慢滑动就成了弹性滑动，就比scrollTo方法的一下滑动完舒服多了，我们还需要注意computeScrollOffset()的返回值，如果返回false表示滑动完了，true则表示没有滑动完。 这里我们梳理一下Scroller实现弹性滑动的工作原理：Scroller必须要配合scrollTo()或scrollBy()和实现View的computeScroll的方法才能实现View的弹性滑动，invalidate()引发第一次重绘，重绘距离滑动开始时间有一个时间间隔，在这个时间间隔中获取View滑动的位置，通过scrollTo()进行滑动，滑动完postInvalidate()再次进行重绘，没有滑动完则继续上面的操作，最终组成弹性滑动。 最后说点 到此，View的滑动方式就已经了解完了。如果文章中有写得不对的地方，请给我留言指出，大家一起学习进步。如果觉得我的文章给予你帮助，也请给我一个喜欢和关注。 测试Demo地址 参考链接 Android 源码View Android 源码Scroller 参考书籍 《Android开发艺术探索》 《Android进阶之光》]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View体系</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从源码角度深入理解Retrofit2]]></title>
    <url>%2F2019%2F01%2F31%2F%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit2%2F</url>
    <content type="text"><![CDATA[Retrofit2作为目前最火的网络请求框架之一，它是一个由Square组织开发的可以在Android和java中使用的安全型HTTP客户端（官方文档描述“Type-safe HTTP client for Android and Java by Square”）。本文将从Retrofit2简单使用入手，在对其源码进行分析来深入理解Retrofit2（基于2.5.0版本）。 Retrofit2简单使用 1.1 下面，根据官方例子，简单使用一个get请求来演示Retrofit2简单使用。首先gradle中添加retrofit依赖，创建一个描述每一个请求的接口 1234567891011121314 /** * gradle中添加依赖 */ implementation 'com.squareup.retrofit2:retrofit:2.5.0'public interface GitHub &#123;public static final String API_URL = "https://api.github.com";//使用Get 请求@GET("/repos/&#123;owner&#125;/&#123;repo&#125;/contributors")Call&lt;List&lt;SimpleService.Contributor&gt;&gt; contributors( @Path("owner") String owner, @Path("repo") String repo);&#125; 1.2 创建网络请求数据bean对象 1234567891011public class SimpleService &#123;public static class Contributor &#123; public final String login; public final int contributions; public Contributor(String login, int contributions) &#123; this.login = login; this.contributions = contributions; &#125; &#125;&#125; 1.3 创建retrofit对象，传入网络请求的域名地址，传入刚刚创建的请求对象接口，而我们的网络请求默认返回JSON数据，而retrofit请求默认返回response.body()（异步请求），所以我们需要添加一个GsonConverterFactory转换器将JSON转化为我们的bean对象，需要在gradle中添加如下库的依赖 1234567891011121314/** * gradle中添加依赖 */implementation 'com.squareup.retrofit2:converter-gson:2.5.0' // Create a very simple REST adapter which points the GitHub API. Retrofit retrofit=new Retrofit.Builder() .baseUrl(GitHub.API_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); // Create an instance of our GitHub API interface. GitHub gitHub = retrofit.create(GitHub.class); // Create a call instance for looking up Retrofit contributors. final retrofit2.Call&lt;List&lt;SimpleService.Contributor&gt;&gt; call = gitHub.contributors("square", "retrofit"); 1.4 根据上一步拿到的call对象执行同步网络请求获取数据，耗时操作开启子线程执行 12345678910111213141516new Thread()&#123; @Override public void run() &#123; super.run(); /** * 同步请求 try &#123; List&lt;SimpleService.Contributor&gt; contributors = call.execute().body(); for (SimpleService.Contributor contributor : contributors) &#123; Log.e("maoqitian","Retrofit同步请求返回参数"+contributor.login + " (" + contributor.contributions + ")"); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); 1.5 根据上一步拿到的call对象执行异步网络请求获取数据 1234567891011121314call.enqueue(new retrofit2.Callback&lt;List&lt;SimpleService.Contributor&gt;&gt;() &#123; @Override public void onResponse(retrofit2.Call&lt;List&lt;SimpleService.Contributor&gt;&gt; call, retrofit2.Response&lt;List&lt;SimpleService.Contributor&gt;&gt; response) &#123; List&lt;SimpleService.Contributor&gt; body = response.body(); for (SimpleService.Contributor contributor : body) &#123; Log.e("maoqitian","Retrofit异步请求返回参数"+contributor.login + " (" + contributor.contributions + ")"); &#125; &#125; @Override public void onFailure(retrofit2.Call&lt;List&lt;SimpleService.Contributor&gt;&gt; call, Throwable t) &#123; Log.e("maoqitian","Retrofit异步请求失败"+t.getMessage()); &#125; &#125;); 源码分析retrofit2网络请求基本流程图 根据上面的简单使用retrofit的例子，我们可以概括一下大致流程图 retrofit对象创建 我们先了解retrofit对象包含了哪些成员变量以及他们的含义和作用 1234567891011121314//ServiceMethod 的缓存，从接口中解析出来，放在这个 map 里面。private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();//okhttp3.Call.Factory接口对象，接口声明了newCall方法final okhttp3.Call.Factory callFactory;//OKHttp3 的HttpUrl 对象，描述了一个 http 地址 final HttpUrl baseUrl;//保存ConverterFactory转换器的list，通过Retrofit.Builder的 addConverterFactory方法来添加final List&lt;Converter.Factory&gt; converterFactories;//保存CallAdapterFactory适配器的list，通过Retrofit.Builder的 addCallAdapterFactory方法来添加final List&lt;CallAdapter.Factory&gt; callAdapterFactories;//回调函数的执行器，也就是回调函数执行的线程，Android 中默认为 MainThreadExecutorfinal @Nullable Executor callbackExecutor;//创建动态代理对象之前，是否提前解析接口 Method，创建 ServiceMethod 并添加到 Cache 中。final boolean validateEagerly; 接着就是创建Retrofit对象new Retrofit.Builder()，一看到Builder我们就可以想到构造者模式，通过外部对各个参数的配置来尽可能的达到各种业务请求场景的要求。先看看Builder()中的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** Retrofit的 Builder方法*/public Builder() &#123; this(Platform.get());&#125;/**Platform类中的get方法*/static Platform get() &#123;return PLATFORM;&#125;private static final Platform PLATFORM = findPlatform();/**Platform类中的findPlatform方法*/private static Platform findPlatform() &#123;try &#123; Class.forName("android.os.Build"); if (Build.VERSION.SDK_INT != 0) &#123; return new Android(); &#125;&#125; catch (ClassNotFoundException ignored) &#123;&#125;try &#123; Class.forName("java.util.Optional"); return new Java8();&#125; catch (ClassNotFoundException ignored) &#123;&#125;return new Platform();&#125;/**Platform类中的Android方法*/static class Android extends Platform &#123;@IgnoreJRERequirement // Guarded by API check.@Override boolean isDefaultMethod(Method method) &#123; if (Build.VERSION.SDK_INT &lt; 24) &#123; return false; &#125; return method.isDefault();&#125;@Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor();&#125;@Override List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories( @Nullable Executor callbackExecutor) &#123; if (callbackExecutor == null) throw new AssertionError(); ExecutorCallAdapterFactory executorFactory = new ExecutorCallAdapterFactory(callbackExecutor); return Build.VERSION.SDK_INT &gt;= 24 ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory) : singletonList(executorFactory);&#125;@Override int defaultCallAdapterFactoriesSize() &#123; return Build.VERSION.SDK_INT &gt;= 24 ? 2 : 1;&#125;@Override List&lt;? extends Converter.Factory&gt; defaultConverterFactories() &#123; return Build.VERSION.SDK_INT &gt;= 24 ? singletonList(OptionalConverterFactory.INSTANCE) : Collections.&lt;Converter.Factory&gt;emptyList();&#125;@Override int defaultConverterFactoriesSize() &#123; return Build.VERSION.SDK_INT &gt;= 24 ? 1 : 0;&#125;static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125;&#125; 由上述源码可以看到，Retrofit的builder方法中调用了Platform.get()方法，最终调用的是findPlatform()，该方法使用反射判断当前的环境来得到不同的Platform对象，接着回到Retrofit的build方法 12345678910111213141516171819202122232425262728293031323334/** Retrofit的 build方法*/public Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException("Base URL required."); &#125; okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories); callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;( 1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize()); // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); converterFactories.addAll(this.converterFactories); converterFactories.addAll(platform.defaultConverterFactories()); return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly); &#125;&#125; 可以看到build方法中callFactory就是OkHttpClient对象，也就是Retrofit的网络请求也是通过OKHttp来完成的；在Android环境中，build中platform调用的方法都是前面提到的Platform的继承类Android中实现的方法，callbackExecutor在主线程执行，默认加载的CallAdapter.Factory为ExecutorCallAdapterFactory，如果Build.VERSION.SDK_INT &gt;= 24(Android 7.0)，则Converter.Factory默认为OptionalConverterFactory，否则为空。最终新建retrofit对象并将设置和默认的参数传入。 retrofit.create(class) 创建了retrofit对象之后，接着调用了retrofit的create方法，先看看该方法的实现 123456789101112131415161718192021222324/**Retrofit类的create方法*/public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;Utils.validateServiceInterface(service);if (validateEagerly) &#123; eagerlyValidateMethods(service);&#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); &#125; &#125;); &#125; 看到retrofit的create方法，代码很少，看到关键代码Proxy，我们就可以知道这里使用了Java的动态代理，为了方便下面代码的解读，我们先来简单了解什么是动态代理。 代理模式 代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。而代理分为动态代理和静态代理，静态代理中每一个需要被代理的类都要创建一个代理类，这显然很麻烦，所以Java给我们提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy 的类来支持动态代理 1234567891011//Object proxy:被代理的对象 //Method method:要调用的方法 //Object[] args:方法调用时所需要参数 public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; &#125; //CLassLoader loader:类的加载器 //Class&lt;?&gt; interfaces:得到全部的接口 //InvocationHandler h:得到InvocationHandler接口的子类的实例 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 更详细动态代理知识可以自行了解 现在我们回过头看retrofit的create方法，Proxy.newProxyInstance方法加载了我们的网络请求描述接口类和其中定义的方法，并实现了InvocationHandler接口，也就是说create方法实现了动态代理，则调用create方法，也就会调用InvocationHandler接口实现的invoke方法。 在InvocationHandler接口实现的invoke方法中，如果是 Object对象本身方法（比如equals、toString、hashCode等）以及 Platform 默认的方法（java8默认方法，1.8的新特性），则在正常使用的时候调用返回，如果不满足，最后调用 loadServiceMethod(method)方法，也就是该方法来解析对应接口中我们定义的描述网络请求的方法。解析描述网络请求接口 上一小节我们说到loadServiceMethod(method)方法解析对应接口 1234567891011121314/**Retrofit类的loadServiceMethod方法 */ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123; ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; result = ServiceMethod.parseAnnotations(this, method); serviceMethodCache.put(method, result); &#125; &#125;return result;&#125; 通过该方法，解析接口之后返回的对象是ServiceMethod，如果之前解析过，则直接从serviceMethodCache取出直接返回，否则调用ServiceMethod.parseAnnotations方法进行解析 123456789101112131415/**ServiceMethod&lt;T&gt; 抽象类的parseAnnotations方法**/static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) &#123;RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method); Type returnType = method.getGenericReturnType(); if (Utils.hasUnresolvableType(returnType)) &#123; throw methodError(method, "Method return type must not include a type variable or wildcard: %s", returnType); &#125; if (returnType == void.class) &#123; throw methodError(method, "Service methods cannot return void.");&#125; return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);&#125; 如上源码，RequestFactory负责解析接口并且生成Request，继续看RequestFactory的 parseAnnotations方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 /**RequestFactory 类的parseAnnotations方法**/ static RequestFactory parseAnnotations(Retrofit retrofit, Method method) &#123; return new Builder(retrofit, method).build(); &#125; /**RequestFactory 类的build方法**/ RequestFactory build() &#123; for (Annotation annotation : methodAnnotations) &#123; //解析网络请求方法注解 parseMethodAnnotation(annotation); &#125; //省略部分代码 ...... int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; //方法参数注解的解析 parameterHandlers[p] = parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p]); &#125; //省略部分代码 ....... return new RequestFactory(this);&#125;/**RequestFactory 类的parseMethodAnnotation方法**/private void parseMethodAnnotation(Annotation annotation) &#123; if (annotation instanceof DELETE) &#123; parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false); &#125; else if (annotation instanceof GET) &#123; parseHttpMethodAndPath("GET", ((GET) annotation).value(), false); //剩余其他请求方法注解解析 ...... isFormEncoded = true; &#125;&#125;/**RequestFactory 类的parseHttpMethodAndPath方法**/private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) &#123; if (this.httpMethod != null) &#123; throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.", this.httpMethod, httpMethod); &#125; this.httpMethod = httpMethod; this.hasBody = hasBody; if (value.isEmpty()) &#123; return; &#125; // Get the relative URL path and existing query string, if present. int question = value.indexOf('?'); if (question != -1 &amp;&amp; question &lt; value.length() - 1) &#123; // Ensure the query string does not have any named parameters. String queryParams = value.substring(question + 1); Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams); if (queryParamMatcher.find()) &#123; throw methodError(method, "URL query string \"%s\" must not have replace block. " + "For dynamic query parameters use @Query.", queryParams); &#125; &#125; this.relativeUrl = value; this.relativeUrlParamNames = parsePathParameters(value);&#125;/**RequestFactory 类的parsePathParameters方法**/static Set&lt;String&gt; parsePathParameters(String path) &#123; Matcher m = PARAM_URL_REGEX.matcher(path); Set&lt;String&gt; patterns = new LinkedHashSet&lt;&gt;(); while (m.find()) &#123; patterns.add(m.group(1)); &#125; return patterns;&#125; 在解析网络请求注解的方法parseMethodAnnotation中，通过instanceof判断描述网络请求接口的注解中是否包含对应网络请求类型，如果包含则调用parseHttpMethodAndPath设置httpMethod网络请求方法（get），联系到上面的简单例子，相对url(对应/repos/{owner}/{repo}/contributors)，hasBody在get请求中没有，在post请求中为post的参数体，relativeUrlParamNames（对应owner、repo）为相对路径中需要外部传递参数占位符名称，通过正则表达式获取。 上面我们的分析中只是解析了网络请求注解，还需要解析接口方法参数的注解，看到RequestFactory的parseAnnotations方法中的parseParameter方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/**RequestFactory 类的parseParameter方法**/private ParameterHandler&lt;?&gt; parseParameter( int p, Type parameterType, @Nullable Annotation[] annotations) &#123; ParameterHandler&lt;?&gt; result = null; if (annotations != null) &#123; for (Annotation annotation : annotations) &#123; ParameterHandler&lt;?&gt; annotationAction = parseParameterAnnotation(p, parameterType, annotations, annotation); //省略部分代码 .... &#125; &#125; return result;&#125; /**RequestFactory 类的parseParameterAnnotation方法**/@Nullableprivate ParameterHandler&lt;?&gt; parseParameterAnnotation( int p, Type type, Annotation[] annotations, Annotation annotation) &#123; //省略部分代码 ....... else if (annotation instanceof Path) &#123; validateResolvableType(p, type); //各种检查判断 ..... gotPath = true; Path path = (Path) annotation; String name = path.value(); validatePathName(p, name); Converter&lt;?, String&gt; converter = retrofit.stringConverter(type, annotations); return new ParameterHandler.Path&lt;&gt;(name, converter, path.encoded()); &#125; //省略代码 ...... &#125; /**ParameterHandler 类的Path实现**/ static final class Path&lt;T&gt; extends ParameterHandler&lt;T&gt; &#123; //省略代码 ...... @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException &#123; if (value == null) &#123; throw new IllegalArgumentException( "Path parameter \"" + name + "\" value must not be null."); &#125; builder.addPathParam(name, valueConverter.convert(value), encoded); &#125;&#125;/**RequestBuilder 类的addPathParam方法**/void addPathParam(String name, String value, boolean encoded) &#123; if (relativeUrl == null) &#123; // The relative URL is cleared when the first query parameter is set. throw new AssertionError(); &#125;String replacement = canonicalizeForPath(value, encoded);String newRelativeUrl = relativeUrl.replace("&#123;" + name + "&#125;", replacement);if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) &#123; throw new IllegalArgumentException( "@Path parameters shouldn't perform path traversal ('.' or '..'): " + value); &#125; relativeUrl = newRelativeUrl;&#125; 由上源码（源码较多，截取Path注解处理原理），RequestFactory 类的parseParameter方法通过遍历参数注解，调用parseParameterAnnotation方法获取了注解中定义的参数值（path.value()），最后返回了new ParameterHandler.Path&lt;&gt;对象，在ParameterHandler类的Path实现中调用RequestBuilder类（创建请求）的addPathParam方法最终将相对路径relativeUrl的占位符通过描述网络请求接口方法传递的参数替换掉得到正确的相对路径relativeUrl。而得到正确相对路径的RequestBuilder对象创建则在RequestFactory类的create方法中。 调用接口中的方法返回Call对象 现在我们再次回到ServiceMethod的parseAnnotations方法，经过上面2.4小节的分析我们已经得到了解析到正确相对路径的RequestFactory对象，最终该方法调用了HttpServiceMethod.parseAnnotations() 1234567891011121314151617181920212223242526/** * Inspects the annotations on an interface method to construct a reusable service method that * speaks HTTP. This requires potentially-expensive reflection so it is best to build each service * method only once and reuse it. * HttpServiceMethod的parseAnnotations方法 */ static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) &#123; //最终通过retrofit对象拿到默认CallAdapter.Factory对象（ExecutorCallAdapterFactory） CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method); Type responseType = callAdapter.responseType(); if (responseType == Response.class || responseType == okhttp3.Response.class) &#123; throw methodError(method, "'" + Utils.getRawType(responseType).getName() + "' is not a valid response body type. Did you mean ResponseBody?"); &#125; if (requestFactory.httpMethod.equals("HEAD") &amp;&amp; !Void.class.equals(responseType)) &#123; throw methodError(method, "HEAD method must use Void as response type."); &#125; //最终通过retrofit拿到设置的Converter.Factory对象（我们设置了GsonConverterFactory） Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType); okhttp3.Call.Factory callFactory = retrofit.callFactory; return new HttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter);&#125; 通过该方法源码，首先我们可以知道最刚开始我们分析retrofit的create方法中loadServiceMethod(method)方法实际上就是HttpServiceMethod对象，接着继续看parseAnnotations方法中的createCallAdapter方法 1234567891011121314151617181920212223242526272829303132/**HttpServiceMethod 类的createCallAdapter方法**/private static &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt; createCallAdapter( Retrofit retrofit, Method method) &#123;Type returnType = method.getGenericReturnType();Annotation[] annotations = method.getAnnotations(); try &#123; //noinspection unchecked return (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations); &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code. throw methodError(method, e, "Unable to create call adapter for %s", returnType); &#125;&#125; /**Retrofit 类的callAdapter方法**/ public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123; return nextCallAdapter(null, returnType, annotations); &#125; /**Retrofit 类的nextCallAdapter方法**/ public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) &#123;checkNotNull(returnType, "returnType == null");checkNotNull(annotations, "annotations == null");int start = callAdapterFactories.indexOf(skipPast) + 1;for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123; CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this); if (adapter != null) &#123; return adapter; &#125; &#125; //省略部分代码 ......&#125; 由上源码HttpServiceMethod通过自身createCallAdapter调用Retrofit 类的callAdapter方法，而Retrofit 类的callAdapter方法又调用 Retrofit 类的nextCallAdapter方法遍历callAdapterFactories来得到CallAdapter.Factory对象；前面我们分析retrofit对象创建时已经说过Platform对象中提供了默认的CallAdapter.Factory对象为ExecutorCallAdapterFactory，该对象也就是HttpServiceMethod的createCallAdapter方法得到的CallAdapter.Factory对象。同理，HttpServiceMethod的createResponseConverter最终通过retrofit的nextResponseBodyConverter方法得到了Converter（GsonRequestBodyConverter）对象（我们设置了GsonConverterFactory.responseBodyConverter的方法创建了该对象），这里就不贴代码了。 接着上面的分析，我们在代理的invoke方法中返回了loadServiceMethod(method).invoke(args != null ? args : emptyArgs)这一句代码，当retrofit.create生成的的接口对象调用其中的接口的方法，则会触发动态代理执行invoke方法，最终返回loadServiceMethod(method).invoke，也就是执行了HttpServiceMethod.ivnoke方法 12345 /**HttpServiceMethod 类的invoke方法**/@Override ReturnT invoke(Object[] args) &#123;return callAdapter.adapt( new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));&#125; 可以看到HttpServiceMethod类的invoke方法中调用了callAdapter.adapt，而这个callAdapter经过我们前面的分析已经知道是默认添加的ExecutorCallAdapterFactory对象，继续看ExecutorCallAdapterFactory对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 /**ExecutorCallAdapterFactory 类**/ final class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor; ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; @Override public @Nullable CallAdapter&lt;?, ?&gt; get( Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; final Type responseType = Utils.getCallResponseType(returnType); return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; /**ExecutorCallbackCall 类**/ static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; final Call&lt;T&gt; delegate; ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, "callback == null"); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;); &#125;//省略代码......@Override public Response&lt;T&gt; execute() throws IOException &#123; return delegate.execute();&#125; //省略代码......&#125; 通过ExecutorCallAdapterFactory的源码应该会有一种让你恍然大悟的感觉 1.通过ExecutorCallAdapterFactory的adapt方法，我们我们已经得到了Call对象，它就是ExecutorCallbackCall 2.ExecutorCallbackCall的enqueue方法执行在主线程，callbackExecutor就是Platfrom默认添加的MainThreadExecutor（Android环境中），所以callback.onResponse中随意更新UI 3.delegate对象就是OkHttpCall对象，所以我们Call执行的enqueue和execute方法都是OkHttpCall对象对象的enqueue和execute方法。Retrofit中的适配器模式和装饰模式 适配器模式做为两个不同的接口之间的桥梁，使得Retrofit2.Call接口可以使用OKHttp.Call的实现来执行网络请求，而适配器就是CallAdapter.Factory 装饰模式在不改变原有类的基础上进行扩展，也就是ExecutorCallbackCall，对OKHttp.Call进行装饰，本身它执行enqueue方法是在子线程中，而ExecutorCallbackCall对其装饰让其返回值执行在主线程中。 下面通过一张图来帮助理解 Call对象执行网络请求 通过上一小节的分析，我们来看看OkHttpCall对象是如何执行网络请求的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 /*OkHttpCall类的enqueue方法*/ @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, "callback == null"); okhttp3.Call call; Throwable failure; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already executed."); executed = true; call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) &#123; try &#123; call = rawCall = createRawCall(); &#125; catch (Throwable t) &#123; throwIfFatal(t); failure = creationFailure = t; &#125; &#125;&#125; if (failure != null) &#123; callback.onFailure(this, failure); return; &#125; if (canceled) &#123; call.cancel(); &#125; call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123; Response&lt;T&gt; response; try &#123; response = parseResponse(rawResponse); &#125; catch (Throwable e) &#123; throwIfFatal(e); callFailure(e); return; &#125; try &#123; callback.onResponse(OkHttpCall.this, response); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; callFailure(e); &#125; private void callFailure(Throwable e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; &#125;); &#125;/*OkHttpCall类的execute方法*/@Override public Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already executed."); executed = true; //省略部分代码 ....... call = rawCall; if (call == null) &#123; try &#123; call = rawCall = createRawCall(); &#125; catch (IOException | RuntimeException | Error e) &#123; //省略部分代码 ....... &#125; return parseResponse(call.execute()); &#125; 通过以上源码，我们可以看到执行完全请求的是okhttp3.Call对象，也就是说retrofit的网络请求时由OKHttp3来完成的，继续看得到okhttp3.Call对象的createRawCall()方法 12345678910111213141516171819 /*OkHttpCall类的createRawCall方法*/ private okhttp3.Call createRawCall() throws IOException &#123; okhttp3.Call call = callFactory.newCall(requestFactory.create(args)); if (call == null) &#123; throw new NullPointerException("Call.Factory returned null."); &#125; return call; &#125;/*retrofit类的build方法*/ public Retrofit build() &#123; okhttp3.Call.Factory callFactory = this.callFactory; //省略部分代码 ....... if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; //省略部分代码 ....... &#125; 通过OkHttpCall类的createRawCall方法和retrofit类的build方法，callFactory.newCall，也就是OkHttpClient.nawCall，而requestFactory.create()返回的就是OKHttp的 request 对象，经过前面的分析，RequestFactory解析好的请求数据传递给了OkHttpClient。 关于OkHttpClient是如何执行网络请求的可以看我之前的一篇文章 从源码角度深入理解OKHttp3 Converter对象转换网络请求成功返回数据 通过上一小节，我们已经通过OkHttp进行了实际的网络请求，请求成功的数据根据之前新建Retrofit对象的时候我们指定了GsonConverterFactory，并在HttpServiceMethod通过createResponseConverter方法得到了GsonResponseBodyConverter对象（可以查看2.5小节分析）。 请求成功返回的数据会经过OkHttpCall类的parseResponse方法进行处理 1234567891011121314151617181920212223242526272829303132333435363738394041 /*OkHttpCall类的parseResponse方法*/ Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); // Remove the body's source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build();//省略部分代码 ....... ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody); try &#123; T body = responseConverter.convert(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; //省略部分代码 ....... &#125;&#125;/* GsonResponseBodyConverter类*/final class GsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123;private final Gson gson;private final TypeAdapter&lt;T&gt; adapter;GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;this.gson = gson;this.adapter = adapter; &#125; @Override public T convert(ResponseBody value) throws IOException &#123; JsonReader jsonReader = gson.newJsonReader(value.charStream()); try &#123; T result = adapter.read(jsonReader); if (jsonReader.peek() != JsonToken.END_DOCUMENT) &#123; throw new JsonIOException("JSON document was not fully consumed."); &#125; return result; &#125; finally &#123; value.close(); &#125; &#125;&#125; 通过以上源码可以看到通过Retrofit对象指定GsonConverterFactory后得到的GsonResponseBodyConverter的对象帮我们把Json数据通过Gson处理成我们指定的bean对象，很方便。到此，retrofit的源码分析就结束了。 最后通过一张类之间调用流程图来帮助更好理解retrofit源码 最后说点 Retrofit整个框架源码量其实不算太多，其中巧妙的运用设计模式来完成整个框架设计。静下心来阅读源码对自己的提升还是很有帮助的。由于本人水平有限，文章中如果有错误，请大家给我提出来，大家一起学习进步，如果觉得我的文章给予你帮助，也请给我一个喜欢和关注。 参考链接 Retrofit分析-经典设计模式案例 官方文档]]></content>
      <categories>
        <category>Android热门框架解析</category>
      </categories>
      <tags>
        <tag>Retrofit2</tag>
        <tag>HTTP</tag>
        <tag>OKHttp3</tag>
        <tag>源码分析</tag>
        <tag>代理模式</tag>
        <tag>配器模式</tag>
        <tag>装饰模式</tag>
        <tag>构造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Android事件分发机制]]></title>
    <url>%2F2019%2F01%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在理解事件分发机制之前，我们先要明白，事件分发机制是为View服务的，而View是Android中所有控件的基类，View可以是单个的，而多个View组成可以叫做ViewGroup。不管什么View控件，他们基类都是View，在Android多个View的叠加有点像Web中的DOM树形结构，所以当我们点击一个区域有多个View的情况下，到底这时候该哪个View来响应我们的点击事件呢？事件分发机制就是为了解决这个问题而产生的。 事件 理解事件分发机制，首先我们要了解事件是什么，这里事件主要指我们操作手机的触摸事件。在Android中所有的输入事件都放在了MotionEvent中。 MotionEvent是个很庞大的东西，有单点触控、多点触控、鼠标事件等等，这里简单列出基本的单点事件，不做更多深入讨论。 事件 简介 ACTION_DOWN 手指初次接触到屏幕时触发 ACTION_MOVE 手指在屏幕上滑动时触发，会会多次触发 ACTION_UP 手指离开屏幕时触发 ACTION_CANCEL 事件被上层拦截时触发 正常情况下触摸一次屏幕触发事件序列为ACTION_DOWN–&gt;ACTION_UP 有滑动动作的单点序列为ACTION_DOWN–&gt;ACTION_MOVE ….. ACTION_MOVE–&gt;ACTION_UP 点击事件分发流程事件分发机制场景例子 首先我们来看一个比较有意思的例子来带入，我们定义一个公司的几个角色 老板（Activity） 12345678910111213141516171819202122232425262728/** * Created by maoqitian on 2018/5/10 0010. * 事件分发机制测试 老板 */ public class DispatchTouchEventTestActivity extends AppCompatActivity &#123; private static final String TAG = Action.TAG1; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dispatch_touch_event_test); &#125; //Actiivty 只有 dispatchTouchEvent 和 onTouchEvent 方法 @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN)&#123; Log.i(TAG,Action.dispatchTouchEvent+"经理,现在项目做到什么程度了?"); &#125; return super.dispatchTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN)&#123; Log.i(TAG, Action.onTouchEvent); &#125; return super.onTouchEvent(event); &#125; 经理（RootView） 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 经理 */public class RootView extends RelativeLayout &#123;private static final String TAG = Action.TAG2; public RootView(Context context) &#123; super(context); &#125; public RootView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public RootView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; Log.i(TAG, Action.dispatchTouchEvent + "技术部,你们的app快做完了么?"); &#125; return super.dispatchTouchEvent(ev); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; Action.onInterceptTouchEvent+"老板问项目进度" ); &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; Log.i(TAG, Action.onTouchEvent +"....."); &#125; return super.onTouchEvent(event); &#125; &#125; 组长（ViewGroup） 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 组长 */ public class ViewGroupA extends RelativeLayout &#123; private static final String TAG = Action.TAG3; public ViewGroupA(Context context) &#123; super(context); &#125; public ViewGroupA(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public ViewGroupA(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; Log.i(TAG, Action.dispatchTouchEvent + "项目进度?"); &#125; return super.dispatchTouchEvent(ev); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; Log.i(TAG, Action.onInterceptTouchEvent + "我问问程序员"); &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; Log.i(TAG, Action.onTouchEvent); &#125; return super.onTouchEvent(event); &#125; &#125; 程序员（View1） 123456789101112131415161718192021222324252627282930313233/** * 码农 */ public class View1 extends View &#123; private static final String TAG = Action.TAG4; public View1(Context context) &#123; super(context); &#125; public View1(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public View1(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; //View最为事件传递的最末端，要么消费掉事件，要么不处理进行回传，根本没必要进行事件拦截 @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; Log.i(TAG, Action.dispatchTouchEvent+"app完成进度么？"); &#125; return super.dispatchTouchEvent(event); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; Log.i(TAG, Action.onTouchEvent+"做好了."); &#125; return true; &#125; &#125; 扫地阿姨（View2） 123456789101112131415161718192021222324252627282930313233/** * 扫地阿姨 */ public class View2 extends View &#123; private static final String TAG = Action.TAG5; public View2(Context context) &#123; super(context); &#125; public View2(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public View2(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; if(event.getAction() == MotionEvent.ACTION_DOWN)&#123; Log.i(TAG, Action.dispatchTouchEvent+"我只是个扫地阿姨，我不懂你说什么"); &#125; return super.dispatchTouchEvent(event); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; Log.i(TAG, Action.onTouchEvent+"经理你问错人了，去问老板吧"); &#125; return super.onTouchEvent(event); &#125; &#125; 场景一：老板询问App项目进度，事件经过每个领导传递到达程序员处，程序员完成了项目（点击事件被View1消费了） 场景二 ：老板异想天开，想造宇宙飞船，事件经过每个领导传递到达程序员处，程序员表示做不了，反馈给老板（事件没有被消费）1234567 @Overridepublic boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; Log.i(TAG, Action.onTouchEvent+"这个真心做不了啊，把我做了吧"); &#125; return super.onTouchEvent(event);&#125; 场景三：老板询问技术部本月表现，只需要组长汇报就行，不需要通知程序员（ViewGroup 拦截并消费了事件）123456789101112131415 @Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; Log.i(TAG, Action.onInterceptTouchEvent + "我看看组员绩效情况"); &#125; //return super.onInterceptTouchEvent(ev); return true;//拦截事件 onTouchEvent 中进行处理&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; Action.onTouchEvent+"技术部组员最近表现都很好,项目按时完成，没有迟到早退"); &#125; return true;//消费事件 &#125; 事件分发机制的三个重要方法 从这三个场景我们可看出事件分发机制主要有三个方法来处理public boolean dispatchTouchEvent(MotionEvent ev) 该方法的作用是事件的分发，返回结果表示是否消耗事件，消耗则会调用当前View的onTouchEvent，否则传递事件，调用子View的dispatchTouchEvent方法，只要时间传递到该View，dispatchTouchEvent方法必定是会被首先调用的。public boolean onInterceptTouchEvent(MotionEvent ev) 该方法表示是否对分发的事件进行拦截，如果进行了拦截，则该方法在这一次的时间传递序列中奖不会被再调用，该方法在dispatchTouchEvent被调用，我们需要注意一点，View是没有该方法的，View是单个的，我们可以理解它为事件传递的终点，终点要么消费事件，要么不消费事件把事件进行回传，而ViewGroup则包含不止一个View，所以他可以把时间传递给子View，也可以拦截事件自己处理不传递给子View。 public boolean onTouchEvent(MotionEvent event) 该方法表示处理拦截的事件，如果不进行处理（事件消耗），也就是不反回true，则当前View不会再次接收到该事件 三个方法之间的关系123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean isDispatch; if(onInterceptTouchEvent(ev))&#123; isDispatch=onTouchEvent(ev); &#125;else &#123; isDispatch=childView.dispatchTouchEvent(ev); &#125; return isDispatch;&#125; 结合这段伪代码和前面的例子的场景三，我们可以发现ViewGroup的事件分发规则是这样的，时间传递到ViewGroup首先调用它的dispatchTouchEvent方法，接下来是调用onInterceptTouchEvent方法，如果该方法但会true，则说明当前ViewGroup要拦截该事件，拦截之后则调用当前ViewGroup的onTouchEvent方法，如果不进行拦截则调用子View的dispatchTouchEvent方法，结合场景二，如果到最后事件都没有被消费掉，则最后返回Activity，Activity不处理则事件消失。 结合场景一、场景二，View接收到事件，如果进行处理，则直接在onTouchEvent进行处理返回true就表示事件被消费了，不进行处理则调用父类onTouchEvent方法或者返回false表示不消费该事件，然后事件再原路返回向上传递。Activity 传递事件 前面我们只是描述了ViewGroup和View之间的时间传递，我们看到例子中的场景事件都是从老板（Activity）开始的，而Activity本身并不是继承View，所以我们需要了解Activity是如何把事件传递到View的，从源码的角度来看是比较清晰的，下面一起来看看。 Activity 本身并不是View，那他去哪里加载View呢？setContentView()这个方法相信大家都不陌生，他加载我们的布局，布局中包括控件，也就是加载我们的View， 12345678910111213/** * Set the activity content from a layout resource. The resource will be * inflated, adding all top-level views to the activity. * * @param layoutResID Resource ID to be inflated. * * @see #setContentView(android.view.View) * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams) */ public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar(); &#125; 我们可以看到调用的是 getWindow().setContentView(layoutResID)这个方法，继续找getWindow() 1234567891011/** * Retrieve the current &#123;@link android.view.Window&#125; for the activity. * This can be used to directly access parts of the Window API that * are not available through Activity/Screen. * * @return Window The current window, or null if the activity is not * visual. */ public Window getWindow() &#123; return mWindow; &#125; getWindow()方法返回的是mWindow，继续找mWindow对象，发现在Activity中定义的是Window对象 1private Window mWindow; 查看Window源码，注释说得非常清楚，Window的唯一实现类是PhoneWindow 123456789/** * &lt;p&gt;The only existing implementation of this abstract class is * android.view.PhoneWindow, which you should instantiate when needing a * Window. */ public abstract class Window &#123; //省略部分代码 ... &#125; 在Activity源码的attch()方法中我们也看到 mWindow 的实例对象确实是PhoneWindow 12345678910final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) &#123; ..... mWindow = new PhoneWindow(this, window, activityConfigCallback); ......&#125; 所以我们继续看PhoneWindow，这时必须要记住，我们还在找setContentView()方法，PhoneWindow的setContentView()方法 123456789101112131415161718192021222324@Overridepublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 该方法中我们重点看installDecor()方法 123456789101112131415161718private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; else &#123; mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); ....... &#125; ....... &#125; 好像没发现什么，继续看generateDecor(int featureId)方法 12345678protected DecorView generateDecor(int featureId) &#123; // System process doesn't have application context and in that case we need to directly use // the context we have. Otherwise we want the application context, so we don't cling to the // activity. Context context; ...... return new DecorView(context, featureId, this, getAttributes());&#125; 到此我们发现，他返回的是DecorView，DecorView是PhoneWindow的内部类，我们再看generateLayout(mDecor)方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465protected ViewGroup generateLayout(DecorView decor)&#123;....// Inflate the window decor. int layoutResource; int features = getLocalFeatures(); // System.out.println("Features: 0x" + Integer.toHexString(features)); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; layoutResource = R.layout.screen_swipe_dismiss; setCloseOnSwipeEnabled(true); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_title_icons; &#125; // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); // System.out.println("Title Icons!"); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123; // Special case for a window with only a progress bar (and title). // XXX Need to have a no-title version of embedded windows. layoutResource = R.layout.screen_progress; // System.out.println("Progress!"); &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123; // Special case for a window with a custom title. // If the window is floating, we need a dialog layout if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogCustomTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_custom_title; &#125; // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; // If no other features and not embedded, only need a title. // If the window is floating, we need a dialog layout if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123; layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); &#125; else &#123; layoutResource = R.layout.screen_title; &#125; // System.out.println("Title!"); &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123; layoutResource = R.layout.screen_simple_overlay_action_mode; &#125; else &#123; // Embedded, so no decoration is needed. layoutResource = R.layout.screen_simple; // System.out.println("Simple!"); &#125; .......&#125; 该方法比较长，只截取一部分，方法根据不同的情况加载不同的布局给layoutResource，看其中一个layout.screen_title布局 1234567891011121314151617181920212223242526272829&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"android:orientation="vertical"android:fitsSystemWindows="true"&gt;&lt;!-- Popout bar for action modes --&gt;&lt;ViewStub android:id="@+id/action_mode_bar_stub" android:inflatedId="@+id/action_mode_bar" android:layout="@layout/action_mode_bar" android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="?attr/actionBarTheme" /&gt;&lt;FrameLayout android:layout_width="match_parent" android:layout_height="?android:attr/windowTitleSize" style="?android:attr/windowTitleBackgroundStyle"&gt; &lt;TextView android:id="@android:id/title" style="?android:attr/windowTitleStyle" android:background="@null" android:fadingEdge="horizontal" android:gravity="center_vertical" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/FrameLayout&gt;&lt;FrameLayout android:id="@android:id/content" android:layout_width="match_parent" android:layout_height="0dip" android:layout_weight="1" android:foregroundGravity="fill_horizontal|top" android:foreground="?android:attr/windowContentOverlay" /&gt;&lt;/LinearLayout&gt; 这时我们只是了解了Activity的setContentView方法，我们看看Activity的dispatchTouchEvent方法 12345678910111213141516171819/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 显然调用getWindow().superDispatchTouchEvent(ev)，根据前面的分析也就是PhoneWindow的dispatchTouchEvent方法 1234567891011// This is the top-level view of the window, containing the window decor.private DecorView mDecor;@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125;// This is the view in which the window contents are placed. It is either// mDecor itself, or a child of mDecor where the contents go.ViewGroup mContentParent; 可以看到PhoneWindow的superDispatchTouchEvent调用的是DecorView的superDispatchTouchEvent方法，前面我们知道DecorView其实是ViewGroup（上述generateLayout(mDecor)返回值），到此我们可以串联起来，Activity的setContentView其实是Window对象的实现是其唯一实现类PhoneWindown的内部类DecorView来作为Activity的根View，也就是说从Activity开始传递的是从PhoneWindow开始，也就是源码中的installDecor得到的DecorView充当了Activity传递事件的View，DecorView可以理解为当前页面的底层容器，底层容器DecorView在根据自己是ViewGroup把事件再向他的子View传递，也就是我们平时写的界面最上层View，也就是setContentView加载的布局根布局View，下图结合实例很清晰的可以表示出Activity的构成。 到此我们可以写出一个事件传递的流程为 1Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; ... －&gt; View 总结一下每个传递者具有的方法，我们注意到Activity没有onInterceptTouchEvent方法，其实很容易理解，Activity作为事件的初始传递者如果拦截了事件，也就是我们点击界面无响应，这也就使得我们用户的点击没什么意义，肯定是我们点击界面中的某个view响应才符合操作。(PhoneWindow在Android都是隐藏的，不做记录) 类型 相关方法 Activity ViewGroup View 事件分发 dispatchTouchEvent 有 有 有 事件拦截 onInterceptTouchEvent 无 有 无 事件消费 onTouchEvent 有 有 有 点击事件分发原则 onInterceptTouchEvent拦截事件，该View的onTouchEvent方法才会被调用，只有onTouchEvent返回true才表示该事件被消费，否则回传到上层View的onTouchEvent方法。 如果事件一直不被消费，则最终回传给Activity，Activity不消费则事件消失。 事件是否被消费是根据返回值，true表示消费，false表示不消费。从源码角度继续分析ViewGroup和View事件传递流程 经过前面的研究，我们回顾一下,一个点击事件用MotionEvent表示，事件最先传递到Activity，调用Activity的dispatchTouchEvent方法，事件处理工作交给PhoneWindow，PhoneWindow在把事件传递给DecorView，最后DecorView作为我们界面底层容器装载我们setContentView的布局，我们写布局一般都是啥layout作为根布局，也就是ViewGroup，DecorView把事件传递到ViewGroup的dispatchTouchEvent方法，我们就从ViewGroup的dispatchTouchEvent源码开始分析 ViewGroup事件传递流程 ViewGroup方法比较长，我们一段一段来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * When set, this ViewGroup should not intercept touch events. * &#123;@hide&#125; */@UnsupportedAppUsageprotected static final int FLAG_DISALLOW_INTERCEPT = 0x80000;@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123;......// Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125;// Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; .....&#125; /** * Resets all touch state in preparation for a new cycle. */private void resetTouchState() &#123; clearTouchTargets(); ..... mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; ......&#125; /** * Clears all touch targets. */ private void clearTouchTargets() &#123; ...... mFirstTouchTarget = null; &#125;&#125; 一上来首先判断了事件是否为ACTION_DOWN，如果是ACTION_DOWN事件，则调用resetTouchState()方法，resetTouchState()钟调用了clearTouchTargets()使mFirstTouchTarget=null，而前面我们了解事件的时候也说过一个事件是ACTION_DOWN开始到ACTION_UP结束，也就是说ACTION_DOWN出现表示一个新的事件的开始；接下来再次判断为ACTION_DOWN和mFirstTouchTarget！=null，我们看到条件成立之后才能调用onInterceptTouchEvent方法，也就是说mFirstTouchTarget！=null成立说明此时不拦截事件，而mFirstTouchTarget==null成立则说明事件已经被拦截，并且不会再有ACTION_DOWN，因为此时这个一个事件还没结束，此时不管ACTION_MOVE还是ACTION_UP动作，都交由现在拦截了事件的ViewGroup来处理，并且不会再次调用onInterceptTouchEvent方法（说明该方法并不是每次都会调用的）。 我们还看到一个标记位FLAG_DISALLOW_INTERCEPT，它一般是由子View的requestDisallowInterceptTouchEvent方法设置的，表示ViewGroup无法拦截除了ACTION_DOWN以外的其他动作，我们看到源码第一个判断就会明白，只要是ACTION_DOWN动作，这个标记位都会被重置，并且ViewGroup会调用自己onInterceptTouchEvent方法表达是否需要拦截这新一轮的点击事件。 接着看dispatchTouchEvent方法剩下的其他代码段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public boolean dispatchTouchEvent(MotionEvent ev) &#123;.......if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; ...... &#125; /** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; ....... if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); ....... &#125; 这里显示的逻辑还是非常清晰的，如果ViewGroup不拦截点击事件，则首先遍历子View的最外层，获取点击事件的X坐标和Y坐标判断是否和当前子View的坐标相匹配，而dispatchTransformedTouchEvent方法实际上就是调用子View的dispatchTouchEvent方法，这样就完成了ViewGroup到子View的事件分发。 ViewGroup默认不拦截任何事件，他的onInterceptTouchEvent方法默认返回false 12345678910public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (ev.isFromSource(InputDevice.SOURCE_MOUSE) //鼠标点击处理 &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123; return true; &#125; return false; &#125; 如下源码，如果ViewGroup将事件传递到子View，则会调用addTouchTarget(child, idBitsToAssign)方法，并退出遍历子View的循环 1234567891011121314151617181920212223public boolean dispatchTouchEvent(MotionEvent ev) &#123;.......newTouchTarget = addTouchTarget(child, idBitsToAssign);break;..... // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; ..... &#125;/** * Adds a touch target for specified child to the beginning of the list. * Assumes the target child is not already present. */private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target;&#125; 如上源码，调用addTouchTarget方法，会给mFirstTouchTarget赋值，也就是说mFirstTouchTarget！=null，前面我们已经讨论过，mFirstTouchTarget==null则拦截所有的事件给该ViewGroup处理，可见mFirstTouchTarget是否赋值对于ViewGroup的事件拦截起了关键的作用。 接着往下看，如果子View遍历结束后事件还是没有进行处理，这样的情况有两种可能，一个就是上面提到的例子场景二，ViewGroup的子View没有消费事件，也就是子View的onTouchEvent返回了false，另一个情况则是则是ViewGroup子View，也就不存在事件传递子View的情况。我们看如下代码，是在上面分析的代码之后出现，第三个参数子View为null，也就是调用super.dispatchTouchEvent(event)方法，ViewGroup是继承View，也就是说不管是否拦截，ViewGropu最终还是将点击事件交由到View来处理了，只是child.dispatchTouchEvent还是super.dispatchTouchEvent的问题。 ViewGroup的源码事件分发就到这里，接下来我们分析一下View的事件分发流程。12345678910public boolean dispatchTouchEvent(MotionEvent ev) &#123;..... // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; ..... &#125; View的事件分发流程 首先我们看View的dispatchTouchEvent方法 12345678910111213141516171819202122232425262728 /** * Pass the touch screen motion event down to the target view, or this * view if it is the target. * * @param event The motion event to be dispatched. * @return True if the event was handled by the view, false otherwise. */public boolean dispatchTouchEvent(MotionEvent event) &#123;boolean result = false;....if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125;..... return result;&#125; 我们看到上面的源码中，View对于点击的事件的处理首先是判断是注册OnTouchListener，并且如果OnTouchListener的onTouch放回true，则整个dispatchTouchEvent返回true，已经拦截了事件，则不会执行下面的onTouchEvent方法的调用，也就是说事件拦截了，但是不调用onTouchEvent方法，这里其实很好理解，如果开发者注册了OnTouchListener并在onTouch放回true，说明开发者是想自己来处理触摸事件，而onTouchEvent是属于Android的事件传递机制方法，是系统帮我们处理的，所以当我们自己处理了点击事件，就不需要系统来再次处理了。所以OnTouchListener的调用有先级高于onTouchEvent。 如果Ciew没有注册OnTouchListener方法，接下来事件传递到onTouchEvent方法，我们接着看onTouchEvent源码 123456789101112131415161718192021222324252627282930313233 /** * Implement this method to handle touch screen motion events. * &lt;p&gt; * If this method is used to detect click actions, it is recommended that * the actions be performed by implementing and calling * &#123;@link #performClick()&#125;. This will ensure consistent system behavior, * including: * &lt;ul&gt; * &lt;li&gt;obeying click sound preferences * &lt;li&gt;dispatching OnClickListener calls * &lt;li&gt;handling &#123;@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when * accessibility features are enabled * &lt;/ul&gt; * * @param event The motion event. * @return True if the event was handled, false otherwise. */public boolean onTouchEvent(MotionEvent event) &#123; .... final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return clickable; &#125; .... &#125; 通过上面源码和注释，我们可以知道，View即使是处于不可用状态，他还是会消费(consumes)点击事件，只是他不会响应点击事件，也就是返回各种点击的状态（点击，长按）。 接着看看剩下源码对点击事件的处理 1234567891011121314151617181920212223242526272829303132333435363738394041public boolean onTouchEvent(MotionEvent event) &#123;if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: ...... if (!clickable) &#123; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; &#125; boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; ....... if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClickInternal(); &#125; &#125; &#125; ..... &#125; break; &#125; .... return true; &#125; return false;&#125; 触摸事件结束，也就是ACTION_UP，所以这里我们看对于ACTION_UP的处理就可以了。我们看到对于ACTION_UP，，如果没有!clickable，也就是没有View的CLICKABLE、LONG_CLICKABLE和CONTEXT_CLICKABLE都不存在，则清除所有的状态回调等，如果其中一个存在，则直接消费这个时间，我们看到方法后面有个retrun true存在，也证实事件被消费了，也就是onTouchEvent方法返回了true。而如果ACTION_UP没有消费事件，最终onTouchEvent方法是返回false。 到这里，我们还看到ACTION_UP事件会触发performClickInternal();方法，我们看看他做了什么 12345678910111213141516171819202122232425 private boolean performClickInternal() &#123; // Must notify autofill manager before performing the click actions to avoid scenarios where // the app has a click listener that changes the state of views the autofill service might // be interested on. notifyAutofillManagerOnClick(); return performClick();&#125;public boolean performClick() &#123; // We still need to call this method to handle the cases where performClick() was called // externally, instead of through performClickInternal() notifyAutofillManagerOnClick(); final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); notifyEnterOrExitForAutoFillIfNeeded(true); return result;&#125; 可以从源码看到他最终调用的是performClick()方法，如果View设置了OnClickListener，则会调用onClick方法。我们知道View默认的LONG_CLICKABLE是false，而CLICKABLE需要根据具体View才能知道，比如Button是可点击的，则CLICKABLE为true，而ImageView默认是不可点击的，所以CLICKABLE为false，但是开发中我们也发现，不管View是否可以点击，只要我们设置setOnClickListener()或者setOnLongClickListener()方法，则该View就是可以被点击或者长按的，也就是LONG_CLICKABLE或者CLICKABLE为true。我们从源码可以看出。到此，从源码角度分析事件分发机制的流程我们已经走完。 123456789101112131415161718192021 /** * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l;&#125;public void setOnLongClickListener(@Nullable OnLongClickListener l) &#123; if (!isLongClickable()) &#123; setLongClickable(true); &#125; getListenerInfo().mOnLongClickListener = l;&#125; 经过前面的分析，我们还可以排出与View相关的事件调度优先顺序为onTouchListener&gt;onTouchEvent &gt; onLongClickListener &gt; onClickListener 最后，总结事件分发机制的核心知识点 正常情况下触摸一次屏幕触发事件序列为ACTION_DOWN–&gt;ACTION_UP 当一个View决定拦截，那么这一个事件序列只能由这个View来处理，onInterceptTouchEvent方法并不是每次产生动作都会被调用到，当我们需要提前出来想要拦截的动作需要在事件必须传递到该ViewGroup的前提下在dispatchTouchEvent方法中进程操作。 一个View开始处理事件，但是它不消耗ACTION_DOWN，也就是onTouchEvent返回false，则这个事件会交由他的父元素的onTouchEvent方法来进行处理，而这个事件序列的其他剩余ACACTION_MOVE，ACTION_UP也不会再给该View来处理。 View没有onInterceptTouchEvent方法，View一旦接收到事件就调用onTouchEvent方法 ViewGroup默认不拦截任何事件（onInterceptTouchEvent方法默认返回false）。 View的onTouchEvent方法默认是处理点击事件的，除非他是不可点击的（clickable和longClickable同时为false） 事件分发机制的核心原理就是责任链模式，事件层层传递，直到被消费。最后说点 终于，把事件分发机制给回顾了一遍，其实五月份的时候我就复习过一次事件分发机制，但是当时没有记录，所以这次在回头看以前记得有些知识点感觉还是模糊，所以记录下来才能在以后忘记的时候去回顾再总结。如果文章中有写得不对的地方，请给我留言指出，大家一起学习进步。如果觉得我的文章给予你帮助，也请给我一个喜欢和关注。 参考链接 Android 源码 Activity Android 源码 Window Android 源码 PhoneWindow Android 源码 screen_title.xml Android 源码 ViewGroup Android 源码 View Android事件传递机制分析 参考书籍 《Android开发艺术探索》 《Android进阶之光》]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>事件分发机制</tag>
        <tag>ViewGroup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从源码角度深入理解OKHttp3]]></title>
    <url>%2F2019%2F01%2F27%2F%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp3%2F</url>
    <content type="text"><![CDATA[在日常开发中网络请求是很常见的功能。OkHttp作为Android开发中最常用的网络请求框架，在Android开发中我们经常结合retrofit一起使用，俗话说得好：“知其然知其所以然”，所以这篇文章我们通过源码来深入理解OKHttp3（基于3.12版本） 常规使用 在了解源码前，我们先了解如何使用OKHttp这个框架（框架地址） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//框架引入项目implementation("com.squareup.okhttp3:okhttp:3.12.0")//引用官方Demo的例子@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //主线程不能进行耗时操作 new Thread()&#123; @Override public void run() &#123; super.run(); /** * 同步请求 */ GetExample getexample = new GetExample(); String syncresponse = null; try &#123; syncresponse = getexample.run("https://raw.github.com/square/okhttp/master/README.md"); Log.i("maoqitian","异步请求返回参数"+syncresponse); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); /** * 异步请求 */ PostExample postexample = new PostExample(); String json = postexample.bowlingJson("Jesse", "Jake"); try &#123; postexample.post("http://www.roundsapp.com/post", json); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 异步请求 */ class PostExample &#123; final MediaType JSON = MediaType.get("application/json; charset=utf-8"); //获取 OkHttpClient 对象 OkHttpClient client = new OkHttpClient(); void post(String url, String json) throws IOException &#123; RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.i("maoqitian","异步请求返回参数"+e.toString()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; String asynresponse= response.body().string(); Log.i("maoqitian","异步请求返回参数"+asynresponse); &#125; &#125;); &#125; String bowlingJson(String player1, String player2) &#123; return "&#123;'winCondition':'HIGH_SCORE'," + "'name':'Bowling'," + "'round':4," + "'lastSaved':1367702411696," + "'dateStarted':1367702378785," + "'players':[" + "&#123;'name':'" + player1 + "','history':[10,8,6,7,8],'color':-13388315,'total':39&#125;," + "&#123;'name':'" + player2 + "','history':[6,10,5,10,10],'color':-48060,'total':41&#125;" + "]&#125;"; &#125; &#125; /** * 同步请求 */ class GetExample &#123; OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException &#123; Request request = new Request.Builder() .url(url) .build(); try (Response response = client.newCall(request).execute()) &#123; return response.body().string(); &#125; &#125; &#125; 由例子我们可以看到，client.newCall(request).execute()执行的是异步请求，我们可以加入Callback来异步获取返回值，Response response = client.newCall(request).execute()执行的是同步请求，更多post请求方式例子可以查看官方sample项目 源码分析OKHttp网络请求流程图 首先看一个流程图，对于接下来的源码分析有个大体印象RealCall 通过上面的例子可以看到，不管是同步请求还是异步请求，首先调用的OkHttpClient的newCall(request)方法，先来看看这个方法 123456/** * Prepares the &#123;@code request&#125; to be executed at some point in the future. */ @Override public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */);&#125; 通过newCall方法的源码可以看到该方法返回值是Call，Call是一个接口，他的实现类是RealCall，所以我们执行的同步execute()方法或者异步enqueue()方法都是RealCall的方法。newCall方法接收了的网络请求参数，接下来我们看看execute()和enqueue()方法 123456789101112131415161718192021222324252627282930313233343536/** * 同步请求 */ @Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); timeout.enter(); eventListener.callStart(this); try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException("Canceled"); return result; &#125; catch (IOException e) &#123; e = timeoutExit(e); eventListener.callFailed(this, e); throw e; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; /** * 异步请求 */ @Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125; 这里先看异步的enqueue方法，很直观可以看到真正执行网络请求的是最后一句代码，而它是怎么做的呢，我们还得先弄明白dispatcher，Dispatcher的本质是异步请求的调度器，它内部持有一个线程池，结合线程池调配并发请求。官方文档描述也说了这一点。 12345678910111213141516171819202122232425262728293031/**最大并发请求数*/private int maxRequests = 64;/**每个主机最大请求数*/private int maxRequestsPerHost = 5;/** Ready async calls in the order they'll be run. 准备要执行的异步请求队列*/private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();/** Running asynchronous calls. Includes canceled calls that haven't finished yet.正在执行的异步请求队列*/private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();/** Running synchronous calls. Includes canceled calls that haven't finished yet. 正在执行的同步请求队列*/private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();/** Dispatcher 构造方法 */public Dispatcher(ExecutorService executorService) &#123;this.executorService = executorService; &#125; public Dispatcher() &#123; &#125;public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false)); &#125; return executorService;&#125; Dispatcher 通过Dispatcher的构造方法我们知道我们可以使用自己的线程池，也可以使用Dispatcher默认的线程池，默认的线程池相当于CachedThreadPool线程池，这个线程池比较适合执行大量的耗时较少的任务（线程池介绍）。 了解了Dispatcher之后，我们继续探究Dispatcher的enqueue方法 1234567891011121314151617181920212223242526272829303132333435363738void enqueue(AsyncCall call) &#123; synchronized (this) &#123; readyAsyncCalls.add(call); &#125; promoteAndExecute(); &#125; /** * Promotes eligible calls from &#123;@link #readyAsyncCalls&#125; to &#123;@link #runningAsyncCalls&#125; and runs * them on the executor service. Must not be called with synchronization because executing calls * can call into user code. * * @return true if the dispatcher is currently running calls. */ private boolean promoteAndExecute() &#123; assert (!Thread.holdsLock(this)); List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) &#123; for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall asyncCall = i.next(); if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity. if (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) continue; // Host max capacity. i.remove(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); &#125; isRunning = runningCallsCount() &gt; 0; &#125; for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); &#125; return isRunning; &#125; 这里分三步走，首先将传入的AsyncCall（这其实是一个Runnable对象）加入准备要执行的异步请求队列，其次调用promoteAndExecute()方法，变量准备要执行的异步请求队列，如果队列任务数超过最大并发请求数，则直接退出遍历，则不会进行下面的操作；如果超过每个主机最大请求数，则跳过这次循环，继续下一次遍历，否则将异步任务加入到正在执行的异步请求队列，最后遍历保存异步任务的队列，执行AsyncCall.executeOn(executorService())方法，并且传入了Dispatcher的默认线程池。 123456789101112131415161718192021/** * Attempt to enqueue this async call on &#123;@code executorService&#125;. This will attempt to clean up * if the executor has been shut down by reporting the call as failed. */ void executeOn(ExecutorService executorService) &#123; assert (!Thread.holdsLock(client.dispatcher())); boolean success = false; try &#123; executorService.execute(this); success = true; &#125; catch (RejectedExecutionException e) &#123; InterruptedIOException ioException = new InterruptedIOException("executor rejected"); ioException.initCause(e); eventListener.callFailed(RealCall.this, ioException); responseCallback.onFailure(RealCall.this, ioException); &#125; finally &#123; if (!success) &#123; client.dispatcher().finished(this); // This call is no longer running! &#125; &#125;&#125; 通过执行AsyncCall.executeOn()方法的源码，我们看到Dispatcher的线程池执行了execute(this)方法，执行异步任务，并且指向的是this，也就是当前的AsyncCall对象（RealCall的内部类），而AsyncCall实现了抽象类NamedRunnable 123456789101112131415161718192021/** * Runnable implementation which always sets its thread name. */public abstract class NamedRunnable implements Runnable &#123;protected final String name;public NamedRunnable(String format, Object... args) &#123;this.name = Util.format(format, args);&#125; @Override public final void run() &#123; String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try &#123; execute(); &#125; finally &#123; Thread.currentThread().setName(oldName); &#125; &#125; protected abstract void execute(); &#125; 可以看到NamedRunnable中run()方法调用了抽象方法execute()，也就说明execute()的实现在AsyncCall对象中，而上面线程池执行的异步任务也是调用这个execute()方法，我们看看AsyncCall对象中execute()方法的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Override protected void execute() &#123; boolean signalledCallback = false; timeout.enter(); try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; e = timeoutExit(e); if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; /**Dispatcher的finished方法*/ /** Used by &#123;@code AsyncCall#run&#125; to signal completion. */ void finished(AsyncCall call) &#123; finished(runningAsyncCalls, call); &#125; /** Used by &#123;@code Call#execute&#125; to signal completion. */ void finished(RealCall call) &#123; finished(runningSyncCalls, call); &#125; private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) &#123; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!"); idleCallback = this.idleCallback; &#125; boolean isRunning = promoteAndExecute(); if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125; &#125; 我们可以先关注最后一行，不管前面请求如何，最后finally代码块中都执行了Dispatcher的finished方法，要是要将当前任务从runningAsyncCalls或runningSyncCalls 中移除， 同时把readyAsyncCalls的任务调度到runningAsyncCalls中并执行而finished方法中执行了promoteAndExecute()方法，经过前面对该方法分析，说明不管当前执行的任务如何，都会OkHttp都会去readyAsyncCalls（准备要执行的异步请求队列）取出下一个请求继续执行。接下来我们继续回到AsyncCall对象中的execute()方法，可以发现getResponseWithInterceptorChain()的方法返回了Response，说明在该方法中执行了我们的网络请求。而不管同步还是异步请求，都是通过getResponseWithInterceptorChain()完成网络请求。 12345678910111213141516171819Response getResponseWithInterceptorChain() throws IOException &#123;// Build a full stack of interceptors.List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();interceptors.addAll(client.interceptors());interceptors.add(retryAndFollowUpInterceptor);interceptors.add(new BridgeInterceptor(client.cookieJar()));interceptors.add(new CacheInterceptor(client.internalCache()));interceptors.add(new ConnectInterceptor(client));if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125;interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest);&#125; 拦截器（Interceptor） 由getResponseWithInterceptorChain()方法我们看到添加了很多Interceptor（拦截器），首先要了解每个Interceptor的作用，也能大致了解OKHttp完成网络请求的过程。 1.首先加入我们自定义的interceptors 2.通过RetryAndFollowUpInterceptor处理网络请求重试 3.通过BridgeInterceptor处理请求对象转换，应用层到网络层 4.通过CacheInterceptor处理缓存 5.通过ConnectInterceptor处理网络请求链接 6.通过CallServerInterceptor处理读写，和服务器通信，进行真正的网络请求 责任链模式 在阅读接下来源码之前，我们先要了解责任链模式。通俗化的讲在责任链模式中有很多对象，这些对象可以理解为上面列出的拦截器，而每个对象之间都通过一条链子连接，网络请求在这条链子上传递，直到某一个对象处理了这个网络请求，也就是完成了网络请求。使用这个模式的好处就是不管你用多少拦截器处理什么操作，最终都不会影响我们的发出请求的目的，就是完成网络请求，拦截过程你可以任意添加分配责任。 接着继续看Interceptor.Chain，他是Interceptor的内部接口，前面添加的每一个拦截器都实现了Interceptor接口，而RealInterceptorChain是Interceptor.Chain接口的实现类。先看RealInterceptorChain的proceed方法源码 123456789101112131415161718192021public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,RealConnection connection) throws IOException &#123;if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; ...... // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException("network interceptor " + interceptor + " must call proceed() exactly once"); &#125; ..... return response; &#125; 通过源码可以注意到interceptor.intercept(next)，RetryAndFollowUpInterceptor作为默认拦截器的第一个拦截器，也就是执行了它的intercept方法 RetryAndFollowUpInterceptor 前面说过RetryAndFollowUpInterceptor拦截器执行OKHttp网络重试，先看它的intercept方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 /**RetryAndFollowUpInterceptor的intercept方法 **/ @Override public Response intercept(Chain chain) throws IOException &#123;Request request = chain.request();RealInterceptorChain realChain = (RealInterceptorChain) chain;Call call = realChain.call();EventListener eventListener = realChain.eventListener();StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace);this.streamAllocation = streamAllocation;int followUpCount = 0;Response priorResponse = null;while (true) &#123; if (canceled) &#123; streamAllocation.release(); throw new IOException("Canceled"); &#125; //将请求通过链子chain传递到下一个拦截器 Response response; boolean releaseConnection = true; try &#123; response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (RouteException e) &#123; // 线路异常，连接失败，检查是否可以重新连接 if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123; throw e.getFirstConnectException(); &#125; releaseConnection = false; continue; &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. // IO异常，连接失败，检查是否可以重新连接 boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue; &#125; finally &#123; // We're throwing an unchecked exception. Release any resources. 释放资源 if (releaseConnection) &#123; streamAllocation.streamFailed(null); streamAllocation.release(); &#125; &#125; // Attach the prior response if it exists. Such responses never have a body. if (priorResponse != null) &#123; response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null) .build()) .build(); &#125; Request followUp; try &#123; //效验状态码、身份验证头信息、跟踪重定向或处理客户端请求超时 followUp = followUpRequest(response, streamAllocation.route()); &#125; catch (IOException e) &#123; streamAllocation.release(); throw e; &#125; if (followUp == null) &#123; streamAllocation.release(); // 不需要重定向，正常返回结果 return response; &#125; closeQuietly(response.body()); //超过重试次数 if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; streamAllocation.release(); throw new ProtocolException("Too many follow-up requests: " + followUpCount); &#125; if (followUp.body() instanceof UnrepeatableRequestBody) &#123; streamAllocation.release(); throw new HttpRetryException("Cannot retry streamed HTTP body", response.code()); &#125; if (!sameConnection(response, followUp.url())) &#123; streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; &#125; else if (streamAllocation.codec() != null) &#123; throw new IllegalStateException("Closing the body of " + response + " didn't close its backing stream. Bad interceptor?"); &#125; request = followUp; priorResponse = response; &#125; &#125; 通过RetryAndFollowUpInterceptor拦截器intercept方法源码，能够理解到OKHttp的重试机制 1.首先创建StreamAllocation对象（稍后分析），在一个死循环中将通过链子chain传递到下一个拦截器，如果捕获异常，则判断异常是否恢复连接，不能连接则抛出异常，跳出循环并是否创建的连接池资源 2.第一步没有异常，还要返回值效验状态码、头部信息、是否需要重定向、连接超时等信息，捕获异常则抛出并退出循环 3.如果如果重定向，循环超出RetryAndFollowUpInterceptor拦截器的最大重试次数，也抛出异常，退出循环 通过拦截器RetryAndFollowUpInterceptor调用(RealInterceptorChain) chain.proceed()方法，又再次回到了我们刚刚分析proceed()方法，而该方法继续调用下一个拦截器的intercept()方法，这个拦截器就是默认的第二个拦截器BridgeInterceptor 123456789101112131415/** * Bridges from application code to network code. First it builds a network request from a user * request. Then it proceeds to call the network. Finally it builds a user response from the network * response. * BridgeInterceptor的intercept方法 */@Override public Response intercept(Chain chain) throws IOException &#123; Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); RequestBody body = userRequest.body(); ...... Response networkResponse = chain.proceed(requestBuilder.build()); ......&#125; 该拦截器主要实现了网络请求中应用层到网络层之间的数据编码桥梁。根据用户请求建立网络连接，根据网络响应建立网络响应，也可以看到该方法 继续调用了chain.proceed()方法，同理，根据前面分析会调用第三个默认拦截器CacheInterceptor的intercept方法。 CacheInterceptor 前面我们说过这个拦截器是处理缓存的，接下来看看源码是如何实现的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * 拦截器CacheInterceptor的intercept方法 */@Override public Response intercept(Chain chain) throws IOException &#123;Response cacheCandidate = cache != null ? cache.get(chain.request()) : null;long now = System.currentTimeMillis();//获取策略，假设当前可以使用网络CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();Request networkRequest = strategy.networkRequest;Response cacheResponse = strategy.cacheResponse;if (cache != null) &#123; cache.trackResponse(strategy);&#125;if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.&#125; // If we're forbidden from using the network and the cache is insufficient, fail. 如果网络被禁止使用并且没有缓存，则请求失败 if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message("Unsatisfiable Request (only-if-cached)") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build();&#125;// If we don't need the network, we're done.如果有缓存，则返回响应缓存，请求完成if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build();&#125;Response networkResponse = null;try &#123;//没有缓存，则进行网络请求，执行下一个拦截器 networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125;&#125; // If we have a cache response too, then we're doing a conditional get. if (cacheResponse != null) &#123; //状态码 304 if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. //保存缓存 CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response;&#125; 先看看intercept方法的大致逻辑 1.首先通过CacheStrategy.Factory().get()获取缓存策略 2.如果网络被禁止使用并且没有缓存，则请求失败，返回504 3.如果有响应缓存，则返回响应缓存，请求完成 4.没有缓存，则进行网络请求，执行下一个拦截器 5.进行网络请求，如果响应状态码为304，说明客户端缓存了目标资源但不确定该缓存资源是否是最新版本，服务端数据没变化，继续使用缓存 6.最后保存缓存 缓存的场景也符合设计模式中的策略模式，需要CacheStrategy提供策略在不同场景下读缓存还是请求网络。 了解了缓存逻辑，继续深入了解OKHttp的缓存是如何做的。首先我们应该回到最初的缓存拦截器设置代码 12345678910111213141516171819202122232425262728293031323334353637383940414243/**RealCall 设置缓存拦截器*/interceptors.add(new CacheInterceptor(client.internalCache()));/**OkHttpClient 设置缓存*/Cache cache;@Override public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) &#123; builder.setInternalCache(internalCache);&#125;void setInternalCache(@Nullable InternalCache internalCache) &#123;this.internalCache = internalCache;this.cache = null;&#125;InternalCache internalCache() &#123;return cache != null ? cache.internalCache : internalCache;&#125;/**Cache类中 内部持有 InternalCache */ final DiskLruCache cache; final InternalCache internalCache = new InternalCache() &#123; @Override public Response get(Request request) throws IOException &#123; return Cache.this.get(request); &#125; @Override public CacheRequest put(Response response) throws IOException &#123; return Cache.this.put(response); &#125; @Override public void remove(Request request) throws IOException &#123; Cache.this.remove(request); &#125; @Override public void update(Response cached, Response network) &#123; Cache.this.update(cached, network); &#125; @Override public void trackConditionalCacheHit() &#123; Cache.this.trackConditionalCacheHit(); &#125; @Override public void trackResponse(CacheStrategy cacheStrategy) &#123; Cache.this.trackResponse(cacheStrategy); &#125;&#125;; 上面我们分别截取了 RealCall类、OkHttpClient类和Cache类的源码，可以了解到拦截器使用的缓存类是DiskLruCache，设置缓存缓存只能通过OkHttpClient的builder来设置，缓存操作实现是在Cache类中，但是Cache没有实现InternalCache接口，而是持有InternalCache接口的内部类对象来实现缓存的操作方法，这样就使得缓存的操作实现只在Cache内部，外部用户是无法实现缓存操作的，方便框架内部使用，接口扩展也不影响外部。 ConnectInterceptor 根据前面的分析，缓存拦截器中也会调用chain.proceed方法，所以这时候执行到了第四个默认拦截器ConnectInterceptor，接着看它的intercept方法 12345678910111213141516/** * 拦截器ConnectInterceptor的intercept方法 */@Override public Response intercept(Chain chain) throws IOException &#123;RealInterceptorChain realChain = (RealInterceptorChain) chain;Request request = realChain.request();StreamAllocation streamAllocation = realChain.streamAllocation();// We need the network to satisfy this request. Possibly for validating a conditional GET.boolean doExtensiveHealthChecks = !request.method().equals("GET");//打开连接HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);RealConnection connection = streamAllocation.connection();//交由下一个拦截器处理return realChain.proceed(request, streamAllocation, httpCodec, connection);&#125; 我们看到intercept源码非常简单，通过StreamAllocation打开连接，然后就交由下一个拦截器处理请求。如何连接呢？我们需要搞懂StreamAllocation。 StreamAllocation对象负责协调请求和连接池之间的联系。每一个OKHttpClient有它对应的一个连接池，经过前面的分析我们知道StreamAllocation对象的创建在RetryAndFollowUpInterceptor拦截器的intercept方法中创建，而StreamAllocation打开了连接，则连接池在哪创建呢，答案就在OKHttpClient的Builder类构造方法中 12345public Builder() &#123; ....... connectionPool = new ConnectionPool(); .......&#125; 了解了StreamAllocation对象和ConnectionPool对象的创建，下面来分析StreamAllocation是如何打开连接的。首先是streamAllocation.newStream()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 public HttpCodec newStream( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123; ........ try &#123; RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); ....... &#125; &#125; catch (IOException e) &#123; throw new RouteException(e); &#125; &#125; /** * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated * until a healthy connection is found. */ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException &#123; while (true) &#123; RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled); ........ return candidate; &#125; &#125; /** * Returns a connection to host a new stream. This prefers the existing connection if it exists, * then the pool, finally building a new connection. */private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException &#123; ............ // if (result == null) &#123; // Attempt to get a connection from the pool. Internal.instance.get(connectionPool, address, this, null); if (connection != null) &#123; //连接复用 foundPooledConnection = true; result = connection; &#125; else &#123; selectedRoute = route; &#125; &#125; .......... if (!foundPooledConnection) &#123; ........ result = new RealConnection(connectionPool, selectedRoute); //记录每个连接的引用，每个调用必须与同一连接上的调用配对。 acquire(result, false); &#125; &#125; ......... synchronized (connectionPool) &#123; ....... // Pool the connection. 将连接放入连接池 Internal.instance.put(connectionPool, result); ...... &#125; &#125; ....... return result; &#125; 根据上面的源码，我们可以知道findHealthyConnection在循环找健康的连接，直到找到连接，说明findConnection方法是寻找连接的核心方法，该方法中存在可以复用的连接则复用，否则创建新的连接，并且记录连接引用，我们可以明白StreamAllocation主要是为拦截器提供一个连接， 如果连接池中有复用的连接则复用连接， 如果没有则创建新的连接。 ConnectionPool连接池实现 明白StreamAllocation是如何创建和复用连接池，我们还要明白连接池（ConnectionPool）的是如何实现的。 理解ConnectionPool之前，我们需要明白TCP连接的知识，Tcp建立连接三次握手和断开连接四次握手过程是需要消耗时间的，在http/1.0每一次请求只能打开一次连接，而在http/1.1是支持持续连接（persistent connection），使得一次连接打开之后会保持一段时间，如果还是同一个请求并且使同一个服务器则在这段时间内继续请求连接是可以复用的。而ConnectionPool也实现了这个机制，在它内部持有一个线程池和一个缓存连接的双向列表，连接中最多只能存在5个空闲连接，空闲连接最多只能存活5分钟，空闲连接到期之后定时清理。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public final class ConnectionPool &#123;/** * Background threads are used to cleanup expired connections. There will be at most a single * thread running per connection pool. The thread pool executor permits the pool itself to be * garbage collected. */ //线程池 private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp ConnectionPool", true)); /** The maximum number of idle connections for each address. */ private final int maxIdleConnections; private final long keepAliveDurationNs; private final Runnable cleanupRunnable = new Runnable() &#123; @Override public void run() &#123; // 后台定期清理连接的线程 while (true) &#123; long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) &#123; long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (ConnectionPool.this) &#123; try &#123; ConnectionPool.this.wait(waitMillis, (int) waitNanos); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125; &#125; &#125; &#125;; //缓存连接的双向队列 private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;(); ............ /** * Create a new connection pool with tuning parameters appropriate for a single-user application. * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity. */ public ConnectionPool() &#123; this(5, 5, TimeUnit.MINUTES); &#125; ............&#125; 这里还要说的一点是streamAllocation.newStream()返回的HttpCodec对象就是我们编码HTTP请求并解码HTTP响应的接口，他的实现类Http2Codec和Http1Codec对应https和http的解析request与响应response对socket读写过程实现，并最终放到RealConnection对象newCodec类中创建。 1234567891011121314/** RealConnection类newCodec方法*/ public HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation streamAllocation) throws SocketException &#123; if (http2Connection != null) &#123; return new Http2Codec(client, chain, streamAllocation, http2Connection); &#125; else &#123; socket.setSoTimeout(chain.readTimeoutMillis()); source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS); sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS); return new Http1Codec(client, streamAllocation, source, sink); &#125;&#125; streamAllocation得到连接对象，也就是RealConnection对象，它封装了套接字socket连接，也就是该类的connectSocket方法。并且使用OKio来对数据读写。OKio封装了Java的I/O操作，这里就不细说了。最后返回的ConnectInterceptor拦截器的intercept方法同样调用了Chain.proceed，将拿到的连接交由CallServerInterceptor做处理。 12345678910111213141516171819202122232425262728293031323334353637/** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. RealConnection类connectSocket方法*/private void connectSocket(int connectTimeout, int readTimeout, Call call, EventListener eventListener) throws IOException &#123;Proxy proxy = route.proxy();Address address = route.address();rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);eventListener.connectStart(call, route.socketAddress(), proxy);rawSocket.setSoTimeout(readTimeout);try &#123; //打开 socket 连接 Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);&#125; catch (ConnectException e) &#123; ConnectException ce = new ConnectException("Failed to connect to " + route.socketAddress()); ce.initCause(e); throw ce;&#125;// The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0// More details:// https://github.com/square/okhttp/issues/3245// https://android-review.googlesource.com/#/c/271775/try &#123; //使用OKio来对数据读写 source = Okio.buffer(Okio.source(rawSocket)); sink = Okio.buffer(Okio.sink(rawSocket)); &#125; catch (NullPointerException npe) &#123; if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123; throw new IOException(npe); &#125; &#125;&#125; 最后返回的ConnectInterceptor拦截器的intercept方法同样调用了Chain.proceed，将拿到的连接交由CallServerInterceptor做处理。 CallServerInterceptor 在经过前面一系列拦截器之后，OKHttp最终把拿到网络请求连接给到CallServerInterceptor拦截器进行网络请求和服务器通信。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/**CallServerInterceptor的intercept方法*/ @Override public Response intercept(Chain chain) throws IOException &#123;RealInterceptorChain realChain = (RealInterceptorChain) chain;HttpCodec httpCodec = realChain.httpStream();StreamAllocation streamAllocation = realChain.streamAllocation();RealConnection connection = (RealConnection) realChain.connection();Request request = realChain.request();long sentRequestMillis = System.currentTimeMillis();realChain.eventListener().requestHeadersStart(realChain.call());//按照HTTP协议，依次写入请求体httpCodec.writeRequestHeaders(request);................. if (responseBuilder == null) &#123; realChain.eventListener().responseHeadersStart(realChain.call()); // responseBuilder = httpCodec.readResponseHeaders(false); &#125; Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); ............... if (forWebSocket &amp;&amp; code == 101) &#123; // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; //响应数据OKio写入 response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); &#125; &#125; return response;&#125;/**Http1Codec方法**///OKio 读写对象final BufferedSource source;final BufferedSink sink;@Override public void writeRequestHeaders(Request request) throws IOException &#123;//构造好请求头String requestLine = RequestLine.get( request, streamAllocation.connection().route().proxy().type()); writeRequest(request.headers(), requestLine);&#125; /** Returns bytes of a request header for sending on an HTTP transport. 将请求信息写入sink */public void writeRequest(Headers headers, String requestLine) throws IOException &#123;if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);sink.writeUtf8(requestLine).writeUtf8("\r\n");for (int i = 0, size = headers.size(); i &lt; size; i++) &#123; sink.writeUtf8(headers.name(i)) .writeUtf8(": ") .writeUtf8(headers.value(i)) .writeUtf8("\r\n"); &#125;sink.writeUtf8("\r\n");state = STATE_OPEN_REQUEST_BODY;&#125; 可以看到在CallServerInterceptor拦截器的方法中首先通过HttpCodec（上面贴的是Http1Codec的方法）writeRequestHeaders和writeRequest方法写入请求体，并将请求体写入OKio的写入对象sink中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/**Http1Codec方法**//** 读取响应头信息*/ @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException &#123;if (state != STATE_OPEN_REQUEST_BODY &amp;&amp; state != STATE_READ_RESPONSE_HEADERS) &#123; throw new IllegalStateException("state: " + state);&#125; try &#123; StatusLine statusLine = StatusLine.parse(readHeaderLine()); Response.Builder responseBuilder = new Response.Builder() .protocol(statusLine.protocol) .code(statusLine.code) .message(statusLine.message) .headers(readHeaders()); if (expectContinue &amp;&amp; statusLine.code == HTTP_CONTINUE) &#123; return null; &#125; else if (statusLine.code == HTTP_CONTINUE) &#123; state = STATE_READ_RESPONSE_HEADERS; return responseBuilder; &#125; state = STATE_OPEN_RESPONSE_BODY; return responseBuilder;&#125; catch (EOFException e) &#123; // Provide more context if the server ends the stream before sending a response. IOException exception = new IOException("unexpected end of stream on " + streamAllocation); exception.initCause(e); throw exception; &#125;&#125; /** 写入响应输入到ResponseBody */ @Override public ResponseBody openResponseBody(Response response) throws IOException &#123; streamAllocation.eventListener.responseBodyStart(streamAllocation.call); String contentType = response.header("Content-Type"); if (!HttpHeaders.hasBody(response)) &#123; Source source = newFixedLengthSource(0); return new RealResponseBody(contentType, 0, Okio.buffer(source)); &#125; if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) &#123; Source source = newChunkedSource(response.request().url()); return new RealResponseBody(contentType, -1L, Okio.buffer(source)); &#125; long contentLength = HttpHeaders.contentLength(response); if (contentLength != -1) &#123; Source source = newFixedLengthSource(contentLength); return new RealResponseBody(contentType, contentLength, Okio.buffer(source)); &#125; return new RealResponseBody(contentType, -1L, Okio.buffer(newUnknownLengthSource()));&#125; 通过readResponseHeaders方法读取响应头信息，openResponseBody得到响应体信息。最终将网络请求的响应信息通过Callback()回调方法异步传递出去，同步请求则直接返回。到此OKHttp源码理解到此为止。 最后说点 通过OKHttp这个框架源码阅读，也是对自己的一个提升，不仅了解了框架原理，设计模式在适宜场景的运用，同时也是对自己耐心的一次考验，源码的阅读是枯燥的，但是只要静下心来，也能发现阅读源码的乐趣。由于本人水平有限，文章中如果有错误，请大家给我提出来，大家一起学习进步，如果觉得我的文章给予你帮助，也请给我一个喜欢和关注。 参考链接： 深入解析OkHttp3 OkHttp3源码和设计模式-1 参考书籍： 《计算机网络》第六版]]></content>
      <categories>
        <category>Android热门框架解析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>HTTP</tag>
        <tag>OKHttp3</tag>
        <tag>源码分析</tag>
        <tag>Dispatcher</tag>
        <tag>Interceptor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿斗鱼直播后台播放功能实现]]></title>
    <url>%2F2019%2F01%2F25%2F%E4%BB%BF%E6%96%97%E9%B1%BC%E7%9B%B4%E6%92%AD%E5%90%8E%E5%8F%B0%E6%92%AD%E6%94%BE%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[最近公司项目需要视频后台播放，后台播放关键点： 判断应用是否进入后台 视频如何后台播放 视频后台播放如何弹出Notification通知 使用SharedPreferences记录用户是否设置了后台播放（默认开启后台播放） 判断应用是否进入后台(Application ActivityLifecycleCallbacks) Application生命周期是最长的，由registerActivityLifecycleCallbacks监控当前到底是哪个Activity，并通过mActivityCount记录是否进入后台，进入后台使用发送广播显示notification123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * @author maoqitian * @Description: * @date 2019/1/4 0004 10:30 */public class MyApplication extends Application &#123; private static final String TAG = "MyApplication"; /** * 当获取的为0则当前应用在后台，否则不为0则为应用在前台 by maoqitian */ private int mActivityCount = 0; /** * 是否进入后台 */ private boolean isBackground=false; @Override public void onCreate() &#123; super.onCreate(); registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; Log.d(TAG,"onActivityCreated"); &#125; @Override public void onActivityStarted(Activity activity) &#123; mActivityCount++; Log.d(TAG,"onActivityStarted"+"mActivityCount ："+mActivityCount +"activityName："+ activity.getClass().getSimpleName()); if(mActivityCount == 1 &amp;&amp; isBackground &amp;&amp; "PlayerActivity".equals(activity.getClass().getSimpleName()) )&#123; //只有播放器才进行操作判断 Log.d(TAG, "onActivityStarted: 播放器进入前台" ); Toast.makeText(MyApplication.this,"播放器进入前台",Toast.LENGTH_LONG).show(); isBackground=false; &#125; &#125; @Override public void onActivityResumed(Activity activity) &#123; Log.d(TAG,"onActivityResumed"); &#125; @Override public void onActivityPaused(Activity activity) &#123; Log.d(TAG,"onActivityCreated"); &#125; @Override public void onActivityStopped(Activity activity) &#123; Log.d(TAG,"onActivityStopped"); mActivityCount--; Log.d(TAG,"onActivityStopped"+"mActivityCount ："+mActivityCount+"activityName："+ activity.getClass().getSimpleName()); if (mActivityCount &lt;= 0 &amp;&amp; !isBackground &amp;&amp; isRun(activity) &amp;&amp; "PlayerActivity".equals(activity.getClass().getSimpleName()) ) &#123; //只有播放器才进行操作判断,如果应用在后台运行 Log.e(TAG, "onActivityStarted: 播放器进入后台" ); isBackground =true; //说明应用进入了后台 PlayerActivity playerActivity = (PlayerActivity) activity; Bundle bundle = playerActivity.onNotificationMsg(); Toast.makeText(MyApplication.this,"播放器进入后台播放",Toast.LENGTH_LONG).show(); //发送显示 notify 广播 Intent intent=new Intent(PlayerNotifyBroadcastReceiver.ACTION_NOTIFY_MESSAGE); intent.setClass(getApplicationContext(),PlayerNotifyBroadcastReceiver.class); Log.e(TAG, "string" +bundle.getString("unitTitle")); intent.putExtra("unitTitle",bundle.getString("unitTitle")); intent.putExtra("unitImage",bundle.getString("unitImage")); sendBroadcast(intent); &#125; &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; Log.d(TAG,"onActivitySaveInstanceState"); &#125; @Override public void onActivityDestroyed(Activity activity) &#123; Log.d(TAG,"onActivityDestroyed"); &#125; &#125;); &#125; /** * 判断应用是否在运行 * @param context * @return */ private boolean isRun(Context context) &#123; ActivityManager activityManager= (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); assert activityManager != null; List&lt;ActivityManager.RunningTaskInfo&gt; runningTasks = activityManager.getRunningTasks(100); boolean isAppRunning = false; String MY_PKG_NAME = "mao.com.backgroundplay"; //100表示取的最大的任务数，info.topActivity表示当前正在运行的Activity，info.baseActivity表系统后台有此进程在运行 for (ActivityManager.RunningTaskInfo info : runningTasks) &#123; if (info.topActivity.getPackageName().equals(MY_PKG_NAME) || info.baseActivity.getPackageName().equals(MY_PKG_NAME)) &#123; isAppRunning = true; Log.i(TAG,info.topActivity.getPackageName() + " info.baseActivity.getPackageName()="+info.baseActivity.getPackageName()); break; &#125; &#125; return isAppRunning; &#125; &#125; 监听后台播放广播123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131 /** * @author maoqitian * @Description: * @date 2019/1/4 0004 10:58 */ public class PlayerNotifyBroadcastReceiver extends BroadcastReceiver &#123; public static final String ACTION_NOTIFY_MESSAGE = "com.besto.beautifultv.ACTION_NOTIFY_MESSAGE"; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction() == null ) return; switch (intent.getAction())&#123; case ACTION_NOTIFY_MESSAGE: String unitTitle = intent.getStringExtra("unitTitle"); String unitImage = intent.getStringExtra("unitImage"); Class&lt;? extends Activity&gt; aClass = AppManager.getInstance().currentActivity().getClass(); if(aClass != null)&#123; NotificationUtils notificationUtils = NotificationUtils.getInstance(); //注意 RemoteView 不支持ConstraintLayout布局 支持FrameLayout, LinearLayout, RelativeLayout notificationUtils.init(context,aClass, R.layout.notification_layout); notificationUtils.showNotification(unitTitle,unitImage); notificationUtils.getmRemoteViews().setTextViewText(R.id.tv_player_des,"正在后台播放："+unitTitle); notificationUtils.update(); &#125; break; &#125; &#125; &#125; ``` ### 当前Activity栈管理（拿到对应的Activity） ``` /** * @author maoqitian * @Description: Activity栈管理(对应播放器中进行添加进栈出栈) * @date 2018/12/29 0029 15:05 */ public class AppManager &#123; private static volatile AppManager instance; private static Stack&lt;Activity&gt; activityStack; public static AppManager getInstance() &#123; if (instance == null) &#123; synchronized (AppManager.class) &#123; if (instance == null) &#123; instance = new AppManager(); &#125; &#125; &#125; return instance; &#125; /** * 添加Activity到stack中 */ public void addActivity(Activity activity) &#123; if (activityStack == null) &#123; activityStack = new Stack&lt;&gt;(); &#125; if (activityStack.contains(activity)) &#123; activityStack.remove(activity); &#125; activityStack.add(activity); &#125; /** * 获取stack中当前的Activity */ public Activity currentActivity() &#123; if (null != activityStack &amp;&amp; null != activityStack.lastElement()) &#123; return activityStack.lastElement(); &#125; return null; &#125; /** * 移除当前的Activity */ public void finishActivity() &#123; if (null != activityStack &amp;&amp; null != activityStack.lastElement()) &#123; finishActivity(activityStack.lastElement()); &#125; &#125; /** * 移除指定的Activity * * @param activity 指定的Activity */ public void finishActivity(Activity activity) &#123; if (activity != null) &#123; activityStack.remove(activity); activity.finish(); activity = null; &#125; &#125; /** * 移除指定Class所对应的Activity */ public void finishActivity(Class&lt;?&gt; cls) &#123; Stack&lt;Activity&gt; activitys = new Stack&lt;Activity&gt;(); for (Activity activity : activityStack) &#123; if (activity.getClass().equals(cls)) &#123; activitys.add(activity); &#125; &#125; for (Activity activity : activitys) &#123; finishActivity(activity); &#125; &#125; /** * 移除所有的Activity */ public void finishAllActivity() &#123; if (activityStack == null) return; for (int i = 0, size = activityStack.size(); i &lt; size; i++) &#123; if (null != activityStack.get(i)) &#123; activityStack.get(i).finish(); &#125; &#125; activityStack.clear(); &#125; &#125; 添加Notification通知（Notification如何加载网络图片（Glide target 或者 直接remoteview 直接设置 bitmap））123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * @author maoqitian * @Description: 通知栏工具类 * @date 2018/12/29 0029 11:12 */ public class NotificationUtils &#123; private NotificationManager mNotificationManager; private Notification mNotification; private Intent mNotificationIntent; private int notifyId = 1; private String mChannelId = "bgPlayChannel"; private RemoteViews mRemoteViews; private static volatile NotificationUtils mInstance; private int mLayoutId; private Context mContext; private NotificationUtils()&#123; &#125; //双重效验锁实现单例 public static NotificationUtils getInstance()&#123; if(mInstance == null)&#123; synchronized (NotificationUtils.class)&#123; if(mInstance == null)&#123; mInstance = new NotificationUtils(); &#125; &#125; &#125; return mInstance; &#125; public void init(Context context, @NonNull Class&lt;?&gt; intentActivity,int layoutId)&#123; mContext = context; mLayoutId = layoutId; mNotificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE); mNotificationIntent = new Intent(mContext, intentActivity); mNotificationIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP|Intent.FLAG_ACTIVITY_SINGLE_TOP); mRemoteViews = new RemoteViews(mContext.getPackageName(),mLayoutId); if (notifyId &lt;= 4) &#123; //最多显示4条通知 notifyId += 1; &#125; &#125; public void showNotification(@NonNull String contentText,String iamgeUrl)&#123; PendingIntent _pendingIntent = PendingIntent.getActivity(mContext, notifyId, mNotificationIntent, PendingIntent.FLAG_UPDATE_CURRENT); Notification.Builder builder = null; //notification channel work if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123; NotificationChannel channel = new NotificationChannel(mChannelId, "liangTV", NotificationManager.IMPORTANCE_HIGH); channel.enableLights(true);//是否在桌面icon右上角展示小红点 channel.setLightColor(Color.RED);//小红点颜色 channel.setShowBadge(true); //是否在久按桌面图标时显示此渠道的通知 mNotificationManager.createNotificationChannel(channel); builder = new Notification.Builder(mContext,mChannelId); &#125; else &#123; builder = new Notification.Builder(mContext); &#125; builder.setSmallIcon(R.drawable.ic_logo); builder.setContentIntent(_pendingIntent); builder.setTicker(contentText); //builder.setCustomContentView(mRemoteViews); // mNotification = builder.build(); //Notification.FLAG_ONLY_ALERT_ONCE 避免8.0在进度更新时候(notify)中多次响铃 mNotification = builder.build(); mNotification.contentView=mRemoteViews; mNotification.flags = Notification.FLAG_NO_CLEAR|Notification.FLAG_ONLY_ALERT_ONCE; mNotification.icon = R.drawable.ic_logo; //使用NotificationTarget（Glide）来加载图片 NotificationTarget notificationTarget = new NotificationTarget(mContext,mRemoteViews,R.id.notification_Image_play,mNotification,notifyId); Glide.with(mContext.getApplicationContext()) // safer! .load(iamgeUrl) .asBitmap() .into( notificationTarget ); mNotificationManager.notify(notifyId, mNotification); &#125; //清除所有推送通知 public void clearAllNotification() &#123; if (mNotificationManager != null) mNotificationManager.cancelAll(); &#125; public RemoteViews getmRemoteViews() &#123; return mRemoteViews; &#125; public void update()&#123; mNotificationManager.notify(notifyId,mNotification); &#125; &#125; 视频后台播放处理（Activity 生命周期 surfacedestory 中不进行释放 player） 对应播放器Activity的各个生命周期方法做相应的播放位置记录（onRestart恢复视频播放 onDestory释放相应资源 onBackPressed中也得需要及时pause视频） 123456789public void surfaceDestroyed(SurfaceHolder holder) &#123; ...... if(ismPauseInBackground())&#123; //尝试进入后台播放不释放播放器，继续播放音频 mMediaPlayer.setDisplay(null); &#125;else &#123; ..... &#125;&#125; 手动设置是否进行后台播放 （使用SharedPreferences） 使用SharedPreferences，获取状态 1SharedPreferences toggleBtnSP = this.getSharedPreferences("toggleButtonState", Context.MODE_PRIVATE);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>音视频相关功能</tag>
        <tag>Notification</tag>
        <tag>ActivityLifecycleCallbacks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络分层以及TCP协议的运输连接管理]]></title>
    <url>%2F2019%2F01%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E4%BB%A5%E5%8F%8ATCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[计算机网络基础对于我们软件开发者来说是很重要的基础知识，不管是日常的开发，抓包，或者网络框架的学习等，计算机网络知识都是基础。而学习计算机网络分层次的体系结构也是最基本的，下面我们就来复习一下计算机网络的体系结构。 计算机网络体系结构 想起大学学习计算机网络的时候，我们一般把计算机网络分为五层协议体系结构，分别为应用层、运输层、网络层、数据链路层、物理层。 计算机网络各层及其协议的集合我们称为网络的体系结构。 五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是TCP/IP四层体系结构，下面来看看对比图：计算机网络体系结构对比图五层协议应用层（application layer） 应用层的任务是通过应用进程间的交互来完成特定的网络应用，进程所指的就是主机正在运行的程序。应用层协议定义的是应用进程间通信和交互的规则（应用协议有很多，比如万维网应用的HTTP,电子邮件协议SMTP,文件传送协议FTP等）；应用层交互的数据单元称为报文。运输层（transport layer） 运输层的作用是让两个主机中进程间之间的通信提供通用的数据服务传输服务，说白了就是在两个主机之间传输应用层的报文。一台主机不可能只有一个进程，所以运输层有复用和分用的功能，复用就是说应用层的多个进程可以同时使用传输层来传输数据，而分用则是指传输层可以分别把传输的数据给到对应的应用层进程 运输层主要有两种控制协议： 运输层控制协议 TCP（Transmission Contrl Protocol） UDP(User Datagram Protocol) 特点 提供面向连接的、可靠的数据传输服务 提供无连接的、尽最大努力（best-effort）的数据传输服务 数据传输单位 报文段 用户数据报 网络层（network layer） 网络层的作用是为分组交换网上的不同主机提供通信服务，在TCP/IP体系结构中网络层使用的IP协议，网络层把运输层传递过来的数据也就是报文段或者用户数据报封装成分组或包进行传送，分组也叫IP数据报 网络层还有另一个作用就是使数据传输源主机的运输层传递的分组能够选择合适的路由器找到目的主机。数据链路层（data link layer） 数据链路层的作用是把网络层传递下来的IP数据报组成帧（frame）数据在两个相邻节点的链路上传递，每一帧包含必要的数据和控制信息（同步信息、地址信息，差错控制等） 物理层（physical layer） 物理层所传递数据单位是比特，作用为将数据链路层的帧变成比特流在两个主机之间传递（作为传递的物理媒介双绞线，同轴电缆、光缆等并不在物理层的协议之内，而是在物理层协议下面，可以认为是第0层，具体看下图）。 两个主机之间数据传递流程 两个主机数据传递也可以用一个简单的例子来说明，就好比两个使用信来彼此联系，寄信人的信就好比是数据，信从最高层传递，也就是寄信人手里，每过一层就相当于包上一个新的信封，写上必要的、交由下一层处理的地址信息。包含多个信封的信件送到收信人手里，收信人从第一层信封拆起，每拆开一个信封后（按照每一层协议进行处理数据），传递到最后收信人取出发信人信件的信息，也就是传递的数据。 TCP/IP 体系结构 我们现在提到的TCP/IP并不是单指TCP和IP这两个具体的协议，而是表示因特网所使用的整个TCP/IP协议族。TCP/IP协议可以为各式各样的应用提供服务，同时TCP/IP协议也允许协议在格式各样的网络构成的互联网上运行。 TCP协议的运输连接管理 经过前面的网络分层了解，我们都知道运输层有两个重要的协议TCP和UDP,而UDP协议传输是无连接的、不可靠的，所以也就不存在连接管理这一说；而TCP协议是面向连接的，所以才会有连接管理。TCP协议的主要特点 TCP是面向连接的运输层协议，好比打电话，通话前输入号码拨打，等待连接，打完后需要挂断电话。 每一个TCP连接只能有两个端点，TCP连接只能是点对点的 TCP提供可靠的交付服务。还是打电话的例子，电话号码指定就是你需要找的人，打通了电话才能通话。 TCP 提供全双工通信，全双工通信双方既是发送方也是接收方，允许通信双方的应用进程在任何时候都能发送数据。 面向字节流。TCP中的“流”指的是流入到进程或者从进程流出的字节序列。TCP并不管字节流的含义、大小，只保证传递的字节流和接收的字节流是完全一样的。“三次握手” 通过TCP协议的特点，我们知道TCP是面向连接的协议，TCP传递的报文则是通过运输连接来处理的。TCP运输连接的建立和释放是每一次面向连接通信中必不可少的过程。 TCP运输连接的管理就是使运输连接的建立和释放都能正常的运行 运输连接的三个阶段：连接建立，数据传送，连接释放 TCP 连接建立 TCP连接的建立采用客户服务器的方式。什么意思呢？也就是主动发起连接建立的应用进程叫做客户（client）,而被动等待连接建立的应用进程叫做服务器（server）。 TCP连接的建立也叫“三次握手”建立连接，我们先看看TCP三次握手建立连接示意图： TCP建立连接过程： 首先连接未建立之前客户和服务器进程都处于关闭状态（CLOSE）。 其次开始建立连接，A客户进程是主动打开连接的，B服务器进程则是被动打开连接，A和B两端首先创建传输控制块TCB（Transmission Control Block，TCB存储了每一个连接中的一些重要信息，如：TCP连接表，到发送和接收缓存的指针，到重传队列的指针，当前发送和接收的序号等），然后A向B发送请求报文段，这时TCP数据报文首部中的同部位SYN=1，初始序号seq=x（表示数据段开始的序号），TCP规定SYN=1的报文是不能携带数据的，但是要消耗一个序号，这时候A的状态变成同步已发送状态（SYN-SENT）；B创建了TCB之后则会变成收听（LISTEN）状态。 B收到A发来的请求连接报文后，如果同意建立连接，则会向A发送确认报文。B向A发送的确认报文SYN位和ACK位都是1，确认序号为ack=x+1(前面A发送请求已经消耗了x序号)，同时B发送的报文初始序号为y，这时B状态为同步收到（SYN-RCVD）状态。 最后A在收到B的确认报文之后，还要再次向B发送一次确认连接的报文，A发送的再次确认报文段的ACK位为1，确认h号ack=y+1（前面B发送的初始序号已经消耗了y序号），下一个报文段初始序号seq=x+1（TCP规定ACK报文可以携带数据，但是如果不携带数据则不用消耗序号，所以这里序号仍然为x+1），这时候A的状态变成了已建立连接（ESTABLISHED）状态,TCP连接已经建立，B在收到再次确认报文也变成已建立连接（ESTABLISHED）状态。到此TCP连接建立过程完成。 这就是TCP建立连接三次握手的过程 为什么是三次握手？ 通过前面的流程走下来，我们了解到TCP的三次握手就是A和B三次交互的过程最终建立了连接，到这里你可能会有一个疑问，为什么是三次握手建立连接，两次握手建立连接好像也是可行的？ 三次握手的原因为：发送的报文是会失效的，而三次握手就是为了防止已失效的请求报文突然又传送到服务端。还是上面的A和B例子，如果A发送请求报文赢网络滞后原因延迟让B接收到，本来A发送的报文已经失效，而B在延迟接收到该报文之后并确认与A连接，但是A已经认为发到B的报文已经失效，则不会再次发送报文到B，这时候B确认与A连接则一直砸等待A发送数据，则会造成B的资源白白等待A而浪费，所以多加一次确认握手，这时B没有收到再次确认则不会建立连接，避免出现资源浪费。“四次握手”TCP连接释放 TCP经过三次握手建立连接之后，客户和服务器发送完数据之后，还需要释放连接，下面我们来分析一个TCP连接释放的过程。 TCP连接释放过程是四次握手，我们先看看过程示意图 TCP连接释放过程： 首先，A和B双方数据传输结束，此时他们都处于已建立连接（ESTABLISHED）状态，这时A进程先向TCP发出连接释放报文，并停止发送数据，主动关闭TCP连接，A此时进入终止等待1（FIN-WAIT-1）状态。这时A发送的连接释放报文终止控制位FIN=1，释放报文的序号seq=u（u应该等于A前面传递数据的最后一个字节序号加上1，这里不懂前面发送数据序号数值，直接用u代替），TCP规定即使FIN报文段不携带数据也是要消耗一个序号的。 B服务器的应用进程在收到A发送的连接释放报文后，即向A发出确认报文，然后B进入关闭等待（CLOSE-WAIT）状态，确认序号为ack=u+1，而B进程发送报文的序号seq=v(v理论上等于B前面传递数据的最后一个字节序号加上1，这里不懂前面发送数据序号数值，直接用v代替)，此时A到B的连接已经断开了，但是此时TCP的连接处于半关闭（half-close）状态，因为B到A的连接还没有关闭（全双工通信）,也就是说此时B向A发送数据，A还是要接收的，但是A已经不能在向B发送数据（注意数据和报文不是一个概念）。 A在收到B发送的确认报文之后就进入终止等待2（FIN-WAIT2）状态。 B在发送确认报文之后，并且已经没有数据发送给A，则B的应用进程就会通知TCP释放连接；B发出的连接释放报文段FIN=1，序号为seq=w（在半关闭状态B可以又向A发送了数据），确认号必须是和前面发出确认报文一样ack=u+1，此时B就进入了最后确认状态（LAST-ACK）状态。 A在收到B发送的释放连接报文段后，还必须在向B发出确认，发出的确认报文段ACK=1，报文序号为seq=u+1（同理FIN报文必须要消耗一个序号），ack=w+1，此时A进入到时间等待（TIME-WAIT）状态。此时TCP的连接还没有断开，A必须经过时间等到计时器设置的2MLS时间之后，才会进入到关闭（CLOSED）状态。 B只要收到了A发出的确认报文，就进入了关闭（CLOSED）状态。 到此，这就是TCP连接释放四次握手的过程。想必你到此肯定会有疑问，前面A释放关闭过程的MSL是什么，为什么要等待2MSL时间呢？ MSL叫做最长报文段寿命，1MSL=2分钟，也就是说A发出确认释放报文到进入到关闭（CLOSED）状态需要4分钟时间。 另一个是等待2MLS的原因：首先是为了保证A发送的最后一个确认报文能够到达B，在A发送的最后一个确认报文到B的过程中该报文有可能会出现丢失，此时B处于最后确认（LAST-ACK）状态，B接收不到A发出的确认报文则会超时重传四次握手的第二、第三次握手，也就是FIN+ACK报文，A收到之后就会再次发出确认释放连接报文到B，重置2MLS时间等待计时器，以此保证B能收到A发出的确认报文。其次，另一个原因就是在TCP连接管理中提到的防止失效的连接请求报文段出现，导致资源浪费。TCP 报文首部示图 看到这里，你也许还是会有疑问，FIN，ACK，SYN这些都是啥，他们都是TCP报文首部的组成，TCP报文是个极其复杂的东西，这里就不做深入的讨论。 最后说点 TCP的三次握手和四次握手在面试中也是经常被问到的问题，通过这一篇文章，我又把大学课程的知识重新拾了回来，也希望对看到这篇文章的朋友有所帮助。文章中如果有错误，请大家给我提出来，大家一起学习进步，如果觉得我的文章给予你帮助，也请给我一个喜欢和关注。 参考资料 《计算机网络》第六版 link]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP/IP</tag>
        <tag>三次握手</tag>
        <tag>四次握手</tag>
        <tag>计算机网络体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的线程池和作用]]></title>
    <url>%2F2019%2F01%2F20%2FJava%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[在Java开发中，多线程执行任务是很常见的，Java也提供了线程类Thread来让我们方便创建一个线程如下代码所示 Thread开启线程123456new Thread()&#123;@Overridepublic void run() &#123; ..... &#125;&#125;.start(); 这样创建新的线程有几个缺点 每次要开启新的线程都需要创建一个，性能差 线程随意创建，缺乏统一的管理 不能做到线程的中断 处理上面的这些问题，我们就需要使用线程池来管理线程。 线程池描述 Java SE5d的java.util.concurrent包 提供了Executor(执行器)来管理线程对象。Executor是一个接口，而ExecutorService继承了Excutor接口，ExecutorService是一个具有生命周期的Executor，它知道如何构建恰当的上下文来执行Runnable对象。而ExecutorService对象是使用Executors的静态方法得到Java中的线程池 Executor接口实现1234567891011121314public interface Executor &#123; /** * Executes the given command at some time in the future. The command * may execute in a new thread, in a pooled thread, or in the calling * thread, at the discretion of the &#123;@code Executor&#125; implementation. * * @param command the runnable task * @throws RejectedExecutionException if this task cannot be * accepted for execution * @throws NullPointerException if command is null */ void execute(Runnable command);&#125; Java 的四种线程池 Java中为我们提供了四种线程池，他们分别是FixedThreadPool、CachedThreadPool、ScheduledThreadPool、SingleThreadExector FixedThreadPool 创建方式为使用Executors的newFixedThreadPool()方法来创建，这种线程池的线程数量是固定的，可以看到他的静态方法需要传入线程的数量，在空闲状态下不会被系统回收，除非它被关闭了。当它的所有线程都在执行任务的时候，新加入的线程就会出来等待状态，等到有线程空闲，新任务才会被执行,如果新任务加入时线程池中有空闲的线程，则意味着它可以快速响应处理任务。12345678910111213141516171819 public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; /* * 获取使用方法 */Runnable r=new Runnable()&#123; @Override run()&#123; ..... &#125;&#125; ExecutorService executor = Executors.newFixedThreadPool(2);executor.execute(r) CachedThreadPool 创建方式为使用Executors的newCachedThreadPool()方法来创建，由其静态方法可以看出，他的线程数是Integer.MAX_VALUE，可以说他的线程数是无限大，也就是说只要有任务，线程就会立即执行，但是它的每一个线程在空闲状态下是有超时机制的，这个时间为60秒，只要线程空闲时间超过60秒该线程就会被回收，如果所有的线程都处于由空闲状态并且超过了60秒，则相当于线程池中没有任何，线程，也就是说这时的线程池是不占用任何资源的，所以这个线程池比较适合执行大量的耗时较少的任务 12345678910111213141516171819public static ExecutorService newCachedThreadPool() &#123;return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; /* * 获取使用方法 */ Runnable r=new Runnable()&#123; @Override run()&#123; ..... &#125; &#125; ExecutorService executor = Executors.newCachedThreadPool(); executor.execute(r) ScheduledThreadPool 创建方式为使用Executors的newCachedThreadPool()方法来创建，这种线程池的核心线程数是固定的，而非核心线程数据是没有限制的，并且当非核心线程空闲的的时候该线程就会被立即回收，所以我们可以使用他来操作定时任务和重复的任务（和Task TimeTask 有些像）1234567891011121314151617181920212223242526public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123;super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125;/* * 获取使用方法 */Runnable r=new Runnable()&#123; @Override run()&#123; ..... &#125; &#125; ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); // 1000ms 后执行任务 executor.schedule(r,1000,TimeUnit.MICROSECONDS) // 延迟1000ms 每隔1000ms 重复执行 任务 executor.scheduleAtFixedRate(r,1000,1000,TimeUnit.MICROSECONDS) SingleThreadExector 创建方式为使用Executors的newCachedThreadPool()方法来创建，这种线程只有唯一一个核心线程，并且保证所有执行的的任务都在这一个线程中执行，并且是顺序执行，也就不用在考虑线程同步的问题了。1234567891011121314151617181920212223public static ExecutorService newSingleThreadExecutor() &#123;return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; /* * 获取使用方法 */ ExecutorService executor = Executors.newSingleThreadExecutor(); executor.execute(r) Runnable r=new Runnable()&#123; @Override run()&#123; ..... &#125; &#125; ExecutorService executor = Executors.newSingleThreadExecutor(); executor.execute(r) 线程池核心构造方法 通过上面对Java四种线程池的介绍,我们可以发现最终都是新建ThreadPoolExecutor对象，也就是说ThreadPoolExecutor才是线程池的核心实现。 ThreadPoolExecutor 比较常用的一个构造方法 1234567891011121314151617181920212223242526272829 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler); &#125; //参数含义corePoolSize：默认情况下核心线程数会一直存在，不管是否处于闲置状态，但是如果线程池设置了核心线程数，也就是ThreadPoolExecutor的allowCoreThreadTimeOut这个boolean为true，如果核心线程数为零，则allowCoreThreadTimeOut的值为true，超时时间为keepAliveTime的值,也就是CachedThreadPool线程池的所有线程都能够回收的原因，他的核心线程数为零,也就是没有核心线程maximumPoolSize：最大线程数keepAliveTime：非核心线程超时时长，如果allowCoreThreadTimeOut的值为true，则该超时时长也会作用于空闲状态的核心线程unit：超时时长的时间单位 TimeUnit.MILLISECONDS/SECONDS/MINUTES(毫秒/秒/分钟)workQueue：线程任务队列，存放线程任务threadFactory：线程池线程生产工厂，为线程池创建新线程 //我们看到构造放中还有一个defaultHandler参数，他其实是RejectedExecutionHandler对象defaultHandler：当线程队列满了，或者线程任务无法执行则用该参数抛出通知RejectedExecutionException，这里构造方法暂时没用到 在Android中我们可以写自己的线程管理类接，下面就来实现一个自己的线程池管理类来管理我们的线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Created by 毛麒添 on 2018/8/1 0010. * 线程管理类，线程池为单例 */public class ThreadManager &#123;private static ThreadPool mThreadPool;public static ThreadPool getmThreadPool()&#123; if (mThreadPool==null)&#123; synchronized (ThreadManager.class)&#123; if(mThreadPool==null)&#123; //线程安全 mThreadPool=new ThreadPool(5,10,1L); &#125; &#125; &#125; return mThreadPool;&#125;//线程池public static class ThreadPool&#123; private int corePoolSize;//核心线程数 5 private int maximumPoolSize;//最大线程数 10 private long keepAliveTime;//线程休眠时间 1秒 private ThreadPoolExecutor executor; private ThreadPool( int corePoolSize, int maximumPoolSize,long keepAliveTime)&#123; this.corePoolSize=corePoolSize; this.maximumPoolSize=maximumPoolSize; this.keepAliveTime=keepAliveTime; &#125; public void execute(Runnable runnable)&#123; /** * int corePoolSize, 核心线程数 * int maximumPoolSize, 最大线程数 * long keepAliveTime, 线程休眠时间 * TimeUnit unit, 时间单位 * BlockingQueue&lt;Runnable&gt; workQueue, 线程队列 * ThreadFactory threadFactory, 生成线程的工厂 */ if(executor==null)&#123; executor = new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime, TimeUnit.SECONDS,new LinkedBlockingQueue&lt;Runnable&gt;(), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy()); &#125; //核心线程也有超时机制 executor.allowCoreThreadTimeOut(true); executor.execute(runnable); &#125; //取消任务，从任务队列中将其移除 public void cancelTask(Runnable runnable)&#123; if(runnable!=null)&#123; executor.getQueue().remove(runnable); &#125; &#125; &#125;&#125;//使用ThreadManager.getmThreadPool().execute(new Runnable() &#123; @Override public void run() &#123; //执行任务 &#125; &#125;); 最后说点 以上这就是我所了解的线程池知识，如果有错，请给我留言指出，大家一起学习进步。 参考资料: 《Android开发艺术探索》 《Java编程思想》(第四版)]]></content>
      <categories>
        <category>Java基础回顾</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限机制解析]]></title>
    <url>%2F2019%2F01%2F19%2FAndroid%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[从Android M（6.0 API级别23）开始，用户开始在应用运行时向其授予权限，而不是在应用安装时授予。此方法可以简化应用安装过程，因为用户在安装或更新应用时不需要授予权限。 权限介绍 权限机制的目的是保护用户的隐私，Android应用程序必须请求访问敏感用户数据（如联系人和短信）以及某些系统特性（如照相机和互联网）的许可。根据该特征，系统可以自动授予许可，或者提示用户批准请求。 如果设备运行的是 Android 6.0 或更高版本，或者应用的目标 SDK 为 23 或更高：应用必须在清单文件中中列出权限，并且它必须在运行时请求其需要的每项危险权限。用户可以授予或拒绝每项权限，且即使用户拒绝权限请求，应用仍可以继续运行有限的功能。 权限类别正常权限 正常权限不会给用户的隐私带来风险，如果你在清单文件（AndroidManifest.xml）中加入了正常权限声明，则安卓系统会自动授予App应用该权限，如下列出了正常权限 1234567891011121314151617181920212223242526272829303132333435363738android.permission.ACCESS_LOCATION_EXTRA_COMMANDSandroid.permission.ACCESS_NETWORK_STATEandroid.permission.ACCESS_NOTIFICATION_POLICYandroid.permission.ACCESS_WIFI_STATEandroid.permission.ACCESS_WIMAX_STATEandroid.permission.BLUETOOTHandroid.permission.BLUETOOTH_ADMINandroid.permission.BROADCAST_STICKYandroid.permission.CHANGE_NETWORK_STATEandroid.permission.CHANGE_WIFI_MULTICAST_STATEandroid.permission.CHANGE_WIFI_STATEandroid.permission.CHANGE_WIMAX_STATEandroid.permission.DISABLE_KEYGUARDandroid.permission.EXPAND_STATUS_BARandroid.permission.FLASHLIGHTandroid.permission.GET_ACCOUNTSandroid.permission.GET_PACKAGE_SIZEandroid.permission.INTERNETandroid.permission.KILL_BACKGROUND_PROCESSESandroid.permission.MODIFY_AUDIO_SETTINGSandroid.permission.NFCandroid.permission.READ_SYNC_SETTINGSandroid.permission.READ_SYNC_STATSandroid.permission.RECEIVE_BOOT_COMPLETEDandroid.permission.REORDER_TASKSandroid.permission.REQUEST_INSTALL_PACKAGESandroid.permission.SET_TIME_ZONEandroid.permission.SET_WALLPAPERandroid.permission.SET_WALLPAPER_HINTSandroid.permission.SUBSCRIBED_FEEDS_READandroid.permission.TRANSMIT_IRandroid.permission.USE_FINGERPRINTandroid.permission.VIBRATEandroid.permission.WAKE_LOCKandroid.permission.WRITE_SYNC_SETTINGScom.android.alarm.permission.SET_ALARMcom.android.launcher.permission.INSTALL_SHORTCUTcom.android.launcher.permission.UNINSTALL_SHORTCUT 危险权限 查看危险权限 1可以通过adb shell pm list permissions -d -g进行查看(Windows使用adb 命令首先需要自行配置环境变量) - 危险权限会授予应用访问用户隐私数据的权限。如果您的应用在清单中列出了正常权限，系统将自动授予该权限。如果您列出了危险权限，则用户在清单文件中列出的同时还必须在触发使用相应功能的时候让用户同意应用使用这些权限 ![危险权限列表](https://github.com/maoqitian/MaoMdPhoto/raw/master/Android%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90/%E5%8D%B1%E9%99%A9%E6%9D%83%E9%99%90.png) 由危险权限的表可以看出，危险权限都是一组一组出现的，并且你只要授予一组权限的其中一个，那么该组危险权限的其他权限也同样被授予了（例如，如果某应用已经请求并且被授予了READ_CONTACTS 权限，然后它又请求WRITE_CONTACTS，系统将立即授予该权限）使用权限 当我们新建一个Android应用的时候，默认应用是没有有申请任何权限的，我们不管需要什么权限，首先需在清单文件中使用标签声明12345&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.android.app.myapp" &gt; &lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt; ... &lt;/manifest&gt; 权限相关API检查权限 当我们应用需要危险的权限的时候，每次执行操作都需要检查是否授予了危险权限，检查是否具有该权限我们使用ContextCompat.checkSelfPermission() 方法12345int permissionCheck = ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.WRITE_CALENDAR); //如果具有该权限，则方法返回PackageManager.PERMISSION_GRANTED，并且应用可以//继续操作。如果应用不具有此权限，方法将返回 PERMISSION_DENIED，且应用必须明确向用户要求权限 请求获取权限 当我们应用某个功能操作需要危险权限的申请，则我们可以调用ActivityCompat.requestPermissions的方法来获取相应的权限。该方法异步运行：它会立即返回，并且在用户响应对话框之后，系统会使用结果调用应用的回调方法，将应用传递的相同请求代码传递到ActivityCompat.requestPermissions方法。 以下代码可以检查应用是否具备读取用户联系人的权限，并根据需要请求该权限1234567891011121314151617181920212223242526272829303132if (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; //是否具有该读取联系人权限 if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) &#123; //判断是否需要向用户解释，为什么需要这些权限。有时候用户会不理解应用程序为什么需要这些权限。 //这个方法只有在APP请求过某一权限且用户禁止APP使用该权限的时候返回true。在用户授权了权限和禁止权限时勾选了“Don't ask again”选项的情况下都会返回false //也就是说如果进入到这里，就说明该权限曾经被拒绝过 /** 被拒绝又想再次申请可跳转应用信息界面授予权限 Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.setData(Uri.fromParts("package", context.getPackageName(), null)); startActivity(intent); */ &#125; else &#123; //申请权限 ActivityCompat.requestPermissions(thisActivity, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. &#125;&#125; 处理权限请求的响应 当权限申请提示框与用户交互的时候，我们开发人员必须知道用户到底是否同意应用的权限申请。所以用户响应时，Android系统将调用应用的 onRequestPermissionsResult() 方法，向其传递用户响应 延续上面读取联系人的例子 1234567891011121314151617181920212223242526272829303132/** * * @param requestCode 申请权限传入的请求码 * @param permissions 申请权限的数组 * @param grantResults 请求的结果（用于区分上一个参数permissions中的权限有没有被授予，permissions和grantResults两个数组大小是一样的，具体值和上方提到的PackageManager中的两个常量做比较） */@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123; // If request is cancelled, the result arrays are empty. if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // permission was granted, yay! Do the // contacts-related task you need to do. //用户同意权限申请，继续应用操作 &#125; else &#123; // permission denied, boo! Disable the // functionality that depends on this permission. //用户拒绝权限申请，提示用户应用的操作需要该权限 &#125; return; &#125; // other 'case' lines to check for other // permissions this app might request &#125; &#125; 运行时权限小例子 读取联系人列表完整例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 public class MainActivity extends AppCompatActivity &#123; private static final int MY_PERMISSIONS_REQUEST_READ_CONTACTS = 1; //保存联系人 public List&lt;String&gt; list = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); readContacts(); &#125; //读取联系人 public void readContacts()&#123; if(ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED)&#123; //申请权限 //申请权限 if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_CONTACTS)) &#123; //之前申请权限的时候拒绝过 ，向用户解释为什么需要该权限 Toast.makeText(MainActivity.this, "Permission Denied，Show an expanation to the user *asynchronously* -- don't block", Toast.LENGTH_SHORT).show(); &#125;else &#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); &#125; &#125;else &#123; //获取联系人列表 list=readContact(); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; if(requestCode == MY_PERMISSIONS_REQUEST_READ_CONTACTS)&#123; if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //获取联系人列表 list=readContact(); &#125; else &#123; // Permission Denied Toast.makeText(MainActivity.this, "Permission Denied", Toast.LENGTH_SHORT).show(); &#125; return; &#125; super.onRequestPermissionsResult(requestCode, permissions, grantResults); &#125; //读取联系人 public List&lt;String&gt; readContact()&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Cursor cursor = null; try &#123; //cursor指针 query询问 contract协议 kinds种类 cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null); if (cursor != null) &#123; while (cursor.moveToNext()) &#123; String displayName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); list.add(displayName + '\n' + number); &#125; &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) &#123; cursor.close(); &#125; &#125; return null; &#125; &#125; //清单文件中别忘了加上 &lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt; 热门框架了解 AndPermission（严振杰大大的框架） 项目地址 https://github.com/yanzhenjie/AndPermission 该框架也是日常开发用得比较多的一个框架，该框架一句话搞定权限申请，还是比较方便的 12345678910111213AndPermission.with(this).runtime() .permission(Permission.Group.STORAGE) .onGranted(new Action&lt;List&lt;String&gt;&gt;() &#123; @Override public void onAction(List&lt;String&gt; data) &#123; &#125; &#125;).onDenied(new Action&lt;List&lt;String&gt;&gt;() &#123; @Override public void onAction(List&lt;String&gt; data) &#123; &#125; &#125;).start(); 通过阅读框架源码，可以看到这个框架的核心就是PermissionActivity,它是一个没有界面的Activity,所有的权限申请都由它来发起，并进行相应操作的回调，结合前面了解的运行时权限的知识，相信这个Activity你可以很轻易就了解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175 /** * &lt;p&gt; * Request permission. * &lt;/p&gt; * Created by Yan Zhenjie on 2017/4/27. */ public final class PermissionActivity extends Activity &#123; private static final String KEY_INPUT_OPERATION = "KEY_INPUT_OPERATION"; private static final int VALUE_INPUT_PERMISSION = 1; private static final int VALUE_INPUT_PERMISSION_SETTING = 2; private static final int VALUE_INPUT_INSTALL = 3; private static final int VALUE_INPUT_OVERLAY = 4; private static final int VALUE_INPUT_ALERT_WINDOW = 5; private static final String KEY_INPUT_PERMISSIONS = "KEY_INPUT_PERMISSIONS"; private static RequestListener sRequestListener; /** * Request for permissions. */ public static void requestPermission(Context context, String[] permissions, RequestListener requestListener) &#123; PermissionActivity.sRequestListener = requestListener; Intent intent = new Intent(context, PermissionActivity.class); intent.putExtra(KEY_INPUT_OPERATION, VALUE_INPUT_PERMISSION); intent.putExtra(KEY_INPUT_PERMISSIONS, permissions); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); &#125; /** * Request for setting. */ public static void permissionSetting(Context context, RequestListener requestListener) &#123; PermissionActivity.sRequestListener = requestListener; Intent intent = new Intent(context, PermissionActivity.class); intent.putExtra(KEY_INPUT_OPERATION, VALUE_INPUT_PERMISSION_SETTING); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); &#125; /** * Request for package install. */ public static void requestInstall(Context context, RequestListener requestListener) &#123; PermissionActivity.sRequestListener = requestListener; Intent intent = new Intent(context, PermissionActivity.class); intent.putExtra(KEY_INPUT_OPERATION, VALUE_INPUT_INSTALL); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); &#125; /** * Request for overlay. */ public static void requestOverlay(Context context, RequestListener requestListener) &#123; PermissionActivity.sRequestListener = requestListener; Intent intent = new Intent(context, PermissionActivity.class); intent.putExtra(KEY_INPUT_OPERATION, VALUE_INPUT_OVERLAY); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); &#125; /** * Request for alert window. */ public static void requestAlertWindow(Context context, RequestListener requestListener) &#123; PermissionActivity.sRequestListener = requestListener; Intent intent = new Intent(context, PermissionActivity.class); intent.putExtra(KEY_INPUT_OPERATION, VALUE_INPUT_ALERT_WINDOW); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Intent intent = getIntent(); int operation = intent.getIntExtra(KEY_INPUT_OPERATION, 0); switch (operation) &#123; case VALUE_INPUT_PERMISSION: &#123; String[] permissions = intent.getStringArrayExtra(KEY_INPUT_PERMISSIONS); if (permissions != null &amp;&amp; sRequestListener != null) &#123; requestPermissions(permissions, VALUE_INPUT_PERMISSION); &#125; else &#123; finish(); &#125; break; &#125; case VALUE_INPUT_PERMISSION_SETTING: &#123; if (sRequestListener != null) &#123; RuntimeSettingPage setting = new RuntimeSettingPage(new ContextSource(this)); setting.start(VALUE_INPUT_PERMISSION_SETTING); &#125; else &#123; finish(); &#125; break; &#125; case VALUE_INPUT_INSTALL: &#123; if (sRequestListener != null) &#123; Intent manageIntent = new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES); manageIntent.setData(Uri.fromParts("package", getPackageName(), null)); startActivityForResult(manageIntent, VALUE_INPUT_INSTALL); &#125; else &#123; finish(); &#125; break; &#125; case VALUE_INPUT_OVERLAY: &#123; if (sRequestListener != null) &#123; OverlaySettingPage settingPage = new OverlaySettingPage(new ContextSource(this)); settingPage.start(VALUE_INPUT_OVERLAY); &#125; else &#123; finish(); &#125; break; &#125; case VALUE_INPUT_ALERT_WINDOW: &#123; if (sRequestListener != null) &#123; AlertWindowSettingPage settingPage = new AlertWindowSettingPage(new ContextSource(this)); settingPage.start(VALUE_INPUT_ALERT_WINDOW); &#125; else &#123; finish(); &#125; break; &#125; default: &#123; throw new AssertionError("This should not be the case."); &#125; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; if (sRequestListener != null) &#123; sRequestListener.onRequestCallback(); &#125; finish(); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (sRequestListener != null) &#123; sRequestListener.onRequestCallback(); &#125; finish(); &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; return true; &#125; return super.onKeyDown(keyCode, event); &#125; @Override public void finish() &#123; sRequestListener = null; super.finish(); &#125; /** * permission callback. */ public interface RequestListener &#123; void onRequestCallback(); &#125;&#125; 最后说点 看过不一定记得，记得不一定会写，会写不代表不会忘记，所以记下来是最好的选择。好了，又通过一篇文章让我对Android运行时权限有了更深入的了解。文章中如果有错误，请大家给我提出来，大家一起学习进步，如果觉得我的文章给予你帮助，也请给我一个喜欢和关注。 参考链接: 《Android进阶之光》 在运行时请求权限 系统权限]]></content>
      <categories>
        <category>Android基础回顾</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android运行时权限</tag>
        <tag>permission</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java接口和抽象类是什么，有什么区别]]></title>
    <url>%2F2019%2F01%2F16%2F%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象(abstract)和接口(interface)在Java中都是关键字，也就说明他们足够重要，而抽象类和接口为我们面向对象编程提供了非常大的帮助。下面我们就一起来回顾这基础知识。 抽象类 在构建某些未实现方法的类时，你可能会第一个想到接口，但是抽象类也是实现这个目的一种重要而必要的工具。 创建抽象类需要用到abstract关键字来修饰类，我们希望通过这个通用的类操作一系类方法，如果没有具体的内容，这个抽象类的意义只有一个，就是不让其他类实例化这个抽象类的对象，只能实例化它的子类对象；要达到操控，Java给我们提供了抽象方法的机制，抽象方法也是使用abstract关键字来修饰，包含抽象方法的类就叫做抽象类抽象类特点 1.抽象类和抽象方法必须用abstract关键字修饰 2.抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者接口 3.抽象类不能实例化，也就是说不能new出来，抽象类必须由子类实例化，这其实也就是多态的一种，抽象类多态（为什么抽象类不能实例化？ 如果抽象类实例化，实例化的抽象类对象意思就可以调用抽象类的抽象方法，但是抽象方法是没有具体实现的，也就没有任何意义，所以抽象类不能实例化） 4.抽象类的子类要么是抽象类(实例中的Car类)，要么就重写抽象类中的抽象方法（实例中的Jetta类） 5.一个类只能继承一个抽象类，抽象类也可以继承抽象类（实例中的SuperCar 类）抽象类成员特点： 1.成员既可以是常量也可以是变量，但是abstract不能修饰成员变量，变量的值是不固定的，无法抽象 2.抽象类也有构造方法，他的意义在于子类可以访问父类的初始化数据（实例中Jetta构造方法 super()调用了抽象父类构造方法） 3.成员方法既可以抽象的，也可以是非抽象的，抽象方法一般是强制要求子类去实现的方法，非抽象方法一般是重复的代码，可以提高代码复用性 4.abstract关键字不能与static关键字（原理和抽象类不能实例化其实是一个道理，staticx修饰的抽象方法不需要实例化可以直接调用，这显然是没有意义的）、final关键字(final修饰的方法子类不能重写，abstract修饰的方法子类强制重写)、private关键同时出现（private修饰的方法子类不能访问） 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @Author: mao.qitian * @Date: 2018/8/11 0011 16:25 * @Description: 汽车抽象类 */public abstract class Car &#123;public Car()&#123; System.out.println("抽象类的构造方法被调用");&#125;public void driver()&#123; System.out.println("所有汽车都能驾驶");&#125;//汽车的速度public abstract void speed();&#125; /** * @Author: mao.qitian@gxxmt.com * @Date: 2018/8/11 0011 16:29 * @Description: 捷达 */ public class Jetta extends Car&#123; public Jetta()&#123; super(); &#125; @Override public void speed() &#123; System.out.println("开完兰博基尼再开捷达速度上无法适应"); &#125; &#125; /** * @Author: mao.qitian * @Date: 2018/8/11 0011 22:39 * @Description: 超跑 */public abstract class SuperCar extends Car &#123;//超跑的价格public abstract void expensive ();&#125;/** * @Author: mao.qitian * @Date: 2018/8/11 0011 16:27 * @Description: 兰博基尼 */ public class Lamborghini extends SuperCar &#123;@Overridepublic void speed() &#123; System.out.println("兰博基尼速度两秒破百");&#125;@Overridepublic void expensive() &#123; &#125;&#125; 接口（interface） 接口使抽象的更向前迈进了一步，interface关键字修饰方法产生的是完全抽象的类，它允许创建者定义方法名，传参和返回类型，但是它没有任何方法体，只提供了形式（规则），而未提供任何具体实现。接口的特点 1.接口使用interface关键字代替class修饰类， 2.类实现接口用implement表示 3.和抽象类一样，接口也不能实例化，只能由实现了接口的类来进行实例化 4.接口的子类可以是抽象类，也可以是具体类，具体类要重写接口的抽象方法 接口成员特点 1.接口中定义的变量都是常量，默认修饰符为 public static final 2.接口没有构造方法 1234567891011121314151617/** * @Author: mao.qitian * @Date: 2018/8/12 0012 0:22 * @Description: */public interface A &#123; public void b(); &#125; class C implements A&#123; public C()&#123; super();//调用的是Objetc类的构造方法，方法默认继承Objetc类 &#125; @Override public void b() &#123; &#125; &#125; 3.接口中的成员方法只能是抽象方法，默认修饰符为 public abstract 4.接口中的所以成员方法和变量都是公共的（public） 接口的应用 策略模式：定义一系列算法，把每一个算法封装起来，并且使他们可以相互替换。策略模式使得算法可独立于使用它的客户端而独立变化。三个角色 上下文角色（Context）:操作我们制定策略的上下文环境，使用策略的通用调用 抽象策略角色（Stragety）:策略，算法的抽象，通常是一个接口 策略的实现角色（ConcreteStragety）：实现抽象的策略接口，具体实现这个策略实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 实现学校教师的奖金发放，教师有属性：编号、姓名，教学总工作量，奖金 奖金的计算方法为： x*30 (当职称为教授时) y= x*25 (当职称为副教授时) x*20 (当职称为讲师时) public interface Function &#123; //接口定义抽象方法 （Stragety） public double Money(double x); &#125; public class A implements Function &#123; //教授奖金计算 public double Money(double x) &#123;return x*30; &#125; public class B implements Function &#123; //副教授奖金计算 public double Money(double x) &#123;return x*25; &#125; &#125; public class C implements Function &#123; //讲师奖金计算 public double Money(double x) &#123;return x*20; &#125; &#125; public class myMoney &#123; //上下文角色 Function s; double M;//工时 String name;//教师姓名 String type;//教师职称 int number;//教师编号 public void S(double X,String N,int Num,String Type)&#123; this.M=X; this.name=N; this.number=Num; this.type=Type; &#125; //奖金计算方式 public double getMoney()&#123; if(type.equals("教授")) s=new A(); if(type.equals("副教授")) s=new B(); if(type.equals("讲师")) s=new C(); return s.Money(M); &#125; &#125; myMoney f=new myMoney(); Scanner sc=new Scanner(System.in); System.out.println("请输入职位:"); String Type=sc.next(); System.out.println("请输入姓名:"); String N=sc.next(); System.out.println("请输入编号:"); int Num=sc.nextInt(); System.out.println("请输入工时:"); double X=sc.nextDouble(); f.S(X, N, Num, Type); System.out.println(N+奖金为"+f.getMoney()); 类与类，类与接口，接口与接口之间的关系 类与类之间，一个类只能继承一个类，但是类可以多层继承 类与接口则是实现关系，一个类可以继承一个接口，也可以继承多个接口，也可以继承一个类的同时实现多个接口 接口与接口之间是继承关系，一个接口可以继承另一个接口，也可以继承多个接口12345678910111213141516171819202122/** * @Author: mao.qitian * @Date: 2018/8/12 0012 0:22 * @Description: */ public interface A &#123; public void a(); &#125; interface B &#123; public void b(); &#125; interface C extends B,A&#123; //接口与接口之间继承，多继承 public void c(); &#125; class D implements A,B,C&#123; @Override public void a() &#123; &#125; @Override public void b() &#123; &#125; @Override public void c() &#123; &#125; &#125; 抽象类和接口的区别 类 成员区别 继承关系区别 设计理念区别 抽象类 成员变量可以是常量，也可以是变量，有构造方法，成员方法可以是抽象的也可以是非抽象的 单继承，多层继承 被继承的体现是“is a”的关系，抽象类中定义的是该继承体系的共性功能 接口 成员变量只能是常量，没有构造方法，成员方法只能是抽象的 实现，可以实现多个接口 被继承的体现是“like a”的关系，接口中定义的是该继承体现的扩展功能 最后说点 还是那句话，好记性不如烂笔头，通过这一篇文章，再次巩固了基础知识。如果文章中有写得不对的地方，请给我留言指出，大家一起学习进步。 参考资料: 《Android进阶之光》 《Java编程思想》(第四版)]]></content>
      <categories>
        <category>Java基础回顾</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>interface</tag>
        <tag>abstract</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins+Gitlab+Maven+Tomcat 持续集成，自动部署项目]]></title>
    <url>%2F2019%2F01%2F14%2FJenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[持续集成：Continuous Integration，简称CI，意思是，在一个项目中，任何人对代码库的任何改动，都会触发CI服务器自动对项目进行构建，自动运行测试，甚至自动部署到测试环境。这样做的好处就是，随时发现问题，随时修复。因为修复问题的成本随着时间的推移而增长，越早发现，修复成本越低。当你想要更新你的项目，只要动手提交代码到你的代码仓库，剩余的更新部署操作就只管交由CI服务器来完成就好，这次使用的CI工具是JenKins。 搭建Jenkins持续集成服务器可以分为两大步骤，一是在服务器安装好所需的软件，二是配置我们的持续集成项目 安装所需的各种软件安装启动 Jenkins 从Jenkins官方网站下载最新的rpm包12345678执行命令 rpm -ivh xxx.rpm 安装Jenkins//启动JenKins/etc/init.d/jenkins start 浏览器输入 http://xxx服务器地址:8080///默认端口号是8080 JenKins默认端口号是8080，这与Tomcat默认端口号冲突，所有我们可以把Jenkins的端口号改成我们自己定义的端口号 9090 修改端口号的文件为 /etc/sysconfig/jenkins，字段为JENKINS_PORT12345678//执行命令进行修改，如果碰到无法启动Jnekins,无法启动（如遇此Starting Jenkins bash: /usr/bin/java: No such file or directory错误 ）修改 /etc/init.d/jenkins 加入 /opt/jdk1.8.0_181/bin/java原因//是Java的环境变量没有找到，一般使用centos服务默认安装openjdk，如果自己卸载openJdk并重新安装sun的JDK,则也需要在该文件中加入路径，如图所示vim /etc/sysconfig/jenkins //添加Java地址vim /etc/init.d/jenkins 修改端口无法启动的情况，有可能是服务器防火墙没有添加端口的监听，导致无法访问 12345678vim /etc/sysconfig/iptables 查看是否监听端口(如果配置了自己定义的端口，需要先访问该端口一次才能看到监听) netstat -ntlp //重启防火墙配置（不重启端口还是无法生效）service iptables restart 关闭Jenkins 只需要在访问jenkins服务器的网址url地址后加上exit。例如我jenkins的地址http://localhost:8080/，那么我只需要在浏览器地址栏上输入http://xxx:9090/exit 网址就能关闭jenkins服务.重启Jenkies 12//xxx:8080 是搭建Jenkins服务器地址http://xxx:8080/restart 重新加载配置信息 1http://localhost:8080/reload Jenkins的卸载 1231. 卸载软件：rpm -e jenkins2. 删除遗留文件: find / -iname jenkins | xargs -n 1000 rm -rf 安装jdk123456789101112131415161718192021查看Java相关的包信息： rpm -qa|grep java （或rpm -qa|grep jdk，rpm安装后，包名里没有Java）卸载 yum -y remove java [包名] 例如 yum –y remove java java-1.8.0-openjdk-1.8.0.131-3.b12.el7_3.x86_64 jdk 卸载方法 https://blog.csdn.net/xyj0808xyj/article/details/52444694//解压到指定目录tar -zxvf jdk-8u181-linux-x64.tar.gz -C /opt///编辑配置文件vim /etc/profileexport JAVA_HOME=/opt/jdk1.8.0_181export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$CLASSPATH //更新配置文件source /etc/profile 安装Tomcat 官网下载 Tomcat8.5 直接解压到服务器（注意这里指的服务器是项目部署的服务器，应该是和部署JenKins的服务器不同） 强制关闭 tomcat 命令12345//强制关闭ps -ef|grep tomcat //杀掉无法关闭进程kill -9 XXXX 安装 git (安装在部署JenKins服务器上)12345678910111213141516171819202122232425安装依赖yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidocyum install gcc perl-ExtUtils-MakeMaker如果已经安装了git,但是版本太老，可以先卸载yum remove git 下载git包解压tar -vxf git-2.15.1.tar.gz -C /opt进入git 目录cd /opt/git-2.18.0/执行以下命令make prefix=/usr/local/git allmake prefix=/usr/local/git installecho "export PATH=$PATH:/usr/local/git/bin" &gt;&gt; /etc/profile //配置环境变量source /etc/profile //跟新配置文件git --version 查看git版本 安装 maven(安装在部署JenKins服务器上) 后台项目为spring-boot搭建，需要安装maven 下载 maven 3.5.4123456789执行以下命令tar -zxvf apache-maven-3.3.9-bin.tar.gz -C /opt在/etc/profile文件末尾增加以下配置M2_HOME=/opt/apache-maven-3.5.4 （注意这里是maven的安装路径） export PATH=$&#123;M2_HOME&#125;/bin:$&#123;PATH&#125; 重载/etc/profile这个文件 source /etc/profile GitLab服务器配置 由于公司已经搭建好Gitlab服务器，所以我也没有配置过Gitlab，不过Gitlab配置网上已经有很多资料，可以自行百度。 Jenkins基础工具配置、新建项目配置Jenkins配置 第一次进入Jnekins,首先根据提示找到安装服务器的密码 如果服务器可以联网，则选择他推荐的插件直接安装，如果服务器无法连接外网，只是在公司内网环境，则可以离线下载插件再上传到我们服务器的Jenkin中，离线插件下载地址，这种方式需要耐心，因为需要安装的插件可不止一两个，如果你的服务器不能上网，我这有一份下载好的插件，可以自行去下载（下载地址） 在Jenkins系统管理模块的系统配置中配置我们的Gitlab,需要登录到Gitlab中获取APIToken生成ssh key（在部署Jenkins服务器上生成） 配置SSH KEY ,用于后续项目可以通过Jenkins部署到应用服务器 12345678910//输入命令，一路回车ssh-keygen -t rsa //现在你的私钥被放在了~/.ssh/id_rsa 这个文件里，而公钥被放在了 ~/.ssh/id_rsa.pub 这个文件里 //可以将私钥配置到JneKins的系统设置中，配置框选项是需要Jenkins安装SSH插件的，如下图所示 //公钥则配置到各个应用服务器的这个目录下/root/.ssh/authorized_keys，没有authorized_keys则创建这个文件，如下图所示 //最后测试应用服务器是否都能成功连接，如下图所示 工具配置 接下来还是系统管理模块中的全局工具配置 Jenkins的 JDK、git和maven。前面我们已经把这些工具都给安装了，现在配置到Jenkins中，如下图所示 新建项目配置 新建一个maven项目（没有maven项目选项则需要下载对应插件） 首先配置源码管理，如图 配置项目构建触发器（Gitlab Hook Plugin， Outbound WebHook for build events，Build Authorization Token Root， SuccessBuild Token Trigger插件） 配置maven项目编译 项目构建成功后部署应用服务器的配置 Tomcat重启脚本(应当放在与Tomcat目录同路径下)12345678910111213141516171819202122#! /bin/shecho '####################开始自动部署####################'export JAVA_HOME=/usr/local/jdk1.8.0_181path=`pwd` #当前路径tomcatPath=/data/XXXX/tomcat_gxxmt_8080 #指定tomcat文件目录名称cd ../$tomcatPath/bin #进入tomcat的bin目录PID=$(ps -fu `whoami`|grep tomcat|grep -v grep|awk '&#123;print $2&#125;')if [ -z "$PID" ];then echo "no tomcat process"else./shutdown.sh #停止tomcat服务ficd ../webapps #进入tomcat的webapps目录rm -rf XXXX-apiecho '####################删除完成####################'#rm -fr gxxmt-api.war #删除test文件目录#mv gxxmt-api.war gxxmt-api.war.$(date +%Y%m%d) #备份webapps下的test16 cp $path/test.war ./ #复制test.war到webapps路径下#cd /var/lib/jenkins/workspace/gxxmt-api/gxxmt-api/target/#cp gxxmt-api.war /data/gxxmt/tomcat_gxxmt_8080/webapps/cd ../bin./startup.sh #启动tomcat服务echo '####################部署结束####################' 项目构建成功并发布到了对应服务器执行对应脚本，这里就可以看到JenKins的灵活性，可以配置多台发布的应用服务器的多个Tomcat,灵活自动部署应用服务器配置 项目构建编译部署成功 集成部署遇到的问题问题一 ERROR: Exception when publishing, exception message [Exec timed out or was interrupted after 120,000 ms]（执行脚本没有正常退出，导致部署超时） 解决：脚本执行加入忽略输入（nohup ….） 12345nohup sh /data/gxxmt-api/restart.sh//当我们使用nohup命令的的时候，日志会被打印到nohup.out文件中去。//如果我们不做任何处理，会随着每次的重新启动，nohup.out会越来越大//。所以我在我执行的脚本中添加了cp /dev/null nohup.out 在jenkins项目配置SSH Publishers勾选了Exec in pty，表示执行完脚本立即退出 问题二，Jenkins目录迁移 jenkins主目录迁移，jenkins默认主目录一般都是安装在系统盘，运行一段时间后项目部署的历史版本，日志文件，工作控件都会占用大量的系统空间，这样就会引发系统盘磁盘空间不足，首先我们可以修改jenkins主目录1234567891011//更改主目录vim /etc/sysconfig/jenkinsJENKINS_HOME="/data/jenkins"复制 /var/lib/jenkins/ 目录到 /data目录下修改目录用户权限chown -R jenkins:jenkins /data/jenkins重启 /etc/sysconfig/jenkins restart 其次我们还可以在项目配置中设置丢弃历史构建 问题三，代码提交触发构建 Url is blocked: Requests to the local network are not allowed Gitlab设置Jenkins的webhook地址无法设置 升级新版Gitlab，要允许WebHook，需要在在Gitlab的Admin账户中，在settings标签下面，找到OutBound Request，勾选上Allow requests to the local network from hooks and services ，保存更改即可解决问题（如下图所示） 问题四 Gradle 编译Android 项目 /lib64/libc.so.6: version `GLIBC_2.14’ not found，系统是CentOS 6.9，最高支持glibc的版本为2.12，而研发程序要2.14版本，所以需要升级。 12345678910111213141516171819202122232425262728//查看系统版本cat /etc/redhat-release//查看glibc库版本strings /lib64/libc.so.6 |grep GLIBC_//下载glibc库 并安装#下载wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz wget http://ftp.gnu.org/gnu/glibc/glibc-ports-2.14.tar.gz #解压tar -xvf glibc-2.14.tar.gz tar -xvf glibc-ports-2.14.tar.gz#创建相关目录mv glibc-ports-2.14 glibc-2.14/portsmkdir glibc-build-2.14cd glibc-build-2.14/ #生成C编译的环境yum -y install gcc#编译C../glibc-2.14/configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/binmake# 安装刚才编译好的 libc.somakeinstall # 查看glibc库版本strings /lib64/libc.so.6 |grep GLIBC_ 最后说点 到此，我们的持续集成服务器已经搭建完成，这时候你只要动手提交一下代码到你前面构建触发器设置的分支（一般为主分支），剩余的项目构建，部署等一系列重复繁琐的工作就交由Jenkins帮我们自动完成就可以了，省时又方便。文章中如果有错误，请大家给我提出来，大家一起学习进步，如果觉得我的文章给予你帮助，也请给我一个喜欢或者关注。 参考链接: jenkins的安装与使用（基于 centos 7） jenkins maven Spring Boot git Linux持续集成环境搭建教程 解决SDK升级到27.0.3遇到的GLIBC_2.14 not found]]></content>
      <categories>
        <category>持续集成（CI）</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>CentOS</tag>
        <tag>Jenkins</tag>
        <tag>git</tag>
        <tag>GitLab</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastDFS服务器集群部署和集成客户端到SpringBoot]]></title>
    <url>%2F2019%2F01%2F12%2FFastDFS%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E5%92%8C%E9%9B%86%E6%88%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%B0SpringBoot%2F</url>
    <content type="text"><![CDATA[FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题，同时也能做到在集群环境下一台机子上传文件，同时该组下的其他节点下也备份了上传的文件。做分布式系统开发时，其中要解决的一个问题就是图片、音视频、文件共享的问题和数据备份，分布式文件系统正好可以解决这个需求。FastDFS的服务主要有两个角色Tracker和Storage，Tracker服务用于负责调度storage节点与client通信，在访问上起负载均衡的作用，和记录storage节点的运行状态，是连接client和storage节点的枢纽，Storage用于保存文件 1.FastDFS集群部署整体部署模块图 环境准备 名称 描述 centos系统版本 6.9 libfatscommon FastDFS分离出的一些公用函数包 FastDFS FastDFS主程序 fastdfs-nginx-module FastDFS和nginx的关联模块 nginx nginx1.15.5 安装编译环境1yum install git gcc gcc-c++ make automake autoconf libtool pcre pcre-devel zlib zlib-devel openssl-devel wget vim -y 磁盘安装路径说明 说明 位置 FastDFS所以安装包安装位置 /usr/local/src tracker数据 /data/fdfs/tracker Storage数据 /data/fdfs/Storage 配置文件路径 /etc/fdfs 安装libfatscommon 下载libfatscommon 解压、安装 123unzip libfastcommon-master.zipcd libfastcommon-master./make.sh &amp;&amp; ./make.sh install #编译安装 安装FastDFS 下载FastDFS 解压、安装 12345678unzip fastdfs-master.zipcd fastdfs-master./make.sh &amp;&amp; ./make.sh install #编译安装cp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.confcp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.confcp /etc/fdfs/client.conf.sample /etc/fdfs/client.conf #客户端文件，测试用cp /usr/local/src/fastdfs/conf/http.conf /etc/fdfs/ #供nginx访问使用cp /usr/local/src/fastdfs/conf/mime.types /etc/fdfs/ #供nginx访问使用 安装fastdfs-nginx-module 下载fastdfs-nginx-module 解压、安装 12unzip fastdfs-nginx-module-master.zipcp /usr/local/src/fastdfs-nginx-module-master/src/mod_fastdfs.conf /etc/fdfs #复制配置文件到fdfs目录 安装nginx 下载nginx 解压、安装 12345tar -zxvf nginx-1.15.5.tar.gzcd nginx-1.15.5#添加fastdfs-nginx-module模块./configure --add-module=/usr/local/src/fastdfs-nginx-module-master/src/ make &amp;&amp; make install #编译安装 FastDFS集群部署配置 tracker配置 12345#服务器ip为 xxx.xxx.78.12, xxx.xxx.78.13vim /etc/fdfs/tracker.conf#需要修改的内容如下port=22122 # tracker服务器端口（默认22122,一般不修改）base_path=/data/fdfs/tracker #存储日志和数据的根目录 Storage配置 12345678vim /etc/fdfs/storage.conf#需要修改的内容如下port=23000 # storage服务端口（默认23000,一般不修改）base_path=/data/fdfs/storage # 数据和日志文件存储根目录store_path0=/data/fdfs/storage # 第一个存储目录tracker_server=xxx.xxx.78.12:22122 # 服务器1tracker_server=xxx.xxx.78.13:22122 # 服务器2http.server_port=8888 # http访问文件的端口(默认8888,看情况修改,和nginx中保持一致) client配置 12345vim /etc/fdfs/client.conf#需要修改的内容如下base_path=/home/moe/dfstracker_server=xxx.xxx.78.12:22122 # 服务器1tracker_server=xxx.xxx.78.13:22122 # 服务器2 配置nginx访问1234567891011121314151617181920212223vim /etc/fdfs/mod_fastdfs.conf#需要修改的内容如下tracker_server=xxx.xxx.78.12:22122 # 服务器1tracker_server=xxx.xxx.78.13:22122 # 服务器2url_have_group_name=truestore_path0=/data/fdfs/storage#配置nginx.configvim /usr/local/nginx/conf/nginx.conf#添加如下配置server &#123;listen 8888; ## 该端口为storage.conf中的http.server_port相同server_name localhost;location ~/group[0-9]/ &#123; ngx_fastdfs_module;&#125;............error_page 500 502 503 504 /50x.html;location = /50x.html &#123;root html;&#125;&#125; 启动服务、测试1234567启动之前我们还需要在防火墙开通端口vim /etc/sysconfig/iptables-A INPUT -m state --state NEW -m tcp -p tcp --dport 22122 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 23000 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8888 -j ACCEPTservice iptables restart #重启防火墙 每个服务的启动、关闭和重启操作12345678910111213141516#tracker/etc/init.d/fdfs_trackerd start #启动tracker服务/etc/init.d/fdfs_trackerd restart #重启动tracker服务/etc/init.d/fdfs_trackerd stop #停止tracker服务chkconfig fdfs_trackerd on #自启动tracker服务#storage/etc/init.d/fdfs_storaged start #启动storage服务/etc/init.d/fdfs_storaged restart #重动storage服务/etc/init.d/fdfs_storaged stop #停止动storage服务chkconfig fdfs_storaged on #自启动storage服务#nginx/usr/local/nginx/sbin/nginx #启动nginx/usr/local/nginx/sbin/nginx -s reload #重启nginx/usr/local/nginx/sbin/nginx -s stop #停止nginx 检测集群12# 会显示会有几台storage服务器,有2台就会显示 Storage 1-Storage 2的详细信息/usr/bin/fdfs_monitor /etc/fdfs/storage.conf 图片上传测试123#上传成功返回 文件访问 ID# fdfs_upload_file 客户端配置文件 上传文件路径fdfs_upload_file /etc/fdfs/client.conf /data/test.png 测试文件访问12http://xxx.xxx.78.12/group1/M00/00/00/rB9ODFvXuSiAWBYBAALSAkm_6RQ360.pnghttp://xxx.xxx.78.13/group1/M00/00/00/rB9ODFvXuSiAWBYBAALSAkm_6RQ360.png 测试nginx默认端口80 访问刚刚上传的文件，两个地址都能访问通一个文件，达到数据备份目的。 至此，FastDFS服务器部署完成 FastDFS客户端集成到SpringBoot编译获取FastDFS jar包 首先根据官方源码提示，我们先下载源码使用maven编译成jar包放到公司maven私服（Nexus），或者你本地的maven私服（也有其他ant等方式，具体请查看github）FastDFS-java-client-SDK源码下载地址12#编译jar包（解压下载的FastDFS-java-client-SDK源码，使用mvn命令需要先有maven环境）mvn clean install maven项目pom.xml中添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.csource&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt; &lt;version&gt;1.27-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 接下来我们在项目resources目录下添加fdfs_client.conf文件 123456789connect_timeout = 30network_timeout = 30charset = UTF-8http.tracker_http_port = 80http.anti_steal_token = nohttp.secret_key = 123456#前面配置的集群tracker服务器地址tracker_server = xxx.xxx.78.12:22122tracker_server = xxx.xxx.78.13:22122 代码编写 写一个上传文件对象类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @Author: maoqitian * @Date: 2018/10/26 0026 17:57 * @Description: FastDFS 文件类 */ public class FastDFSFileEntity &#123; //文件名称 private String name; //内容 private byte[] content; //文件类型 private String ext; //md5值 private String md5; //作者 private String author; public FastDFSFileEntity(String name, byte[] content, String ext, String height, String width, String author) &#123; super(); this.name = name; this.content = content; this.ext = ext; this.author = author; &#125; public FastDFSFileEntity(String name, byte[] content, String ext) &#123; super(); this.name = name; this.content = content; this.ext = ext; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public byte[] getContent() &#123; return content; &#125; public void setContent(byte[] content) &#123; this.content = content; &#125; public String getExt() &#123; return ext; &#125; public void setExt(String ext) &#123; this.ext = ext; &#125; public String getMd5() &#123; return md5; &#125; public void setMd5(String md5) &#123; this.md5 = md5; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; &#125; 编写FastDFS操作类，主要是加载初始化配置Tracker服务器，文件上传，下载，删除等操作工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/** * @Author: maoqitian * @Date: 2018/10/29 0029 9:30 * @Description: FastDFS 操作类 */ public class FastDFSClient &#123; private static org.slf4j.Logger logger = LoggerFactory.getLogger(FastDFSClient.class); //双重守护单例 private static volatile FastDFSClient mInstance; /** * 加载配置信息 **/ static &#123; try &#123; String filePath=new ClassPathResource("fdfs_client.conf").getFile().getAbsolutePath(); ClientGlobal.init(filePath); &#125;catch (Exception e)&#123; logger.error("FastDFS Client Init Fail!",e); &#125; &#125; private FastDFSClient()&#123; &#125; public static FastDFSClient getInstance()&#123; if(mInstance == null)&#123; synchronized (FastDFSClient.class)&#123; if(mInstance == null)&#123; mInstance=new FastDFSClient(); &#125; &#125; &#125; return mInstance; &#125; /** * @Author maoqitian * @Description 上传文件 * @Date 2018/10/29 0029 9:42 * @Param [fastDFSFileEntity] * @return java.lang.String[] **/ public String[] upload(FastDFSFileEntity file)&#123; logger.info("File Name: " + file.getName() + "File Length:" + file.getContent().length); NameValuePair[] metalist=new NameValuePair[1]; metalist[0]=new NameValuePair("author",file.getAuthor()); long startTime = System.currentTimeMillis(); String[] uploadResults= null; StorageClient storageClient=null; try &#123; storageClient=getTrackerClient(); uploadResults = storageClient.upload_file(file.getContent(),file.getExt(),metalist); &#125;catch (IOException e)&#123; logger.error("IO Exception when uploadind the file:"+file.getName(),e); &#125; catch (Exception e)&#123; logger.error("Non IO Exception when uploadind the file:"+file.getName(),e); &#125; logger.info("upload_file time used:" + (System.currentTimeMillis() - startTime) + " ms"); if(uploadResults==null &amp;&amp; storageClient!=null)&#123; logger.error("upload file fail, error code:" + storageClient.getErrorCode()); &#125; String groupName = uploadResults[0]; String remoteFileName = uploadResults[1]; logger.info("upload file successfully!!!" + "group_name:" + groupName + ", remoteFileName:" + " " + remoteFileName); return uploadResults; &#125; public FileInfo getFile(String groupName, String remoteFileName) &#123; try &#123; StorageClient storageClient = getTrackerClient(); return storageClient.get_file_info(groupName, remoteFileName); &#125; catch (IOException e) &#123; logger.error("IO Exception: Get File from Fast DFS failed", e); &#125; catch (Exception e) &#123; logger.error("Non IO Exception: Get File from Fast DFS failed", e); &#125; return null; &#125; public InputStream downFile(String groupName, String remoteFileName) &#123; try &#123; StorageClient storageClient = getTrackerClient(); byte[] fileByte = storageClient.download_file(groupName, remoteFileName); InputStream ins = new ByteArrayInputStream(fileByte); return ins; &#125; catch (IOException e) &#123; logger.error("IO Exception: Get File from Fast DFS failed", e); &#125; catch (Exception e) &#123; logger.error("Non IO Exception: Get File from Fast DFS failed", e); &#125; return null; &#125; /** * @Author maoqitian * @Description * @Date 2018/10/31 0031 11:19 * @Param [remoteFileName] * @return int -1 失败 0成功 **/ public int deleteFile(String remoteFileName) throws Exception &#123; StorageClient storageClient = getTrackerClient(); int i = storageClient.delete_file("group1", remoteFileName); logger.info("delete file successfully!!!" + i); return i; &#125; public StorageServer[] getStoreStorages(String groupName) throws IOException &#123; TrackerClient trackerClient = new TrackerClient(); TrackerServer trackerServer = trackerClient.getConnection(); return trackerClient.getStoreStorages(trackerServer, groupName); &#125; public ServerInfo[] getFetchStorages(String groupName, String remoteFileName) throws IOException &#123; TrackerClient trackerClient = new TrackerClient(); TrackerServer trackerServer = trackerClient.getConnection(); return trackerClient.getFetchStorages(trackerServer, groupName, remoteFileName); &#125; public String getTrackerUrl() throws IOException &#123; return "http://"+getTrackerServer().getInetSocketAddress().getHostString()+":"+ClientGlobal.getG_tracker_http_port()+"/"; &#125; /** * @Author maoqitian * @Description 获取 StorageClient * @Date 2018/10/29 0029 10:33 * @Param [] * @return org.csource.fastdfs.StorageClient **/ private StorageClient getTrackerClient() throws IOException&#123; TrackerServer trackerServer=getTrackerServer(); StorageClient storageClient=new StorageClient(trackerServer,null); return storageClient; &#125; /** * @Author maoqitian * @Description 获取 TrackerServer * @Date 2018/10/29 0029 10:34 * @Param [] * @return org.csource.fastdfs.TrackerServer **/ private TrackerServer getTrackerServer() throws IOException &#123; TrackerClient trackerClient=new TrackerClient(); TrackerServer trackerServer = trackerClient.getConnection(); return trackerServer; &#125; Controller编写，接收请求并上传文件返回文件访问路径（这里写一个文件上传的例子，其他文件下载，删除等功能可根据自己需求进行编写）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 /*** @Author maoqitian* @Description 上传文件* @Date 2018/10/30 0030 15:07* @Param [file]* @return com.gxxmt.common.utils.ResultApi**/ @RequestMapping("/upload") public ResultApi upload(@RequestParam("file") MultipartFile file) throws Exception &#123;if (file.isEmpty()) &#123; throw new RRException("上传文件不能为空");&#125;String url;//此处域名获取可以根据自需求编写String domainUrl = OSSFactory.build().getDomainPath();logger.info("配置的域名为"+domainUrl);if (StringUtils.isNotBlank(domainUrl))&#123; url = uploadFile(file,domainUrl); return ResultApi.success.put("url",url);&#125;else &#123; return ResultApi.error("域名配置为空,请先配置对象存储域名");&#125; &#125; /** * @Author maoqitian * @Description 上传文件到 FastDFS * @Date 2018/10/29 0029 11:11 * @Param [file]* @Param [domainName] 域名* @return path 文件访问路径 **/public String uploadFile(MultipartFile file,String domainName) throws IOException &#123;String[] fileAbsolutePath=&#123;&#125;;String fileName=file.getOriginalFilename();String ext=fileName.substring(fileName.lastIndexOf(".")+1);byte[] file_buff=null;InputStream inputStream = file.getInputStream();if(inputStream!=null)&#123; int available = inputStream.available(); file_buff=new byte[available]; inputStream.read(file_buff);&#125;inputStream.close();FastDFSFileEntity fastDFSFileEntity=new FastDFSFileEntity(fileName,file_buff,ext);try &#123; fileAbsolutePath=FastDFSClient.getInstance().upload(fastDFSFileEntity); logger.info(fileAbsolutePath.toString());&#125;catch (Exception e)&#123; logger.error("upload file Exception!",e); throw new RRException("文件上传出错"+e);&#125;if(fileAbsolutePath == null)&#123; logger.error("upload file failed,please upload again!"); throw new RRException("文件上传失败，请重新上传");&#125;String path=domainName+fileAbsolutePath[0]+ "/"+fileAbsolutePath[1];return path; &#125; 测试部署成果 上传一个图片，由日志打印我们可以看出图片已经上传成功 测试访问上传的图片 最后说点 到此，FastDFS服务器集群部署和集成客户端到SpringBoot中已经完成，以后我们就可以愉快的使用FastDFS服务保存我们的图片等并备份。如果文章中有写得不对的地方，请给我留言指出，大家一起学习进步。如果觉得我的文章给予你帮助，也请给我一个喜欢和关注。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>FastDFS</tag>
        <tag>spring boot</tag>
        <tag>Java</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 源码编译]]></title>
    <url>%2F2019%2F01%2F10%2FAndroid-source-code-compilation%2F</url>
    <content type="text"><![CDATA[android源码编译的四个流程:1.源码下载;2.构建编译环境;3.编译源码;4运行. Ubuntu 18.04（虚拟机）环境下编译Android 源码源码下载 首先确保自己已经安装了Git. 123sudo apt-get install git git config –global user.email “test@test.com” git config –global user.name “test” 使用清华大学镜像 Android 镜像使用帮助 首先要下载repo 工具 123456mkdir ~/binPATH=~/bin:$PATHcurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo//拒绝连接可以使用tuna的git-repo镜像详情查看网址https://mirrors.tuna.tsinghua.edu.cn/help/git-repo/ 使用每月更新的初始化包 下载地址 每月更新的初始化包 由于所有代码都是从隐藏的 .repo 目录中 checkout 出来的，所以只保留了 .repo 目录，下载后解压 再 repo sync 一遍即可得到完整的目录 12345678使用方法如下:wget -c https://mirrors.tuna.tsinghua.edu.cn/aosp-mo nthly/aosp-latest.tar # 下载初始化包tar xf aosp-latest.tarcd AOSP # 解压得到的 AOSP 工程目录# 这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录repo sync # 正常同步一遍即可得到完整目录# 或 repo sync -l 仅checkout代码 构建编译环境硬件要求: 64位的操作系统只能编译2.3.x以上的版本,如果你想要编译2.3.x以下的,那么需要32位的操作系统. 磁盘空间越多越好,至少在100GB以上.意思就是,你可以去买个大点的硬盘了啊 如果你想要在是在虚拟机运行linux,那么至少需要16GB的RAM/swap. 软件要求 安装 openJDK 8 12sudo apt-get updatesudo apt-get install openjdk-8-jdk 依赖设置: 12345678910sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386 sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-devsudo apt-get install git-core gnupg flex bison gperf build-essential sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib sudo apt-get install libc6-dev-i386 sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev sudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4sudo apt-get install lib32z-dev ccache 依赖设置中有可能会出现“无法定位软件包 libesd0-dev” 这个问题 1234解决方案：在etc/apt 的sources.list 添加镜像源 deb http://archive.ubuntu.com/ubuntu/ trusty main universe restricted multiverse然后 sudo apt-get update 接着继续使用该命令安装就可以了 操作系统要求 Android版本 | 编译要求的Ubuntu最低版本 —|— Android 6.0至AOSP master | Ubuntu 14.04 Android 2.3.x至Android 5.x | Ubuntu 12.04 Android 1.5至Android 2.2.x | Ubuntu 10.04 JDK版本要求 Android版本 编译要求的JDK版本 AOSP的Android主线 OpenJDK 8 Android 5.x至android 6.0 Oracle JDK 7 Android 2.3.x至Android 4.4.x Oracle JDK 6 Android 1.5至Android 2.2.x Oracle JDK 5 官方编译环境搭建文档地址 搭建编译环境 初始化编译环境 123source build/envsetup.sh 或者. build/envsetup.sh 选择目标 1. lunch aosp_arm64-eng 该命令表示针对模拟器进行完整编译，并且所有调试功能均处于启用状态。 如果您没有提供任何参数就运行命令，lunch 将提示您从菜单中选择一个目标。 所有编译目标都采用 BUILD-BUILDTYPE 形式，其中 BUILD 是表示特定功能组合的代号。 BUILDTYPE 是以下类型之一： 编译类型 | 使用情况 ---|--- user | 权限受限；适用于生产环境（没有root权和dedug等） userdebug |在user版本的基础上开放了root权限和debug权限. eng | 开发工程师的版本,拥有最大的权限,此外还附带了许多debug工具 编译源码 您可以使用make编译任何代码。GNUMake可以借助 -jN参数处理并行任务，通常使用的任务数N介于编译时所用计算机上硬件线程数的1-2倍之间。例如，在一台双核 E5520 计算机（2 个 CPU，每个 CPU 4 个内核，每个内核2个线程）上，要实现最快的编译速度，可以使用介于make -j16 到 make -j32 之间的命令。 1make -j8 编译中 编译完成 运行模拟器 1234567//依次输入以下命令（如果是在编译成功源码之后直接想运行模拟器，则直接输入emulator命令就行，因为前面编译源码已经输入过以上两条命令）. build/envsetup.shlunch(选择刚才你编译源码设置的目标版本)emulator 将源码导入Android Studio 查看 编译idegen 12source build/envsetup.sh // 将执行文件设置为临时变量mmm development/tools/idegen/ //生成idegen.jar文件（#### build completed successfully (49 seconds) #### 标识生成idegen.jar文件） 执行脚本 idegen.sh 1. development/tools/idegen/idegen.sh 看到下图，表示编译idegen完成，执行成功后在asop的根目录下生成android.ipr和android.iml两个个文件： android.ipr 一般保存了工程相关的设置，比如modules和modules libraries的路径，编译器配置，入口点等。 android.iml 用来描述modules。它包括modules路径、 依赖关系，顺序设置等。一个项目可以包含多个 *.iml 文件。 打开Android studio，点击File&gt;Open，选择刚刚生成的android.ipr导入就可以了，依据个人机子性能问题，导入时间有快有慢。 编译中遇到的坑 Error: library-pathout/host/linux-x86/lib64/libsepolwrap.so does not exist 解决 ： 1.重新同步代码 并加入sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-dev2.确认是否配置好了JDK的环境变量 openJDK 配置环境变量方法 123456781.用gedit文本编辑器在/etc/profile中添加环境变量：命令 ： sudo gedit /etc/profile2.在打开的/etc/profile文件末尾添加下面几行：export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 最后说点 到此，Android源码编译完成，源码编译是一个需要耐心的过程，希望看到文章的你也可以编译成功。文章中如果有错误，请大家给我提出来，大家一起学习进步，如果觉得我的文章给予你帮助，也请给我一个喜欢或者关注。 参考资料 搭建编译环境 动手实现Android源码（AOSP）的下载、编译、运行、导入、调试 Android 镜像使用帮助]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码编译</tag>
      </tags>
  </entry>
</search>
